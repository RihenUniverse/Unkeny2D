ANALYSE DE CODE - COLLECTION AVEC M√âTADONN√âES
R√©pertoire de base: E:\Projets\2026\Unkeny2D
M√âTADONN√âES POUR RECONSTRUCTION:
{
  "base_directory": "E:\\Projets\\2026\\Unkeny2D",
  "included_extensions": [
    "cpp",
    "h",
    "jenga"
  ],
  "excluded_extensions": [],
  "included_paths": [],
  "excluded_paths": [],
  "included_files": [],
  "excluded_files": [],
  "structure": {
    ".": [
      "Unkeny2D.jenga"
    ],
    "Core\\Logger": [
      "Core\\Logger\\Logger.jenga"
    ],
    "Core\\Logger\\src\\Logger": [
      "Core\\Logger\\src\\Logger\\AsyncLogger.cpp",
      "Core\\Logger\\src\\Logger\\AsyncLogger.h",
      "Core\\Logger\\src\\Logger\\Export.h",
      "Core\\Logger\\src\\Logger\\Formatter.cpp",
      "Core\\Logger\\src\\Logger\\Formatter.h",
      "Core\\Logger\\src\\Logger\\Log.cpp",
      "Core\\Logger\\src\\Logger\\Log.h",
      "Core\\Logger\\src\\Logger\\Logger.cpp",
      "Core\\Logger\\src\\Logger\\Logger.h",
      "Core\\Logger\\src\\Logger\\LogLevel.cpp",
      "Core\\Logger\\src\\Logger\\LogLevel.h",
      "Core\\Logger\\src\\Logger\\LogMessage.cpp",
      "Core\\Logger\\src\\Logger\\LogMessage.h",
      "Core\\Logger\\src\\Logger\\Pattern.h",
      "Core\\Logger\\src\\Logger\\Registry.cpp",
      "Core\\Logger\\src\\Logger\\Registry.h",
      "Core\\Logger\\src\\Logger\\Sink.h"
    ],
    "Core\\Logger\\src\\Logger\\Filters": [
      "Core\\Logger\\src\\Logger\\Filters\\LevelFilter.cpp",
      "Core\\Logger\\src\\Logger\\Filters\\LevelFilter.h",
      "Core\\Logger\\src\\Logger\\Filters\\PatternFilter.cpp",
      "Core\\Logger\\src\\Logger\\Filters\\PatternFilter.h",
      "Core\\Logger\\src\\Logger\\Filters\\ThreadFilter.cpp",
      "Core\\Logger\\src\\Logger\\Filters\\ThreadFilter.h"
    ],
    "Core\\Logger\\src\\Logger\\Sinks": [
      "Core\\Logger\\src\\Logger\\Sinks\\AsyncSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\AsyncSink.h",
      "Core\\Logger\\src\\Logger\\Sinks\\ConsoleSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\ConsoleSink.h",
      "Core\\Logger\\src\\Logger\\Sinks\\DailyFileSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\DailyFileSink.h",
      "Core\\Logger\\src\\Logger\\Sinks\\DistributingSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\DistributingSink.h",
      "Core\\Logger\\src\\Logger\\Sinks\\FileSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\FileSink.h",
      "Core\\Logger\\src\\Logger\\Sinks\\NullSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\NullSink.h",
      "Core\\Logger\\src\\Logger\\Sinks\\RotatingFileSink.cpp",
      "Core\\Logger\\src\\Logger\\Sinks\\RotatingFileSink.h"
    ],
    "Core\\Maths": [
      "Core\\Maths\\Maths.jenga"
    ],
    "Core\\Maths\\src\\Maths": [
      "Core\\Maths\\src\\Maths\\MathConstants.h",
      "Core\\Maths\\src\\Maths\\Matrix3x3.cpp",
      "Core\\Maths\\src\\Maths\\Matrix3x3.h",
      "Core\\Maths\\src\\Maths\\Random.cpp",
      "Core\\Maths\\src\\Maths\\Random.h",
      "Core\\Maths\\src\\Maths\\Vector2.cpp",
      "Core\\Maths\\src\\Maths\\Vector2.h"
    ],
    "Core\\Maths\\tests": [
      "Core\\Maths\\tests\\ConstantsTest.cpp",
      "Core\\Maths\\tests\\Matrix3x3Test.cpp",
      "Core\\Maths\\tests\\RandomTest.cpp",
      "Core\\Maths\\tests\\Vector2Test.cpp"
    ],
    "Core\\Nkentseu": [
      "Core\\Nkentseu\\Nkentseu.jenga"
    ],
    "Core\\Nkentseu\\src\\Nkentseu": [
      "Core\\Nkentseu\\src\\Nkentseu\\Sleep.cpp",
      "Core\\Nkentseu\\src\\Nkentseu\\Sleep.h",
      "Core\\Nkentseu\\src\\Nkentseu\\Types.h"
    ],
    "Core\\Nkentseu\\src\\Nkentseu\\Config": [
      "Core\\Nkentseu\\src\\Nkentseu\\Config\\Architecture.h",
      "Core\\Nkentseu\\src\\Nkentseu\\Config\\Compiler.h",
      "Core\\Nkentseu\\src\\Nkentseu\\Config\\Export.h",
      "Core\\Nkentseu\\src\\Nkentseu\\Config\\Platform.h"
    ],
    "Core\\Unkeny2D": [
      "Core\\Unkeny2D\\Unkeny2D.jenga"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Unkeny.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Events": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Events\\Event.h",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Events\\EventManager.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Events\\EventManager.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Android": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Android\\WindowAndroid.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Android\\WindowAndroid.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Emscripten": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Emscripten\\WindowEmscripten.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Emscripten\\WindowEmscripten.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\iOS": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\iOS\\WindowIOS.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Linux": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Linux\\WindowXCB.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Linux\\WindowXCB.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\macOS": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\macOS\\WindowMacOS.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Win32": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Win32\\WindowWin32.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Platform\\Win32\\WindowWin32.h"
    ],
    "Core\\Unkeny2D\\src\\Unkeny2D\\Window": [
      "Core\\Unkeny2D\\src\\Unkeny2D\\Window\\Window.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Window\\Window.h",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Window\\WindowManager.cpp",
      "Core\\Unkeny2D\\src\\Unkeny2D\\Window\\WindowManager.h"
    ],
    "Sandbox": [
      "Sandbox\\Sandbox.jenga"
    ],
    "Sandbox\\src": [
      "Sandbox\\src\\Main.cpp"
    ]
  },
  "timestamp": "1770235341.5485601"
}
================================================================================


üìÅ DOSSIER: .
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Unkeny2D.jenga]
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# FICHIER: workspace.jenga
# DESCRIPTION: Fichier de configuration principal du workspace pour le syst√®me
#              de build Jenga. D√©finit les configurations globales, plateformes
#              et projets inclus.
# AUTEUR: Rihen
# DATE: 2026
# -----------------------------------------------------------------------------

from Jenga.core.api import *

with workspace("Unkeny2D"):
    # D√©finition des configurations de build disponibles
    configurations(["Debug", "Release"])
    
    # Plateformes cibles support√©es
    platforms(["Windows", "Linux", "Android", "Emscripten"])
    
    # Projet de d√©marrage par d√©faut
    startproject("Sandbox")
    
    # Configuration de la toolchain par d√©faut
    with toolchain("default", "clang++"):
        cppcompiler("clang++")
        ccompiler("clang")
    
    # Inclusion du projet Logger (biblioth√®que de loggin)
    with include("Core/Nkentseu/Nkentseu.jenga"):
        pass
    
    # Inclusion du projet Logger (biblioth√®que de loggin)
    with include("Core/Logger/Logger.jenga"):
        pass
    
    # Inclusion du projet Maths (biblioth√®que de math)
    with include("Core/Maths/Maths.jenga"):
        pass
    
    # Inclusion du projet Unkeny2D (biblioth√®que principale)
    with include("Core/Unkeny2D/Unkeny2D.jenga"):
        pass
    
    # Inclusion du projet Sandbox (application de test)
    with include("Sandbox/Sandbox.jenga"):
        pass
==================================================


üìÅ DOSSIER: Core\Logger
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Logger\Logger.jenga]
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# FICHIER: Core/Logger/Logger.jenga
# DESCRIPTION: Configuration du projet Logger (biblioth√®que statique de log).
#              D√©finit les logging.
# AUTEUR: Rihen
# DATE: 2026
# -----------------------------------------------------------------------------

from Jenga.core.api import *

with project("Logger"):
    # Type de projet: biblioth√®que statique
    staticlib()
    
    # Langage et version C++
    language("C++")
    cppdialect("C++17")
    
    # Fichiers sources globaux
    files([
        "src/**.cpp",
    ])
    
    # R√©pertoires d'inclusion publics
    includedirs([
        "src",
        "%{Nkentseu.location}/src",
    ])
    dependson(["Nkentseu"])
    
    # Configuration sp√©cifique √† Windows
    with filter("system:Windows"):
        links(["gdi32", "user32"])
        addldflag("-lgdi32")
        addldflag("-luser32")
    
    # Configuration sp√©cifique √† Linux
    with filter("system:Linux"):
        links(["xcb"])
    
    # Configuration sp√©cifique √† Android
    with filter("system:Android"):
        links(["android", "log"])
    
    # Configuration sp√©cifique √† Emscripten
    with filter("system:Emscripten"):
        pass
    
    # Configuration des r√©pertoires de sortie
    targetdir("%{wks.location}/Build/Lib/%{cfg.buildcfg}")
    objdir("%{wks.location}/Build/Obj/%{cfg.buildcfg}/%{prj.name}")
    
    # Configuration Debug
    with filter("configurations:Debug"):
        defines(["DEBUG", "_DEBUG"])
        optimize("Off")
        symbols("On")
    
    # Configuration Release
    with filter("configurations:Release"):
        defines(["NDEBUG", "RELEASE"])
        optimize("Speed")
        symbols("Off")
==================================================


üìÅ DOSSIER: Core\Logger\src\Logger
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Logger\src\Logger\AsyncLogger.cpp]
==================================================
#include "Logger/AsyncLogger.h"

namespace nkentseu {

} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\AsyncLogger.h]
==================================================
#ifndef NKENTSEU_LOGGER_ASYNCLOGGER_H
#define NKENTSEU_LOGGER_ASYNCLOGGER_H

#include <Logger/Logger.h>

namespace nkentseu {

class AsyncLogger {
public:
    AsyncLogger();
    ~AsyncLogger();

private:
    // Implementation
};

} // namespace nkentseu

#endif // NKENTSEU_LOGGER_ASYNCLOGGER_H
==================================================


[FICHIER: Core\Logger\src\Logger\Export.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Export.h
// DESCRIPTION: Configuration d'exportation de symboles pour le module Logger.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include <Nkentseu/Config/Export.h>
#include <Nkentseu/Config/Compiler.h>

// -----------------------------------------------------------------------------
// MACROS D'EXPORTATION/IMPORTATION POUR LOGGER
// -----------------------------------------------------------------------------

#if defined(NK_PLATFORM_WINDOWS)
    #if defined(LOGGER_BUILD_SHARED)
        #define LOGGER_API __declspec(dllexport)
    #elif defined(LOGGER_USE_SHARED)
        #define LOGGER_API __declspec(dllimport)
    #else
        #define LOGGER_API
    #endif

#elif defined(NK_COMPILER_GCC) || defined(NK_COMPILER_CLANG)
    #if defined(LOGGER_BUILD_SHARED)
        #define LOGGER_API __attribute__((visibility("default")))
    #else
        #define LOGGER_API
    #endif

#else
    #define LOGGER_API
#endif

// -----------------------------------------------------------------------------
// MACROS D'INLINING POUR LOGGER
// -----------------------------------------------------------------------------

#if defined(NK_COMPILER_MSVC)
    #define LOGGER_FORCE_INLINE __forceinline
    #define LOGGER_NO_INLINE __declspec(noinline)

#elif defined(NK_COMPILER_GCC) || defined(NK_COMPILER_CLANG)
    #define LOGGER_FORCE_INLINE __attribute__((always_inline)) inline
    #define LOGGER_NO_INLINE __attribute__((noinline))

#else
    #define LOGGER_FORCE_INLINE inline
    #define LOGGER_NO_INLINE
#endif

// Macro d'inlining standard pour Logger
#define LOGGER_INLINE inline
==================================================


[FICHIER: Core\Logger\src\Logger\Formatter.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Formatter.cpp
// DESCRIPTION: Impl√©mentation du formatter de messages de log.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Formatter.h"
#include "Logger/LogLevel.h"
#include <sstream>
#include <iomanip>
#include <iostream>
#include <ctime>

// -----------------------------------------------------------------------------
// PATTERNS PR√âD√âFINIS
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        const char* Formatter::DEFAULT_PATTERN = "[%Y-%m-%d %H:%M:%S.%e] [%L] [%n] [%t] -> %v";
        const char* Formatter::SIMPLE_PATTERN = "%v";
        const char* Formatter::DETAILED_PATTERN = "[%Y-%m-%d %H:%M:%S.%e] [%L] [%n] [thread %t] [%s:%# in %f] -> %v";
        const char* Formatter::COLOR_PATTERN = "[%Y-%m-%d %H:%M:%S.%e] [%^%L%$] [%n] [%t] -> %v";
        const char* Formatter::JSON_PATTERN = R"({"time":"%Y-%m-%dT%H:%M:%S.%fZ","level":"%l","thread":%t,"logger":"%n","file":"%s","line":%#,"function":"%f","message":"%v"})";

    } // namespace logger
} // namespace nkentseu

    // -----------------------------------------------------------------------------
    // NAMESPACE: nkentseu::logger
    // -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE Formatter
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur par d√©faut
         */
        Formatter::Formatter()
            : m_Pattern(DEFAULT_PATTERN)
            , m_TokensValid(false) {
        }
        
        /**
         * @brief Constructeur avec pattern sp√©cifique
         */
        Formatter::Formatter(const std::string& pattern)
            : m_Pattern(pattern)
            , m_TokensValid(false) {
            ParsePattern(pattern);
        }
        
        /**
         * @brief Destructeur
         */
        Formatter::~Formatter() {
        }
        
        /**
         * @brief D√©finit le pattern de formatage
         */
        void Formatter::SetPattern(const std::string& pattern) {
            if (m_Pattern != pattern) {
                m_Pattern = pattern;
                m_TokensValid = false;
            }
        }
        
        /**
         * @brief Obtient le pattern courant
         */
        const std::string& Formatter::GetPattern() const {
            return m_Pattern;
        }
        
        /**
         * @brief Formate un message de log
         */
        std::string Formatter::Format(const LogMessage& message) {
            return Format(message, false);
        }
        
        /**
         * @brief Formate un message de log avec des couleurs
         */
        std::string Formatter::Format(const LogMessage& message, bool useColors) {
            if (!m_TokensValid) {
                ParsePattern(m_Pattern);
            }
            
            std::string result;
            result.reserve(256); // Pr√©-allocation pour performance
            
            for (const auto& token : m_Tokens) {
                FormatToken(token, message, useColors, result);
            }
            
            return result;
        }
        
        /**
         * @brief Parse le pattern en tokens
         */
        void Formatter::ParsePattern(const std::string& pattern) {
            m_Tokens.clear();
            m_Tokens.reserve(pattern.size() / 2); // Estimation
            
            for (size_t i = 0; i < pattern.size(); ++i) {
                if (pattern[i] == '%' && i + 1 < pattern.size()) {
                    char next = pattern[i + 1];
                    PatternToken token;
                    
                    switch (next) {
                        case 'Y': token.type = PatternToken::Type::Year; break;
                        case 'm': token.type = PatternToken::Type::Month; break;
                        case 'd': token.type = PatternToken::Type::Day; break;
                        case 'H': token.type = PatternToken::Type::Hour; break;
                        case 'M': token.type = PatternToken::Type::Minute; break;
                        case 'S': token.type = PatternToken::Type::Second; break;
                        case 'e': token.type = PatternToken::Type::Millis; break;
                        case 'f': token.type = PatternToken::Type::Micros; break;
                        case 'l': token.type = PatternToken::Type::Level; break;
                        case 'L': token.type = PatternToken::Type::LevelShort; break;
                        case 't': token.type = PatternToken::Type::ThreadId; break;
                        case 'T': token.type = PatternToken::Type::ThreadName; break;
                        case 's': token.type = PatternToken::Type::SourceFile; break;
                        case '#': token.type = PatternToken::Type::SourceLine; break;
                        case 'F': token.type = PatternToken::Type::Function; break;
                        case 'v': token.type = PatternToken::Type::Message; break;
                        case 'n': token.type = PatternToken::Type::LoggerName; break;
                        case '%': token.type = PatternToken::Type::Percent; break;
                        case '^': token.type = PatternToken::Type::ColorStart; break;
                        case '$': token.type = PatternToken::Type::ColorEnd; break;
                        default:
                            // Token litt√©ral avec le %
                            token.type = PatternToken::Type::Literal;
                            token.value = pattern.substr(i, 2);
                            m_Tokens.push_back(token);
                            ++i;
                            continue;
                    }
                    
                    m_Tokens.push_back(token);
                    ++i; // Skip le caract√®re suivant
                } else {
                    // Token litt√©ral
                    size_t start = i;
                    while (i < pattern.size() && pattern[i] != '%') {
                        ++i;
                    }
                    
                    PatternToken token;
                    token.type = PatternToken::Type::Literal;
                    token.value = pattern.substr(start, i - start);
                    m_Tokens.push_back(token);
                    
                    --i; // Pour que la boucle incr√©mente correctement
                }
            }
            
            m_TokensValid = true;
        }
        
        /**
         * @brief Formate un token individuel
         */
        void Formatter::FormatToken(const PatternToken& token, const LogMessage& message,
                                bool useColors, std::string& result) {
            switch (token.type) {
                case PatternToken::Type::Literal:
                    result += token.value;
                    break;
                    
                case PatternToken::Type::Year: {
                    auto tm = message.GetLocalTime();
                    result += FormatNumber(tm.tm_year + 1900, 4);
                    break;
                }
                    
                case PatternToken::Type::Month: {
                    auto tm = message.GetLocalTime();
                    result += FormatNumber(tm.tm_mon + 1, 2);
                    break;
                }
                    
                case PatternToken::Type::Day: {
                    auto tm = message.GetLocalTime();
                    result += FormatNumber(tm.tm_mday, 2);
                    break;
                }
                    
                case PatternToken::Type::Hour: {
                    auto tm = message.GetLocalTime();
                    result += FormatNumber(tm.tm_hour, 2);
                    break;
                }
                    
                case PatternToken::Type::Minute: {
                    auto tm = message.GetLocalTime();
                    result += FormatNumber(tm.tm_min, 2);
                    break;
                }
                    
                case PatternToken::Type::Second: {
                    auto tm = message.GetLocalTime();
                    result += FormatNumber(tm.tm_sec, 2);
                    break;
                }
                    
                case PatternToken::Type::Millis: {
                    uint64 millis = message.GetMillis() % 1000;
                    result += FormatNumber(static_cast<int>(millis), 3);
                    break;
                }
                    
                case PatternToken::Type::Micros: {
                    uint64 micros = message.GetMicros() % 1000000;
                    result += FormatNumber(static_cast<int>(micros), 6);
                    break;
                }
                    
                case PatternToken::Type::Level:
                    result += LogLevelToString(message.level);
                    break;
                    
                case PatternToken::Type::LevelShort:
                    result += LogLevelToShortString(message.level);
                    break;
                    
                case PatternToken::Type::ThreadId: {
                    std::ostringstream oss;
                    oss << message.threadId;
                    result += oss.str();
                    break;
                }
                    
                case PatternToken::Type::ThreadName:
                    if (!message.threadName.empty()) {
                        result += message.threadName;
                    } else {
                        std::ostringstream oss;
                        oss << message.threadId;
                        result += oss.str();
                    }
                    break;
                    
                case PatternToken::Type::SourceFile:
                    if (!message.sourceFile.empty()) {
                        // Extraire juste le nom du fichier (sans chemin)
                        size_t pos = message.sourceFile.find_last_of("/\\");
                        if (pos != std::string::npos) {
                            result += message.sourceFile.substr(pos + 1);
                        } else {
                            result += message.sourceFile;
                        }
                    }
                    break;
                    
                case PatternToken::Type::SourceLine: {
                    if (message.sourceLine > 0) {
                        std::ostringstream oss;
                        oss << message.sourceLine;
                        result += oss.str();
                    }
                    break;
                }
                    
                case PatternToken::Type::Function:
                    if (!message.functionName.empty()) {
                        result += message.functionName;
                    }
                    break;
                    
                case PatternToken::Type::Message:
                    result += message.message;
                    break;
                    
                case PatternToken::Type::LoggerName:
                    if (!message.loggerName.empty()) {
                        result += message.loggerName;
                    } else {
                        result += "default";
                    }
                    break;
                    
                case PatternToken::Type::Percent:
                    result += '%';
                    break;
                    
                case PatternToken::Type::ColorStart:
                    if (useColors) {
                        result += GetANSIColor(message.level);
                    }
                    break;
                    
                case PatternToken::Type::ColorEnd:
                    if (useColors) {
                        result += GetANSIReset();
                    }
                    break;
            }
        }
        
        /**
         * @brief Formate un nombre avec padding
         */
        std::string Formatter::FormatNumber(int value, int width, char fillChar) const {
            std::ostringstream oss;
            oss << std::setw(width) << std::setfill(fillChar) << value;
            return oss.str();
        }
        
        /**
         * @brief Obtient le code couleur ANSI pour un niveau de log
         */
        std::string Formatter::GetANSIColor(LogLevel level) const {
            return LogLevelToANSIColor(level);
        }
        
        /**
         * @brief Obtient le code de fin de couleur ANSI
         */
        std::string Formatter::GetANSIReset() const {
            return "\033[0m";
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Formatter.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Formatter.h
// DESCRIPTION: Classe de formatage des messages de log avec patterns.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Export.h"
#include "Logger/LogMessage.h"
#include <string>
#include <memory>
#include <vector>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // STRUCTURE: PatternToken
        // DESCRIPTION: Token individuel dans un pattern de formatage
        // -------------------------------------------------------------------------
        struct PatternToken {
            /// Type du token
            enum class Type {
                Literal,    // Texte litt√©ral
                Year,       // %Y - Ann√©e (4 chiffres)
                Month,      // %m - Mois (2 chiffres)
                Day,        // %d - Jour (2 chiffres)
                Hour,       // %H - Heure (24h, 2 chiffres)
                Minute,     // %M - Minute (2 chiffres)
                Second,     // %S - Seconde (2 chiffres)
                Millis,     // %e - Millisecondes (3 chiffres)
                Micros,     // %f - Microsecondes (6 chiffres)
                Level,      // %l - Niveau de log (texte)
                LevelShort, // %L - Niveau de log (court)
                ThreadId,   // %t - ID du thread
                ThreadName, // %T - Nom du thread
                SourceFile, // %s - Fichier source
                SourceLine, // %# - Ligne source
                Function,   // %f - Fonction
                Message,    // %v - Message
                LoggerName, // %n - Nom du logger
                Percent,    // %% - Pourcentage litt√©ral
                ColorStart, // D√©but de couleur
                ColorEnd    // Fin de couleur
            };
            
            Type type;
            std::string value; // Pour les tokens litt√©raux
        };

        // -------------------------------------------------------------------------
        // CLASSE: Formatter
        // DESCRIPTION: Formate les messages de log selon un pattern
        // -------------------------------------------------------------------------
        class LOGGER_API Formatter {
        public:
            // ---------------------------------------------------------------------
            // CONSTRUCTEURS ET DESTRUCTEUR
            // ---------------------------------------------------------------------
            
            /**
             * @brief Constructeur par d√©faut (pattern par d√©faut)
             */
            Formatter();
            
            /**
             * @brief Constructeur avec pattern sp√©cifique
             * @param pattern Pattern de formatage
             */
            explicit Formatter(const std::string& pattern);
            
            /**
             * @brief Destructeur
             */
            ~Formatter();
            
            // ---------------------------------------------------------------------
            // CONFIGURATION DU PATTERN
            // ---------------------------------------------------------------------
            
            /**
             * @brief D√©finit le pattern de formatage
             * @param pattern Pattern √† utiliser
             */
            void SetPattern(const std::string& pattern);
            
            /**
             * @brief Obtient le pattern courant
             * @return Pattern de formatage
             */
            const std::string& GetPattern() const;
            
            // ---------------------------------------------------------------------
            // FORMATAGE
            // ---------------------------------------------------------------------
            
            /**
             * @brief Formate un message de log
             * @param message Message √† formater
             * @return Message format√©
             */
            std::string Format(const LogMessage& message);
            
            /**
             * @brief Formate un message de log avec des couleurs
             * @param message Message √† formater
             * @param useColors true pour inclure les codes couleur
             * @return Message format√©
             */
            std::string Format(const LogMessage& message, bool useColors);
            
            // ---------------------------------------------------------------------
            // PATTERNS PR√âD√âFINIS
            // ---------------------------------------------------------------------
            
            /**
             * @brief Pattern par d√©faut (similaire √† spdlog)
             */
            static const char* DEFAULT_PATTERN;
            
            /**
             * @brief Pattern simple (juste le message)
             */
            static const char* SIMPLE_PATTERN;
            
            /**
             * @brief Pattern d√©taill√© (avec toutes les informations)
             */
            static const char* DETAILED_PATTERN;
            
            /**
             * @brief Pattern avec couleurs (pour console)
             */
            static const char* COLOR_PATTERN;
            
            /**
             * @brief Pattern JSON (pour traitement automatis√©)
             */
            static const char* JSON_PATTERN;

        private:
            // ---------------------------------------------------------------------
            // M√âTHODES PRIV√âES
            // ---------------------------------------------------------------------
            
            /**
             * @brief Parse le pattern en tokens
             * @param pattern Pattern √† parser
             */
            void ParsePattern(const std::string& pattern);
            
            /**
             * @brief Formate un token individuel
             * @param token Token √† formater
             * @param message Message source
             * @param useColors true pour inclure les couleurs
             * @param result R√©sultat en construction
             */
            void FormatToken(const PatternToken& token, const LogMessage& message,
                            bool useColors, std::string& result);
            
            /**
             * @brief Formate un nombre avec padding
             * @param value Valeur √† formater
             * @param width Largeur minimum
             * @param fillChar Caract√®re de remplissage
             * @return Cha√Æne format√©e
             */
            std::string FormatNumber(int value, int width = 2, char fillChar = '0') const;
            
            /**
             * @brief Obtient le code couleur ANSI pour un niveau de log
             * @param level Niveau de log
             * @return Code couleur ANSI
             */
            std::string GetANSIColor(LogLevel level) const;
            
            /**
             * @brief Obtient le code de fin de couleur ANSI
             * @return Code de fin de couleur
             */
            std::string GetANSIReset() const;
            
            // ---------------------------------------------------------------------
            // VARIABLES MEMBRE PRIV√âES
            // ---------------------------------------------------------------------
            
            /// Pattern de formatage
            std::string m_Pattern;
            
            /// Tokens pars√©s
            std::vector<PatternToken> m_Tokens;
            
            /// Indicateur si les tokens sont valides
            bool m_TokensValid;
        };

        // -------------------------------------------------------------------------
        // TYPE ALIAS POUR LES FORMATTERS
        // -------------------------------------------------------------------------
        
        /// Type pour les pointeurs uniques de formatters
        using FormatterPtr = std::unique_ptr<Formatter>;

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Log.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/NkentseuLogger.cpp
// DESCRIPTION: Impl√©mentation du logger par d√©faut avec API fluide.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Log.h"
#include "Logger/Sinks/ConsoleSink.h"
#include "Logger/Sinks/FileSink.h"
#include <cstdarg>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // INITIALISATION DES VARIABLES STATIQUES
        // -------------------------------------------------------------------------
        
        bool NkentseuLogger::s_Initialized = false;

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE NkentseuLogger
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur priv√©
         */
        NkentseuLogger::NkentseuLogger(const std::string& name)
            : Logger(name) {
            
            // Ajouter un sink console par d√©faut avec couleurs
            auto consoleSink = std::make_shared<ConsoleSink>();
            consoleSink->SetColorEnabled(true);
            AddSink(consoleSink);
            
            // Ajouter un sink fichier par d√©faut
            auto fileSink = std::make_shared<FileSink>("logs/app.log");
            AddSink(fileSink);
            
            // Configuration par d√©faut
            SetLevel(LogLevel::Info);
            SetPattern(Formatter::DEFAULT_PATTERN);
        }
        
        /**
         * @brief Destructeur
         */
        NkentseuLogger::~NkentseuLogger() {
            Flush();
        }
        
        /**
         * @brief Obtient l'instance singleton
         */
        NkentseuLogger& NkentseuLogger::Instance() {
            static NkentseuLogger instance;
            s_Initialized = true;
            return instance;
        }
        
        /**
         * @brief Initialise le logger par d√©faut
         */
        void NkentseuLogger::Initialize(const std::string& name, const std::string& pattern, LogLevel level) {
            auto& instance = Instance();
            
            if (instance.GetName() != name && !name.empty()) {
                instance.SetName(name);
            }
            
            instance.SetPattern(pattern);
            instance.SetLevel(level);
        }
        
        /**
         * @brief Nettoie le logger par d√©faut
         */
        void NkentseuLogger::Shutdown() {
            auto& instance = Instance();
            instance.Flush();
            instance.ClearSinks();
        }
        
        /**
         * @brief Configure les informations de source
         */
        // SourceContext NkentseuLogger::Source(const char* file, int line, const char* function) const {
        //     return SourceContext(file, line, function);
        // }
        
        /**
         * @brief Configure le nom du logger
         */
        NkentseuLogger& NkentseuLogger::Named(const std::string& name) {
            SetName(name);
            return *this;
        }
        
        /**
         * @brief Configure le niveau de log
         */
        NkentseuLogger& NkentseuLogger::Level(LogLevel level) {
            SetLevel(level);
            return *this;
        }
        
        /**
         * @brief Configure le pattern
         */
        NkentseuLogger& NkentseuLogger::Pattern(const std::string& pattern) {
            SetPattern(pattern);
            return *this;
        }


        NkentseuLogger& NkentseuLogger::Source(const char* sourceFile, uint32 sourceLine, const char* functionName) {
            Logger::Source(sourceFile, sourceLine, functionName);
            return *this;
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Log.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/NkentseuLogger.h
// DESCRIPTION: Logger par d√©faut avec API fluide pour un usage simplifi√©.
//              Fournit une instance singleton et des m√©thodes cha√Ænables.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Logger.h"
#include <memory>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: NkentseuLogger
        // DESCRIPTION: Logger par d√©faut singleton avec API fluide
        // -------------------------------------------------------------------------
        class LOGGER_API NkentseuLogger : public Logger {
            public:
                // ---------------------------------------------------------------------
                // M√âTHODES STATIQUES (SINGLETON)
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Obtient l'instance singleton du logger par d√©faut
                 * @return R√©f√©rence √† l'instance du logger par d√©faut
                 */
                static NkentseuLogger& Instance();
                
                /**
                 * @brief Initialise le logger par d√©faut
                 * @param name Nom du logger (optionnel, "default" par d√©faut)
                 * @param pattern Pattern de formatage (optionnel)
                 * @param level Niveau de log (optionnel, Info par d√©faut)
                 */
                static void Initialize(const std::string& name = "default",
                                    const std::string& pattern = Formatter::DEFAULT_PATTERN,
                                    LogLevel level = LogLevel::Info);
                
                /**
                 * @brief Nettoie et d√©truit le logger par d√©faut
                 */
                static void Shutdown();
                
                // ---------------------------------------------------------------------
                // API FLUIDE
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Configure les informations de source pour le prochain log
                 * @param file Fichier source
                 * @param line Ligne source
                 * @param function Fonction source
                 * @return Objet SourceContext pour cha√Ænage
                 */
                // SourceContext Source(const char* file, int line, const char* function) const;
                
                /**
                 * @brief Configure le nom du logger (retourne *this pour cha√Ænage)
                 */
                NkentseuLogger& Named(const std::string& name);
                
                /**
                 * @brief Configure le niveau de log (retourne *this pour cha√Ænage)
                 */
                NkentseuLogger& Level(LogLevel level);
                
                /**
                 * @brief Configure le pattern (retourne *this pour cha√Ænage)
                 */
                NkentseuLogger& Pattern(const std::string& pattern);


                virtual NkentseuLogger& Source(const char* sourceFile = nullptr, uint32 sourceLine = 0, const char* functionName = nullptr) override;

            private:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS PRIV√âS (SINGLETON)
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur priv√©
                 */
                explicit NkentseuLogger(const std::string& name = "default");
                
                /**
                 * @brief Destructeur priv√©
                 */
                ~NkentseuLogger();
                
                /**
                 * @brief Constructeur de copie supprim√©
                 */
                NkentseuLogger(const NkentseuLogger&) = delete;
                
                /**
                 * @brief Op√©rateur d'affectation supprim√©
                 */
                NkentseuLogger& operator=(const NkentseuLogger&) = delete;
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE
                // ---------------------------------------------------------------------
                
                /// Indicateur d'initialisation
                static bool s_Initialized;
        };

    } // namespace logger
} // namespace nkentseu

// -----------------------------------------------------------------------------
// MACRO PRINCIPALE POUR UN USAGE SIMPLIFI√â
// -----------------------------------------------------------------------------

/// Macro pour obtenir le logger par d√©faut avec informations de source
#define logs nkentseu::logger::NkentseuLogger::Instance().Source(__FILE__, __LINE__, __FUNCTION__)

/// Macros raccourcis pour un usage direct (sans informations de source)
#define NK_LOG_TRACE(...) nkentseu::logger::NkentseuLogger::Instance().Trace(__VA_ARGS__)
#define NK_LOG_DEBUG(...) nkentseu::logger::NkentseuLogger::Instance().Debug(__VA_ARGS__)
#define NK_LOG_INFO(...)  nkentseu::logger::NkentseuLogger::Instance().Info(__VA_ARGS__)
#define NK_LOG_WARN(...)  nkentseu::logger::NkentseuLogger::Instance().Warn(__VA_ARGS__)
#define NK_LOG_ERROR(...) nkentseu::logger::NkentseuLogger::Instance().Error(__VA_ARGS__)
#define NK_LOG_CRITICAL(...) nkentseu::logger::NkentseuLogger::Instance().Critical(__VA_ARGS__)
#define NK_LOG_FATAL(...) nkentseu::logger::NkentseuLogger::Instance().Fatal(__VA_ARGS__)
==================================================


[FICHIER: Core\Logger\src\Logger\Logger.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Logger.cpp
// DESCRIPTION: Impl√©mentation de la classe Logger principale.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Logger.h"
#include "Logger/LogMessage.h"
#include <cstdarg>
#include <chrono>
#include <iostream>
#include <thread>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE Logger
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur de logger avec nom
         * @param name Nom du logger
         */
        Logger::Logger(const std::string& name)
            : m_Name(name)
            , m_Level(LogLevel::Info)
            , m_Enabled(true)
            , m_Formatter(std::make_unique<Formatter>()) {
        }
        
        /**
         * @brief Destructeur du logger
         */
        Logger::~Logger() {
            Flush();
        }
        
        /**
         * @brief Ajoute un sink au logger
         * @param sink Sink √† ajouter (partag√©)
         */
        void Logger::AddSink(std::shared_ptr<ISink> sink) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Sinks.push_back(sink);
        }
        
        /**
         * @brief Supprime tous les sinks du logger
         */
        void Logger::ClearSinks() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Sinks.clear();
        }
        
        /**
         * @brief Obtient le nombre de sinks attach√©s
         * @return Nombre de sinks
         */
        size_t Logger::GetSinkCount() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Sinks.size();
        }
        
        /**
         * @brief D√©finit le formatter pour tous les sinks
         * @param formatter Formatter √† utiliser
         */
        void Logger::SetFormatter(std::unique_ptr<Formatter> formatter) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Formatter = std::move(formatter);
        }
        
        /**
         * @brief D√©finit le pattern de formatage
         * @param pattern Pattern √† utiliser
         */
        void Logger::SetPattern(const std::string& pattern) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_Formatter) {
                m_Formatter->SetPattern(pattern);
            }
        }
        
        /**
         * @brief D√©finit le niveau de log minimum
         * @param level Niveau minimum √† logger
         */
        void Logger::SetLevel(LogLevel level) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Level = level;
        }
        
        /**
         * @brief Obtient le niveau de log courant
         * @return Niveau de log
         */
        LogLevel Logger::GetLevel() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Level;
        }
        
        /**
         * @brief V√©rifie si un niveau devrait √™tre logg√©
         * @param level Niveau √† v√©rifier
         * @return true si le niveau est >= niveau minimum, false sinon
         */
        bool Logger::ShouldLog(LogLevel level) const {
            if (!m_Enabled) return false;
            return level >= m_Level;
        }
        
        /**
         * @brief Log interne avec informations de source
         */
        void Logger::LogInternal(LogLevel level, const std::string& message, const char* sourceFile, uint32 sourceLine, const char* functionName) {
            if (!m_Enabled || level < m_Level) return;
            
            // Cr√©ation du message de log avec nom du logger
            LogMessage msg;
            msg.timestamp = std::chrono::duration_cast<std::chrono::nanoseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            msg.threadId = static_cast<uint32>(std::hash<std::thread::id>{}(std::this_thread::get_id()));
            msg.level = level;
            msg.message = message;
            msg.loggerName = m_Name;  // Nom du logger ajout√© ici
            
            if (sourceFile) msg.sourceFile = sourceFile;
            if (sourceLine > 0) msg.sourceLine = sourceLine;
            if (functionName) msg.functionName = functionName;
            
            // Obtention du nom du thread si disponible
            #if defined(__APPLE__) || defined(__linux__)
                char threadName[256] = {0};
                if (pthread_getname_np(pthread_self(), threadName, sizeof(threadName)) == 0) {
                    msg.threadName = threadName;
                }
            #endif
            
            // Formatage du message
            std::string formatted;
            {
                std::lock_guard<std::mutex> lock(m_Mutex);
                if (m_Formatter) {
                    formatted = m_Formatter->Format(msg);
                } else {
                    formatted = message; // Fallback
                }
            }
            
            // Envoi √† tous les sinks
            std::lock_guard<std::mutex> lock(m_Mutex);
            for (auto& sink : m_Sinks) {
                if (sink) {
                    sink->GetFormatter()->SetPattern(m_Formatter->GetPattern());
                    sink->Log(msg);
                }
            }
        }
        
        /**
         * @brief Formatage variadique
         */
        std::string Logger::FormatString(const char* format, va_list args) {
            // D√©termination de la taille n√©cessaire
            va_list argsCopy;
            va_copy(argsCopy, args);
            int size = vsnprintf(nullptr, 0, format, argsCopy);
            va_end(argsCopy);
            
            if (size < 0) return "";
            
            // Allocation et formatage
            std::string result(size + 1, '\0');
            vsnprintf(&result[0], result.size(), format, args);
            result.resize(size); // Retirer le null terminator
            
            return result;
        }
        
        /**
         * @brief Log avec format string (style printf)
         */
        void Logger::Log(LogLevel level, const char* format, ...) {
            if (!ShouldLog(level)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(level, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log avec format string et informations de source
         */
        void Logger::Log(LogLevel level, const char* file, int line, const char* func, const char* format, ...) {
            if (!ShouldLog(level)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(level, message, file, line, func);
        }

        /**
         * @brief Log avec message string et informations de source
         */
        void Logger::Log(LogLevel level, const char* file, int line, const char* func, const std::string& message) {
            if (!ShouldLog(level)) return;
            LogInternal(level, message, file, line, func);
        }

        /**
         * @brief Log avec format string, informations de source et va_list
         */
        void Logger::Log(LogLevel level, const char* file, int line, const char* func, const char* format, va_list args) {
            if (!ShouldLog(level)) return;
            
            std::string message = FormatString(format, args);
            LogInternal(level, message, file, line, func);
        }

        /**
         * @brief Log trace avec format string
         */
        void Logger::Trace(const char* format, ...) {
            if (!ShouldLog(LogLevel::Trace)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Trace, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log debug avec format string
         */
        void Logger::Debug(const char* format, ...) {
            if (!ShouldLog(LogLevel::Debug)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Debug, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log info avec format string
         */
        void Logger::Info(const char* format, ...) {
            if (!ShouldLog(LogLevel::Info)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Info, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log warning avec format string
         */
        void Logger::Warn(const char* format, ...) {
            if (!ShouldLog(LogLevel::Warn)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Warn, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log error avec format string
         */
        void Logger::Error(const char* format, ...) {
            if (!ShouldLog(LogLevel::Error)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Error, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log critical avec format string
         */
        void Logger::Critical(const char* format, ...) {
            if (!ShouldLog(LogLevel::Critical)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Critical, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log fatal avec format string
         */
        void Logger::Fatal(const char* format, ...) {
            if (!ShouldLog(LogLevel::Fatal)) return;
            
            va_list args;
            va_start(args, format);
            std::string message = FormatString(format, args);
            va_end(args);
            
            LogInternal(LogLevel::Fatal, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log avec stream style
         */
        void Logger::Log(LogLevel level, const std::string& message) {
            if (!ShouldLog(level)) return;
            LogInternal(level, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log trace avec stream style
         */
        void Logger::Trace(const std::string& message) {
            if (!ShouldLog(LogLevel::Trace)) return;
            LogInternal(LogLevel::Trace, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log debug avec stream style
         */
        void Logger::Debug(const std::string& message) {
            if (!ShouldLog(LogLevel::Debug)) return;
            LogInternal(LogLevel::Debug, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log info avec stream style
         */
        void Logger::Info(const std::string& message) {
            if (!ShouldLog(LogLevel::Info)) return;
            LogInternal(LogLevel::Info, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log warning avec stream style
         */
        void Logger::Warn(const std::string& message) {
            if (!ShouldLog(LogLevel::Warn)) return;
            LogInternal(LogLevel::Warn, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log error avec stream style
         */
        void Logger::Error(const std::string& message) {
            if (!ShouldLog(LogLevel::Error)) return;
            LogInternal(LogLevel::Error, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log critical avec stream style
         */
        void Logger::Critical(const std::string& message) {
            if (!ShouldLog(LogLevel::Critical)) return;
            LogInternal(LogLevel::Critical, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Log fatal avec stream style
         */
        void Logger::Fatal(const std::string& message) {
            if (!ShouldLog(LogLevel::Fatal)) return;
            LogInternal(LogLevel::Fatal, message, m_SourceFile.c_str(), m_SourceLine, m_FunctionName.c_str());
        }
        
        /**
         * @brief Force le flush de tous les sinks
         */
        void Logger::Flush() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            for (auto& sink : m_Sinks) {
                if (sink) {
                    sink->Flush();
                }
            }
        }
        
        /**
         * @brief Obtient le nom du logger
         * @return Nom du logger
         */
        const std::string& Logger::GetName() const {
            return m_Name;
        }
        
        /**
         * @brief V√©rifie si le logger est actif
         * @return true si actif, false sinon
         */
        bool Logger::IsEnabled() const {
            return m_Enabled;
        }
        
        /**
         * @brief Active ou d√©sactive le logger
         * @param enabled √âtat d'activation
         */
        void Logger::SetEnabled(bool enabled) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Enabled = enabled;
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Logger.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Logger.h
// DESCRIPTION: Classe principale du syst√®me de logging, similaire √† spdlog.
//              G√®re les sinks, formatters et fournit une API de logging.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Export.h"
#include "Logger/LogLevel.h"
#include "Logger/Sink.h"
#include "Logger/Formatter.h"
#include <memory>
#include <vector>
#include <string>
#include <mutex>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: Logger
        // DESCRIPTION: Classe principale de logging avec support multi-sink
        // -------------------------------------------------------------------------
        class LOGGER_API Logger {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS ET DESTRUCTEUR
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur de logger avec nom
                 * @param name Nom du logger
                 */
                explicit Logger(const std::string& name);
                
                /**
                 * @brief Destructeur du logger
                 */
                ~Logger();
                
                // ---------------------------------------------------------------------
                // GESTION DES SINKS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Ajoute un sink au logger
                 * @param sink Sink √† ajouter (partag√©)
                 */
                void AddSink(std::shared_ptr<ISink> sink);
                
                /**
                 * @brief Supprime tous les sinks du logger
                 */
                void ClearSinks();
                
                /**
                 * @brief Obtient le nombre de sinks attach√©s
                 * @return Nombre de sinks
                 */
                size_t GetSinkCount() const;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION DU FORMATTER
                // ---------------------------------------------------------------------
                
                /**
                 * @brief D√©finit le formatter pour tous les sinks
                 * @param formatter Formatter √† utiliser
                 */
                void SetFormatter(std::unique_ptr<Formatter> formatter);
                
                /**
                 * @brief D√©finit le pattern de formatage
                 * @param pattern Pattern √† utiliser
                 */
                void SetPattern(const std::string& pattern);
                
                // ---------------------------------------------------------------------
                // CONFIGURATION DU NIVEAU DE LOG
                // ---------------------------------------------------------------------
                
                /**
                 * @brief D√©finit le niveau de log minimum
                 * @param level Niveau minimum √† logger
                 */
                void SetLevel(LogLevel level);
                
                /**
                 * @brief Obtient le niveau de log courant
                 * @return Niveau de log
                 */
                LogLevel GetLevel() const;
                
                /**
                 * @brief V√©rifie si un niveau devrait √™tre logg√©
                 * @param level Niveau √† v√©rifier
                 * @return true si le niveau est >= niveau minimum, false sinon
                 */
                bool ShouldLog(LogLevel level) const;
                
                // ---------------------------------------------------------------------
                // M√âTHODES DE LOGGING (FORMAT STRING)
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Log avec format string (style printf)
                 * @param level Niveau de log
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                virtual void Log(LogLevel level, const char* format, ...);

                /**
                 * @brief Log avec format string et informations de source
                 * @param level Niveau de log
                 * @param file Fichier source
                 * @param line Ligne source
                 * @param func Fonction source
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                virtual void Log(LogLevel level, const char* file, int line, const char* func, const char* format, ...);

                /**
                 * @brief Log avec message string et informations de source
                 * @param level Niveau de log
                 * @param file Fichier source
                 * @param line Ligne source
                 * @param func Fonction source
                 * @param message Message √† logger
                 */
                void Log(LogLevel level, const char* file, int line, const char* func, const std::string& message);

                /**
                 * @brief Log avec format string, informations de source et va_list
                 * @param level Niveau de log
                 * @param file Fichier source
                 * @param line Ligne source
                 * @param func Fonction source
                 * @param format Format string
                 * @param args Arguments variables (va_list)
                 */
                virtual void Log(LogLevel level, const char* file, int line, const char* func, const char* format, va_list args);
                
                /**
                 * @brief Log trace avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Trace(const char* format, ...);
                
                /**
                 * @brief Log debug avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Debug(const char* format, ...);
                
                /**
                 * @brief Log info avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Info(const char* format, ...);
                
                /**
                 * @brief Log warning avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Warn(const char* format, ...);
                
                /**
                 * @brief Log error avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Error(const char* format, ...);
                
                /**
                 * @brief Log critical avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Critical(const char* format, ...);
                
                /**
                 * @brief Log fatal avec format string
                 * @param format Format string
                 * @param ... Arguments variables
                 */
                void Fatal(const char* format, ...);
                
                // ---------------------------------------------------------------------
                // M√âTHODES DE LOGGING (STREAM STYLE)
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Log avec stream style
                 * @param level Niveau de log
                 * @param message Message √† logger
                 */
                void Log(LogLevel level, const std::string& message);
                
                /**
                 * @brief Log trace avec stream style
                 * @param message Message √† logger
                 */
                void Trace(const std::string& message);
                
                /**
                 * @brief Log debug avec stream style
                 * @param message Message √† logger
                 */
                void Debug(const std::string& message);
                
                /**
                 * @brief Log info avec stream style
                 * @param message Message √† logger
                 */
                void Info(const std::string& message);
                
                /**
                 * @brief Log warning avec stream style
                 * @param message Message √† logger
                 */
                void Warn(const std::string& message);
                
                /**
                 * @brief Log error avec stream style
                 * @param message Message √† logger
                 */
                void Error(const std::string& message);
                
                /**
                 * @brief Log critical avec stream style
                 * @param message Message √† logger
                 */
                void Critical(const std::string& message);
                
                /**
                 * @brief Log fatal avec stream style
                 * @param message Message √† logger
                 */
                void Fatal(const std::string& message);
                
                // ---------------------------------------------------------------------
                // UTILITAIRES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Force le flush de tous les sinks
                 */
                virtual void Flush();
                
                /**
                 * @brief Obtient le nom du logger
                 * @return Nom du logger
                 */
                const std::string& GetName() const;
                
                /**
                 * @brief V√©rifie si le logger est actif
                 * @return true si actif, false sinon
                 */
                bool IsEnabled() const;
                
                /**
                 * @brief Active ou d√©sactive le logger
                 * @param enabled √âtat d'activation
                 */
                void SetEnabled(bool enabled);


                virtual Logger& Source(const char* sourceFile = nullptr, uint32 sourceLine = 0, const char* functionName = nullptr) {
                    m_SourceFile = sourceFile ? sourceFile : "";
                    m_SourceLine = sourceLine;
                    m_FunctionName = functionName ? functionName : "";
                    return *this;
                }
            private:
                // ---------------------------------------------------------------------
                // M√âTHODES PRIV√âES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Log interne avec informations de source
                 * @param level Niveau de log
                 * @param message Message √† logger
                 * @param sourceFile Fichier source (optionnel)
                 * @param sourceLine Ligne source (optionnel)
                 * @param functionName Fonction source (optionnel)
                 */
                void LogInternal(LogLevel level, const std::string& message,
                                const char* sourceFile = nullptr,
                                uint32 sourceLine = 0,
                                const char* functionName = nullptr);
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Nom du logger
                std::string m_Name;
                
                /// Niveau de log minimum
                LogLevel m_Level;
                
                /// Indicateur d'activation
                bool m_Enabled;
            protected:
                void SetName(const std::string& name) {
                    m_Name = name;
                }
                /// Mutex pour la synchronisation thread-safe
                mutable std::mutex m_Mutex;
                
                /// Liste des sinks attach√©s
                std::vector<std::shared_ptr<ISink>> m_Sinks;
                
                /// Formatter pour le formatting
                std::unique_ptr<Formatter> m_Formatter;
                
                /**
                 * @brief Formatage variadique
                 * @param format Format string
                 * @param args Arguments variables
                 * @return Cha√Æne format√©e
                 */
                std::string FormatString(const char* format, va_list args);

                std::string m_SourceFile;
                uint32 m_SourceLine;
                std::string m_FunctionName;
        };

        // -------------------------------------------------------------------------
        // MACROS DE LOGGING PRATIQUES
        // -------------------------------------------------------------------------
        
        #define LOG_TRACE(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Trace)) \
                (logger)->Log(LogLevel::Trace, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)
        
        #define LOG_DEBUG(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Debug)) \
                (logger)->Log(LogLevel::Debug, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)
        
        #define LOG_INFO(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Info)) \
                (logger)->Log(LogLevel::Info, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)
        
        #define LOG_WARN(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Warn)) \
                (logger)->Log(LogLevel::Warn, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)
        
        #define LOG_ERROR(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Error)) \
                (logger)->Log(LogLevel::Error, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)
        
        #define LOG_CRITICAL(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Critical)) \
                (logger)->Log(LogLevel::Critical, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)
        
        #define LOG_FATAL(logger, ...) \
            if ((logger)->ShouldLog(LogLevel::Fatal)) \
                (logger)->Log(LogLevel::Fatal, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)

        #define LOG_FLUSH(logger) \
            (logger)->Flush()
        
        // -------------------------------------------------------------------------
        // MACROS AVEC INFORMATIONS DE SOURCE
        // -------------------------------------------------------------------------
        
        #define LOG_TRACE_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Trace, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)
        
        #define LOG_DEBUG_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Debug, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)
        
        #define LOG_INFO_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Info, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)
        
        #define LOG_WARN_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Warn, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)
        
        #define LOG_ERROR_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Error, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)
        
        #define LOG_CRITICAL_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Critical, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)
        
        #define LOG_FATAL_SRC(logger, ...) \
            (logger)->LogInternal(LogLevel::Fatal, (logger)->FormatString(__VA_ARGS__), \
                                __FILE__, __LINE__, __FUNCTION__)

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\LogLevel.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/LogLevel.cpp
// DESCRIPTION: Impl√©mentation des fonctions utilitaires pour LogLevel.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/LogLevel.h"
#include <cstring>
#include <cctype>   // Pour std::tolower

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // FONCTIONS UTILITAIRES POUR LogLevel
        // -------------------------------------------------------------------------
        
        /**
         * @brief Convertit un LogLevel en cha√Æne de caract√®res
         */
        const char* LogLevelToString(LogLevel level) {
            switch (level) {
                case LogLevel::Trace:    return "trace";
                case LogLevel::Debug:    return "debug";
                case LogLevel::Info:     return "info";
                case LogLevel::Warn:     return "warning";
                case LogLevel::Error:    return "error";
                case LogLevel::Critical: return "critical";
                case LogLevel::Fatal:    return "fatal";
                case LogLevel::Off:      return "off";
                default:                 return "unknown";
            }
        }
        
        /**
         * @brief Convertit un LogLevel en cha√Æne courte (3 caract√®res)
         */
        const char* LogLevelToShortString(LogLevel level) {
            switch (level) {
                case LogLevel::Trace:    return "TRC";
                case LogLevel::Debug:    return "DBG";
                case LogLevel::Info:     return "INF";
                case LogLevel::Warn:     return "WRN";
                case LogLevel::Error:    return "ERR";
                case LogLevel::Critical: return "CRT";
                case LogLevel::Fatal:    return "FTL";
                case LogLevel::Off:      return "OFF";
                default:                 return "UNK";
            }
        }
        
        /**
         * @brief Convertit une cha√Æne en LogLevel
         */
        LogLevel StringToLogLevel(const char* str) {
            if (!str) return LogLevel::Info;
            
            std::string levelStr(str);
            for (auto& c : levelStr) c = std::tolower(c);
            
            if (levelStr == "trace")    return LogLevel::Trace;
            if (levelStr == "debug")    return LogLevel::Debug;
            if (levelStr == "info")     return LogLevel::Info;
            if (levelStr == "warn" || levelStr == "warning") return LogLevel::Warn;
            if (levelStr == "error")    return LogLevel::Error;
            if (levelStr == "critical") return LogLevel::Critical;
            if (levelStr == "fatal")    return LogLevel::Fatal;
            if (levelStr == "off")      return LogLevel::Off;
            
            return LogLevel::Info; // Valeur par d√©faut
        }
        
        /**
         * @brief Convertit une cha√Æne courte en LogLevel
         */
        LogLevel ShortStringToLogLevel(const char* str) {
            if (!str) return LogLevel::Info;
            
            if (strcmp(str, "TRC") == 0) return LogLevel::Trace;
            if (strcmp(str, "DBG") == 0) return LogLevel::Debug;
            if (strcmp(str, "INF") == 0) return LogLevel::Info;
            if (strcmp(str, "WRN") == 0) return LogLevel::Warn;
            if (strcmp(str, "ERR") == 0) return LogLevel::Error;
            if (strcmp(str, "CRT") == 0) return LogLevel::Critical;
            if (strcmp(str, "FTL") == 0) return LogLevel::Fatal;
            if (strcmp(str, "OFF") == 0) return LogLevel::Off;
            
            return LogLevel::Info; // Valeur par d√©faut
        }
        
        /**
         * @brief Obtient la couleur ANSI associ√©e √† un niveau de log
         */
        const char* LogLevelToANSIColor(LogLevel level) {
            switch (level) {
                case LogLevel::Trace:    return "\033[37m";  // Blanc
                case LogLevel::Debug:    return "\033[36m";  // Cyan
                case LogLevel::Info:     return "\033[32m";  // Vert
                case LogLevel::Warn:     return "\033[33m";  // Jaune
                case LogLevel::Error:    return "\033[31m";  // Rouge
                case LogLevel::Critical: return "\033[35m";  // Magenta
                case LogLevel::Fatal:    return "\033[41m\033[37m"; // Rouge fond, blanc texte
                default:                 return "\033[0m";   // Reset
            }
        }
        
        /**
         * @brief Obtient la couleur Windows associ√©e √† un niveau de log
         */
        uint16 LogLevelToWindowsColor(LogLevel level) {
            switch (level) {
                case LogLevel::Trace:    return 0x07; // Gris sur noir
                case LogLevel::Debug:    return 0x0B; // Cyan clair sur noir
                case LogLevel::Info:     return 0x0A; // Vert clair sur noir
                case LogLevel::Warn:     return 0x0E; // Jaune sur noir
                case LogLevel::Error:    return 0x0C; // Rouge clair sur noir
                case LogLevel::Critical: return 0x0D; // Magenta clair sur noir
                case LogLevel::Fatal:    return 0x4F; // Blanc sur rouge
                default:                 return 0x07; // Gris sur noir
            }
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\LogLevel.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/LogLevel.h
// DESCRIPTION: D√©finition des niveaux de log et fonctions utilitaires.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include <string>
#include <Nkentseu/Types.h>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // √âNUM√âRATION: LogLevel
        // DESCRIPTION: Niveaux de log disponibles, similaires √† spdlog
        // -------------------------------------------------------------------------
        enum class LogLevel : uint8 {
            /// Niveau trace - messages de trace tr√®s d√©taill√©s
            Trace = 0,
            
            /// Niveau debug - messages de d√©bogage
            Debug = 1,
            
            /// Niveau info - messages informatifs normaux
            Info = 2,
            
            /// Niveau warn - messages d'avertissement
            Warn = 3,
            
            /// Niveau error - messages d'erreur
            Error = 4,
            
            /// Niveau critical - messages critiques
            Critical = 5,
            
            /// Niveau fatal - messages fatals (arr√™t de l'application)
            Fatal = 6,
            
            /// D√©sactivation compl√®te du logging
            Off = 7
        };

        // -------------------------------------------------------------------------
        // FONCTIONS UTILITAIRES POUR LogLevel
        // -------------------------------------------------------------------------
        
        /**
         * @brief Convertit un LogLevel en cha√Æne de caract√®res
         * @param level Niveau de log √† convertir
         * @return Cha√Æne repr√©sentant le niveau de log
         */
        const char* LogLevelToString(LogLevel level);
        
        /**
         * @brief Convertit un LogLevel en cha√Æne courte (3 caract√®res)
         * @param level Niveau de log √† convertir
         * @return Cha√Æne courte repr√©sentant le niveau de log
         */
        const char* LogLevelToShortString(LogLevel level);
        
        /**
         * @brief Convertit une cha√Æne en LogLevel
         * @param str Cha√Æne √† convertir
         * @return LogLevel correspondant, LogLevel::Info par d√©faut
         */
        LogLevel StringToLogLevel(const char* str);
        
        /**
         * @brief Convertit une cha√Æne courte en LogLevel
         * @param str Cha√Æne courte √† convertir
         * @return LogLevel correspondant, LogLevel::Info par d√©faut
         */
        LogLevel ShortStringToLogLevel(const char* str);
        
        /**
         * @brief Obtient la couleur ANSI associ√©e √† un niveau de log
         * @param level Niveau de log
         * @return Code couleur ANSI (pour console)
         */
        const char* LogLevelToANSIColor(LogLevel level);
        
        /**
         * @brief Obtient la couleur Windows associ√©e √† un niveau de log
         * @param level Niveau de log
         * @return Code couleur Windows (pour console Windows)
         */
        uint16 LogLevelToWindowsColor(LogLevel level);

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\LogMessage.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/LogMessage.cpp
// DESCRIPTION: Impl√©mentation de la structure LogMessage.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/LogMessage.h"
#include <chrono>
#include <ctime>
#include <thread>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE LogMessage
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur par d√©faut
         */
        LogMessage::LogMessage()
            : timestamp(0)
            , timePoint(std::chrono::system_clock::now())
            , threadId(0)
            , sourceLine(0)
            , level(LogLevel::Info) {
            // Conversion du time_point en timestamp nanosecondes
            timestamp = std::chrono::duration_cast<std::chrono::nanoseconds>(
                timePoint.time_since_epoch()).count();
            
            // Obtention de l'ID du thread
            threadId = static_cast<uint32>(std::hash<std::thread::id>{}(std::this_thread::get_id()));
        }
        
        /**
         * @brief Constructeur avec niveau et message
         */
        LogMessage::LogMessage(LogLevel lvl, const std::string& msg, const std::string& logger)
            : LogMessage() {
            level = lvl;
            message = msg;
            if (!logger.empty()) {
                loggerName = logger;
            }
        }
        
        /**
         * @brief Constructeur avec informations compl√®tes
         */
        LogMessage::LogMessage(LogLevel lvl, const std::string& msg,
                            const std::string& file, uint32 line, const std::string& func,
                            const std::string& logger)
            : LogMessage(lvl, msg, logger) {
            if (!file.empty()) sourceFile = file;
            if (line > 0) sourceLine = line;
            if (!func.empty()) functionName = func;
        }
        
        /**
         * @brief R√©initialise le message
         */
        void LogMessage::Reset() {
            timestamp = 0;
            timePoint = std::chrono::system_clock::now();
            threadId = 0;
            threadName.clear();
            level = LogLevel::Info;
            message.clear();
            loggerName.clear();
            sourceFile.clear();
            sourceLine = 0;
            functionName.clear();
            
            // Recalcul du timestamp
            timestamp = std::chrono::duration_cast<std::chrono::nanoseconds>(
                timePoint.time_since_epoch()).count();
            
            // Recalcul de l'ID du thread
            threadId = static_cast<uint32>(std::hash<std::thread::id>{}(std::this_thread::get_id()));
        }
        
        /**
         * @brief V√©rifie si le message est valide
         */
        bool LogMessage::IsValid() const {
            return !message.empty() && timestamp > 0;
        }
        
        /**
         * @brief Obtient l'heure sous forme de structure tm
         */
        std::tm LogMessage::GetLocalTime() const {
            auto time = std::chrono::system_clock::to_time_t(timePoint);
            std::tm localTime;
            
            #ifdef _WIN32
                localtime_s(&localTime, &time);
            #else
                localtime_r(&time, &localTime);
            #endif
            
            return localTime;
        }
        
        /**
         * @brief Obtient l'heure sous forme de structure tm (UTC)
         */
        std::tm LogMessage::GetUTCTime() const {
            auto time = std::chrono::system_clock::to_time_t(timePoint);
            std::tm utcTime;
            
            #ifdef _WIN32
                gmtime_s(&utcTime, &time);
            #else
                gmtime_r(&time, &utcTime);
            #endif
            
            return utcTime;
        }
        
        /**
         * @brief Obtient le timestamp en millisecondes
         */
        uint64 LogMessage::GetMillis() const {
            return timestamp / 1000000ULL;
        }
        
        /**
         * @brief Obtient le timestamp en microsecondes
         */
        uint64 LogMessage::GetMicros() const {
            return timestamp / 1000ULL;
        }
        
        /**
         * @brief Obtient le timestamp en secondes
         */
        double LogMessage::GetSeconds() const {
            return static_cast<double>(timestamp) / 1000000000.0;
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\LogMessage.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/LogMessage.h
// DESCRIPTION: Structure contenant toutes les informations d'un message de log.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include <string>
#include <chrono>
#include <Nkentseu/Types.h>
#include "Logger/LogLevel.h"

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // STRUCTURE: LogMessage
        // DESCRIPTION: Contient toutes les informations d'un message de log
        // -------------------------------------------------------------------------
        struct LogMessage {
            // ---------------------------------------------------------------------
            // DONN√âES TEMPORELLES
            // ---------------------------------------------------------------------
            
            /// Timestamp en nanosecondes depuis l'epoch
            uint64 timestamp;
            
            /// Heure de r√©ception du message
            std::chrono::system_clock::time_point timePoint;
            
            // ---------------------------------------------------------------------
            // INFORMATIONS DE THREAD
            // ---------------------------------------------------------------------
            
            /// ID du thread √©metteur
            uint32 threadId;
            
            /// Nom du thread (optionnel)
            std::string threadName;
            
            // ---------------------------------------------------------------------
            // INFORMATIONS DE LOG
            // ---------------------------------------------------------------------
            
            /// Niveau de log
            LogLevel level;
            
            /// Message de log
            std::string message;
            
            /// Nom du logger
            std::string loggerName;
            
            // ---------------------------------------------------------------------
            // INFORMATIONS DE SOURCE (optionnelles)
            // ---------------------------------------------------------------------
            
            /// Fichier source
            std::string sourceFile;
            
            /// Ligne source
            uint32 sourceLine;
            
            /// Nom de la fonction
            std::string functionName;
            
            // ---------------------------------------------------------------------
            // CONSTRUCTEURS
            // ---------------------------------------------------------------------
            
            /**
             * @brief Constructeur par d√©faut
             */
            LogMessage();
            
            /**
             * @brief Constructeur avec niveau et message
             * @param lvl Niveau de log
             * @param msg Message de log
             * @param logger Nom du logger (optionnel)
             */
            LogMessage(LogLevel lvl, const std::string& msg, const std::string& logger = "");
            
            /**
             * @brief Constructeur avec informations compl√®tes
             * @param lvl Niveau de log
             * @param msg Message de log
             * @param file Fichier source (optionnel)
             * @param line Ligne source (optionnel)
             * @param func Fonction source (optionnel)
             * @param logger Nom du logger (optionnel)
             */
            LogMessage(LogLevel lvl, const std::string& msg,
                    const std::string& file, uint32 line, const std::string& func,
                    const std::string& logger = "");
            
            /**
             * @brief Destructeur
             */
            ~LogMessage() = default;
            
            // ---------------------------------------------------------------------
            // M√âTHODES UTILITAIRES
            // ---------------------------------------------------------------------
            
            /**
             * @brief R√©initialise le message
             */
            void Reset();
            
            /**
             * @brief V√©rifie si le message est valide
             * @return true si valide, false sinon
             */
            bool IsValid() const;
            
            /**
             * @brief Obtient l'heure sous forme de structure tm
             * @return Structure tm avec l'heure locale
             */
            std::tm GetLocalTime() const;
            
            /**
             * @brief Obtient l'heure sous forme de structure tm (UTC)
             * @return Structure tm avec l'heure UTC
             */
            std::tm GetUTCTime() const;
            
            /**
             * @brief Obtient le timestamp en millisecondes
             * @return Timestamp en millisecondes
             */
            uint64 GetMillis() const;
            
            /**
             * @brief Obtient le timestamp en microsecondes
             * @return Timestamp en microsecondes
             */
            uint64 GetMicros() const;
            
            /**
             * @brief Obtient le timestamp en secondes
             * @return Timestamp en secondes (double)
             */
            double GetSeconds() const;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Pattern.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Pattern.h
// DESCRIPTION: Patterns de formatage pr√©d√©finis pour le logging.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // PATTERNS DE FORMATAGE PR√âD√âFINIS
        // -------------------------------------------------------------------------
        
        /**
         * @brief Pattern par d√©faut (similaire √† spdlog)
         * Format: [2026-01-01 12:34:56.789] [INF] [12345] Message
         */
        extern const char* DEFAULT_PATTERN;
        
        /**
         * @brief Pattern simple (juste le message)
         * Format: Message
         */
        extern const char* SIMPLE_PATTERN;
        
        /**
         * @brief Pattern d√©taill√© (avec toutes les informations)
         * Format: [2026-01-01 12:34:56.789] [INF] [logger] [thread 12345] [file.cpp:42 in function] Message
         */
        extern const char* DETAILED_PATTERN;
        
        /**
         * @brief Pattern avec couleurs (pour console)
         * Format: [2026-01-01 12:34:56.789] [INF] [12345] Message (INF en couleur)
         */
        extern const char* COLOR_PATTERN;
        
        /**
         * @brief Pattern JSON (pour traitement automatis√©)
         * Format: {"time":"2026-01-01T12:34:56.789000Z","level":"info","thread":12345,"logger":"default","file":"file.cpp","line":42,"function":"function","message":"Message"}
         */
        extern const char* JSON_PATTERN;
        
        /**
         * @brief Pattern court (pour logs de production)
         * Format: 12:34:56 INF Message
         */
        extern const char* SHORT_PATTERN;
        
        /**
         * @brief Pattern avec heure ISO 8601
         * Format: 2026-01-01T12:34:56.789Z [INF] Message
         */
        extern const char* ISO8601_PATTERN;
        
        /**
         * @brief Pattern pour les logs syst√®me
         * Format: Jan 01 12:34:56 hostname logger[12345]: Message
         */
        extern const char* SYSLOG_PATTERN;

        // -------------------------------------------------------------------------
        // DOCUMENTATION DES TOKENS DE PATTERN
        // -------------------------------------------------------------------------
        
        /**
         * TOKENS DISPONIBLES:
         * 
         * %Y - Ann√©e (4 chiffres, ex: 2026)
         * %m - Mois (2 chiffres, ex: 01)
         * %d - Jour (2 chiffres, ex: 01)
         * %H - Heure (24h, 2 chiffres, ex: 14)
         * %M - Minute (2 chiffres, ex: 30)
         * %S - Seconde (2 chiffres, ex: 45)
         * %e - Millisecondes (3 chiffres, ex: 123)
         * %f - Microsecondes (6 chiffres, ex: 123456)
         * %l - Niveau de log (texte complet, ex: "info")
         * %L - Niveau de log (3 lettres, ex: "INF")
         * %t - ID du thread (nombre)
         * %T - Nom du thread (si disponible, sinon ID)
         * %s - Fichier source (nom seulement)
         * %# - Ligne source (nombre)
         * %F - Fonction source
         * %v - Message de log
         * %n - Nom du logger
         * %% - Caract√®re '%' litt√©ral
         * %^ - D√©but de couleur (ANSI)
         * %$ - Fin de couleur (ANSI)
         */

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Registry.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Registry.cpp
// DESCRIPTION: Impl√©mentation du registre global des loggers.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Registry.h"
#include "Logger/Sinks/ConsoleSink.h"
#include <algorithm>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE Registry
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur priv√©
         */
        Registry::Registry()
            : m_GlobalLevel(LogLevel::Info)
            , m_GlobalPattern(Formatter::DEFAULT_PATTERN)
            , m_Initialized(false) {
        }
        
        /**
         * @brief Destructeur priv√©
         */
        Registry::~Registry() {
            Clear();
        }
        
        /**
         * @brief Obtient l'instance singleton du registre
         */
        Registry& Registry::Instance() {
            static Registry instance;
            return instance;
        }
        
        /**
         * @brief Initialise le registre avec des param√®tres par d√©faut
         */
        void Registry::Initialize() {
            auto& instance = Instance();
            
            std::lock_guard<std::mutex> lock(instance.m_Mutex);
            if (!instance.m_Initialized) {
                instance.CreateDefaultLogger();
                instance.m_Initialized = true;
            }
        }
        
        /**
         * @brief Nettoie le registre (d√©truit tous les loggers)
         */
        void Registry::Shutdown() {
            auto& instance = Instance();
            instance.Clear();
            instance.m_Initialized = false;
        }
        
        /**
         * @brief Enregistre un logger dans le registre
         */
        bool Registry::Register(std::shared_ptr<Logger> logger) {
            if (!logger) return false;
            
            std::string name = logger->GetName();
            
            if (m_Loggers.find(name) != m_Loggers.end()) {
                return false; // Nom d√©j√† existant
            }
            
            m_Loggers[name] = logger;
            return true;
        }
        
        /**
         * @brief D√©senregistre un logger du registre
         */
        bool Registry::Unregister(const std::string& name) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            auto it = m_Loggers.find(name);
            
            if (it != m_Loggers.end()) {
                m_Loggers.erase(it);
                return true;
            }
            
            return false;
        }
        
        /**
         * @brief Obtient un logger par son nom
         */
        std::shared_ptr<Logger> Registry::Get(const std::string& name) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            auto it = m_Loggers.find(name);
            
            if (it != m_Loggers.end()) {
                return it->second;
            }
            
            return nullptr;
        }
        
        /**
         * @brief Obtient un logger par son nom (cr√©e si non existant)
         */
        std::shared_ptr<Logger> Registry::GetOrCreate(const std::string& name) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            auto it = m_Loggers.find(name);
            
            if (it != m_Loggers.end()) {
                return it->second;
            }
            
            // Cr√©ation d'un nouveau logger
            auto logger = std::make_shared<Logger>(name);
            logger->SetLevel(m_GlobalLevel);
            logger->SetPattern(m_GlobalPattern);
            
            m_Loggers[name] = logger;
            return logger;
        }
        
        /**
         * @brief V√©rifie si un logger existe
         */
        bool Registry::Exists(const std::string& name) const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Loggers.find(name) != m_Loggers.end();
        }
        
        /**
         * @brief Supprime tous les loggers du registre
         */
        void Registry::Clear() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Loggers.clear();
            m_DefaultLogger.reset();
        }
        
        /**
         * @brief Obtient la liste de tous les noms de loggers
         */
        std::vector<std::string> Registry::GetLoggerNames() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            std::vector<std::string> names;
            names.reserve(m_Loggers.size());
            
            for (const auto& pair : m_Loggers) {
                names.push_back(pair.first);
            }
            
            return names;
        }
        
        /**
         * @brief Obtient le nombre de loggers enregistr√©s
         */
        size_t Registry::GetLoggerCount() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Loggers.size();
        }
        
        /**
         * @brief D√©finit le niveau de log global
         */
        void Registry::SetGlobalLevel(LogLevel level) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_GlobalLevel = level;
            
            // Appliquer √† tous les loggers existants
            for (auto& pair : m_Loggers) {
                if (pair.second) {
                    pair.second->SetLevel(level);
                }
            }
        }
        
        /**
         * @brief Obtient le niveau de log global
         */
        LogLevel Registry::GetGlobalLevel() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_GlobalLevel;
        }
        
        /**
         * @brief D√©finit le pattern global
         */
        void Registry::SetGlobalPattern(const std::string& pattern) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_GlobalPattern = pattern;
            
            // Appliquer √† tous les loggers existants
            for (auto& pair : m_Loggers) {
                if (pair.second) {
                    pair.second->SetPattern(pattern);
                }
            }
        }
        
        /**
         * @brief Obtient le pattern global
         */
        std::string Registry::GetGlobalPattern() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_GlobalPattern;
        }
        
        /**
         * @brief Force le flush de tous les loggers
         */
        void Registry::FlushAll() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            for (auto& pair : m_Loggers) {
                if (pair.second) {
                    pair.second->Flush();
                }
            }
        }
        
        /**
         * @brief D√©finit le logger par d√©faut
         */
        void Registry::SetDefaultLogger(std::shared_ptr<Logger> logger) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_DefaultLogger = logger;
            
            // S'assurer qu'il est aussi dans le registre
            if (logger && !Exists(logger->GetName())) {
                Register(logger);
            }
        }
        
        /**
         * @brief Obtient le logger par d√©faut
         */
        std::shared_ptr<Logger> Registry::GetDefaultLogger() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            if (!m_DefaultLogger) {
                m_DefaultLogger = CreateDefaultLogger();
            }
            
            return m_DefaultLogger;
        }
        
        /**
         * @brief Cr√©e un logger par d√©faut avec console sink
         */
        std::shared_ptr<Logger> Registry::CreateDefaultLogger() {
            auto logger = std::make_shared<Logger>("default");
            
            logger->SetLevel(m_GlobalLevel);
            logger->SetPattern(m_GlobalPattern);
            
            // Ajouter un sink console par d√©faut
            auto consoleSink = std::make_shared<ConsoleSink>();
            logger->AddSink(consoleSink);
            
            // Enregistrer le logger
            Register(logger);
            m_DefaultLogger = logger;
            
            return logger;
        }

        // -------------------------------------------------------------------------
        // FONCTIONS UTILITAIRES GLOBALES
        // -------------------------------------------------------------------------
        
        /**
         * @brief Obtient un logger par son nom
         */
        std::shared_ptr<Logger> GetLogger(const std::string& name) {
            return Registry::Instance().Get(name);
        }
        
        /**
         * @brief Obtient le logger par d√©faut
         */
        std::shared_ptr<Logger> GetDefaultLogger() {
            return Registry::Instance().GetDefaultLogger();
        }
        
        /**
         * @brief Cr√©e un logger avec un nom sp√©cifique
         */
        std::shared_ptr<Logger> CreateLogger(const std::string& name) {
            auto& registry = Registry::Instance();
            return registry.GetOrCreate(name);
        }
        
        /**
         * @brief Supprime tous les loggers
         */
        void DropAll() {
            Registry::Instance().Clear();
        }
        
        /**
         * @brief Supprime un logger sp√©cifique
         */
        void Drop(const std::string& name) {
            Registry::Instance().Unregister(name);
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Registry.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Registry.h
// DESCRIPTION: Registre global des loggers (similaire √† spdlog).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Export.h"
#include "Logger/Logger.h"
#include <memory>
#include <string>
#include <unordered_map>
#include <mutex>
#include <vector>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: Registry
        // DESCRIPTION: Registre global singleton pour la gestion des loggers
        // -------------------------------------------------------------------------
        class LOGGER_API Registry {
            public:
                // ---------------------------------------------------------------------
                // M√âTHODES STATIQUES (SINGLETON)
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Obtient l'instance singleton du registre
                 * @return R√©f√©rence √† l'instance du registre
                 */
                static Registry& Instance();
                
                /**
                 * @brief Initialise le registre avec des param√®tres par d√©faut
                 */
                static void Initialize();
                
                /**
                 * @brief Nettoie le registre (d√©truit tous les loggers)
                 */
                static void Shutdown();
                
                // ---------------------------------------------------------------------
                // GESTION DES LOGGERS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Enregistre un logger dans le registre
                 * @param logger Logger √† enregistrer
                 * @return true si enregistr√©, false si nom d√©j√† existant
                 */
                bool Register(std::shared_ptr<Logger> logger);
                
                /**
                 * @brief D√©senregistre un logger du registre
                 * @param name Nom du logger √† d√©senregistrer
                 * @return true si d√©senregistr√©, false si non trouv√©
                 */
                bool Unregister(const std::string& name);
                
                /**
                 * @brief Obtient un logger par son nom
                 * @param name Nom du logger
                 * @return Pointeur vers le logger, nullptr si non trouv√©
                 */
                std::shared_ptr<Logger> Get(const std::string& name);
                
                /**
                 * @brief Obtient un logger par son nom (cr√©e si non existant)
                 * @param name Nom du logger
                 * @return Pointeur vers le logger (existant ou nouvellement cr√©√©)
                 */
                std::shared_ptr<Logger> GetOrCreate(const std::string& name);
                
                /**
                 * @brief V√©rifie si un logger existe
                 * @param name Nom du logger
                 * @return true si existe, false sinon
                 */
                bool Exists(const std::string& name) const;
                
                /**
                 * @brief Supprime tous les loggers du registre
                 */
                void Clear();
                
                /**
                 * @brief Obtient la liste de tous les noms de loggers
                 * @return Vecteur des noms de loggers
                 */
                std::vector<std::string> GetLoggerNames() const;
                
                /**
                 * @brief Obtient le nombre de loggers enregistr√©s
                 * @return Nombre de loggers
                 */
                size_t GetLoggerCount() const;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION GLOBALE
                // ---------------------------------------------------------------------
                
                /**
                 * @brief D√©finit le niveau de log global
                 * @param level Niveau de log global
                 */
                void SetGlobalLevel(LogLevel level);
                
                /**
                 * @brief Obtient le niveau de log global
                 * @return Niveau de log global
                 */
                LogLevel GetGlobalLevel() const;
                
                /**
                 * @brief D√©finit le pattern global
                 * @param pattern Pattern de formatage global
                 */
                void SetGlobalPattern(const std::string& pattern);
                
                /**
                 * @brief Obtient le pattern global
                 * @return Pattern de formatage global
                 */
                std::string GetGlobalPattern() const;
                
                /**
                 * @brief Force le flush de tous les loggers
                 */
                void FlushAll();
                
                /**
                 * @brief D√©finit le logger par d√©faut
                 * @param logger Logger par d√©faut
                 */
                void SetDefaultLogger(std::shared_ptr<Logger> logger);
                
                /**
                 * @brief Obtient le logger par d√©faut
                 * @return Pointeur vers le logger par d√©faut
                 */
                std::shared_ptr<Logger> GetDefaultLogger();
                
                /**
                 * @brief Cr√©e un logger par d√©faut avec console sink
                 * @return Pointeur vers le nouveau logger par d√©faut
                 */
                std::shared_ptr<Logger> CreateDefaultLogger();

            private:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS PRIV√âS (SINGLETON)
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur priv√© (singleton)
                 */
                Registry();
                
                /**
                 * @brief Destructeur priv√©
                 */
                ~Registry();
                
                /**
                 * @brief Constructeur de copie supprim√©
                 */
                Registry(const Registry&) = delete;
                
                /**
                 * @brief Op√©rateur d'affectation supprim√©
                 */
                Registry& operator=(const Registry&) = delete;
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Map des loggers par nom
                std::unordered_map<std::string, std::shared_ptr<Logger>> m_Loggers;
                
                /// Logger par d√©faut
                std::shared_ptr<Logger> m_DefaultLogger;
                
                /// Niveau de log global
                LogLevel m_GlobalLevel;
                
                /// Pattern global
                std::string m_GlobalPattern;
                
                /// Mutex pour la synchronisation thread-safe
                mutable std::mutex m_Mutex;
                
                /// Indicateur d'initialisation
                bool m_Initialized;
        };

        // -------------------------------------------------------------------------
        // FONCTIONS UTILITAIRES GLOBALES
        // -------------------------------------------------------------------------
        
        /**
         * @brief Obtient un logger par son nom
         * @param name Nom du logger
         * @return Pointeur vers le logger
         */
        LOGGER_API std::shared_ptr<Logger> GetLogger(const std::string& name);
        
        /**
         * @brief Obtient le logger par d√©faut
         * @return Pointeur vers le logger par d√©faut
         */
        LOGGER_API std::shared_ptr<Logger> GetDefaultLogger();
        
        /**
         * @brief Cr√©e un logger avec un nom sp√©cifique
         * @param name Nom du logger
         * @return Nouveau logger
         */
        LOGGER_API std::shared_ptr<Logger> CreateLogger(const std::string& name);
        
        /**
         * @brief Supprime tous les loggers
         */
        LOGGER_API void DropAll();
        
        /**
         * @brief Supprime un logger sp√©cifique
         * @param name Nom du logger √† supprimer
         */
        LOGGER_API void Drop(const std::string& name);

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sink.h
// DESCRIPTION: Interface de base pour tous les sinks de logging.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Export.h"
#include "Logger/LogMessage.h"
#include "Logger/Formatter.h"
#include <memory>
#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: ISink
        // DESCRIPTION: Interface de base pour tous les sinks de logging
        // -------------------------------------------------------------------------
        class LOGGER_API ISink {
        public:
            /**
             * @brief Destructeur virtuel
             */
            virtual ~ISink() = default;
            
            // ---------------------------------------------------------------------
            // M√âTHODES VIRTUELLES PURES
            // ---------------------------------------------------------------------
            
            /**
             * @brief Logge un message
             * @param message Message √† logger
             */
            virtual void Log(const LogMessage& message) = 0;
            
            /**
             * @brief Force l'√©criture des donn√©es en attente
             */
            virtual void Flush() = 0;
            
            /**
             * @brief D√©finit le formatter pour ce sink
             * @param formatter Formatter √† utiliser
             */
            virtual void SetFormatter(std::unique_ptr<Formatter> formatter) = 0;
            
            /**
             * @brief D√©finit le pattern de formatage
             * @param pattern Pattern √† utiliser
             */
            virtual void SetPattern(const std::string& pattern) = 0;
            
            /**
             * @brief Obtient le formatter courant
             * @return Pointeur vers le formatter
             */
            virtual Formatter* GetFormatter() const = 0;
            
            /**
             * @brief Obtient le pattern courant
             * @return Pattern de formatage
             */
            virtual std::string GetPattern() const = 0;
            
            // ---------------------------------------------------------------------
            // M√âTHODES VIRTUELLES (OPTIONNELLES)
            // ---------------------------------------------------------------------
            
            /**
             * @brief D√©finit le niveau minimum de log pour ce sink
             * @param level Niveau minimum
             */
            virtual void SetLevel(LogLevel level) { m_Level = level; }
            
            /**
             * @brief Obtient le niveau minimum de log
             * @return Niveau minimum
             */
            virtual LogLevel GetLevel() const { return m_Level; }
            
            /**
             * @brief V√©rifie si un niveau devrait √™tre logg√©
             * @param level Niveau √† v√©rifier
             * @return true si le niveau est >= niveau minimum, false sinon
             */
            virtual bool ShouldLog(LogLevel level) const { return level >= m_Level; }
            
            /**
             * @brief Active ou d√©sactive le sink
             * @param enabled √âtat d'activation
             */
            virtual void SetEnabled(bool enabled) { m_Enabled = enabled; }
            
            /**
             * @brief V√©rifie si le sink est activ√©
             * @return true si activ√©, false sinon
             */
            virtual bool IsEnabled() const { return m_Enabled; }
            
            /**
             * @brief Obtient le nom du sink
             * @return Nom du sink
             */
            virtual std::string GetName() const { return m_Name; }
            
            /**
             * @brief D√©finit le nom du sink
             * @param name Nom du sink
             */
            virtual void SetName(const std::string& name) { m_Name = name; }

        protected:
            /// Niveau minimum de log
            LogLevel m_Level = LogLevel::Trace;
            
            /// Indicateur d'activation
            bool m_Enabled = true;
            
            /// Nom du sink
            std::string m_Name;
        };

        // -------------------------------------------------------------------------
        // TYPE ALIAS POUR LES SINKS
        // -------------------------------------------------------------------------
        
        /// Type pour les pointeurs partag√©s de sinks
        using SinkPtr = std::shared_ptr<ISink>;
        
        /// Type pour les pointeurs uniques de sinks
        using SinkUniquePtr = std::unique_ptr<ISink>;

    } // namespace logger
} // namespace nkentseu
==================================================


üìÅ DOSSIER: Core\Logger\src\Logger\Filters
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Logger\src\Logger\Filters\LevelFilter.cpp]
==================================================
#include "Logger/Filters/LevelFilter.h"

namespace nkentseu {

} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Filters\LevelFilter.h]
==================================================
#ifndef NKENTSEU_LOGGER_FILTERS_LEVELFILTER_H
#define NKENTSEU_LOGGER_FILTERS_LEVELFILTER_H

namespace nkentseu {

class LevelFilter {
public:
    LevelFilter();
    ~LevelFilter();

private:
    // Implementation
};

} // namespace nkentseu

#endif // NKENTSEU_LOGGER_FILTERS_LEVELFILTER_H
==================================================


[FICHIER: Core\Logger\src\Logger\Filters\PatternFilter.cpp]
==================================================
#include "Logger/Filters/PatternFilter.h"

namespace nkentseu {

} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Filters\PatternFilter.h]
==================================================
#ifndef NKENTSEU_LOGGER_FILTERS_PATTERNFILTER_H
#define NKENTSEU_LOGGER_FILTERS_PATTERNFILTER_H

namespace nkentseu {

class PatternFilter {
public:
    PatternFilter();
    ~PatternFilter();

private:
    // Implementation
};

} // namespace nkentseu

#endif // NKENTSEU_LOGGER_FILTERS_PATTERNFILTER_H
==================================================


[FICHIER: Core\Logger\src\Logger\Filters\ThreadFilter.cpp]
==================================================
#include "Logger/Filters/ThreadFilter.h"

namespace nkentseu {

} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Filters\ThreadFilter.h]
==================================================
#ifndef NKENTSEU_LOGGER_FILTERS_THREADFILTER_H
#define NKENTSEU_LOGGER_FILTERS_THREADFILTER_H

namespace nkentseu {

class ThreadFilter {
public:
    ThreadFilter();
    ~ThreadFilter();

private:
    // Implementation
};

} // namespace nkentseu

#endif // NKENTSEU_LOGGER_FILTERS_THREADFILTER_H
==================================================


üìÅ DOSSIER: Core\Logger\src\Logger\Sinks
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Logger\src\Logger\Sinks\AsyncSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/AsyncSink.cpp
// DESCRIPTION: Impl√©mentation du logger asynchrone avec file d'attente.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/AsyncSink.h"
#include <Nkentseu/Sleep.h>
#include <cstdarg>

namespace nkentseu {
namespace logger {

    /**
     * @brief Constructeur avec configuration
     */
    AsyncLogger::AsyncLogger(const std::string& name, size_t queueSize, uint32 flushInterval)
        : Logger(name)
        , m_MaxQueueSize(queueSize)
        , m_FlushInterval(flushInterval)
        , m_Running(false)
        , m_StopRequested(false) {
    }

    /**
     * @brief Destructeur
     */
    AsyncLogger::~AsyncLogger() {
        Stop();
    }

    /**
     * @brief Log asynchrone
     */
    void AsyncLogger::Log(LogLevel level, const char* format, ...) {
        if (!ShouldLog(level)) return;

        va_list args;
        va_start(args, format);
        std::string message = FormatString(format, args);
        va_end(args);

        Log(level, message);
    }

    /**
     * @brief Log asynchrone avec message pr√©-format√©
     */
    void AsyncLogger::Log(LogLevel level, const std::string& message) {
        if (!ShouldLog(level)) return;

        LogMessage msg;
        msg.timestamp = std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        msg.threadId = static_cast<uint32>(std::hash<std::thread::id>{}(std::this_thread::get_id()));
        msg.level = level;
        msg.message = message;
        msg.loggerName = GetName();

        Enqueue(msg);
    }

    /**
     * @brief Force le flush des messages en attente
     */
    void AsyncLogger::Flush() {
        FlushQueue();
        Logger::Flush();
    }

    /**
     * @brief D√©marre le thread de traitement
     */
    void AsyncLogger::Start() {
        if (m_Running) return;

        m_Running = true;
        m_StopRequested = false;
        m_WorkerThread = std::thread(&AsyncLogger::WorkerThread, this);
    }

    /**
     * @brief Arr√™te le thread de traitement
     */
    void AsyncLogger::Stop() {
        if (!m_Running) return;

        m_StopRequested = true;
        m_Condition.notify_one();

        if (m_WorkerThread.joinable()) {
            m_WorkerThread.join();
        }

        m_Running = false;
        FlushQueue();
    }

    /**
     * @brief V√©rifie si le logger est en cours d'ex√©cution
     */
    bool AsyncLogger::IsRunning() const {
        return m_Running;
    }

    /**
     * @brief Obtient la taille actuelle de la file
     */
    size_t AsyncLogger::GetQueueSize() const {
        std::lock_guard<std::mutex> lock(m_QueueMutex);
        return m_MessageQueue.size();
    }

    /**
     * @brief D√©finit la taille maximum de la file
     */
    void AsyncLogger::SetMaxQueueSize(size_t size) {
        std::lock_guard<std::mutex> lock(m_QueueMutex);
        m_MaxQueueSize = size;
    }

    /**
     * @brief Obtient la taille maximum de la file
     */
    size_t AsyncLogger::GetMaxQueueSize() const {
        std::lock_guard<std::mutex> lock(m_QueueMutex);
        return m_MaxQueueSize;
    }

    /**
     * @brief D√©finit l'intervalle de flush
     */
    void AsyncLogger::SetFlushInterval(uint32 ms) {
        std::lock_guard<std::mutex> lock(m_QueueMutex);
        m_FlushInterval = ms;
    }

    /**
     * @brief Obtient l'intervalle de flush
     */
    uint32 AsyncLogger::GetFlushInterval() const {
        std::lock_guard<std::mutex> lock(m_QueueMutex);
        return m_FlushInterval;
    }

    /**
     * @brief Fonction du thread de traitement
     */
    void AsyncLogger::WorkerThread() {
        while (!m_StopRequested) {
            std::unique_lock<std::mutex> lock(m_QueueMutex);

            m_Condition.wait_for(lock, std::chrono::milliseconds(m_FlushInterval), [this] {
                return !m_MessageQueue.empty() || m_StopRequested;
            });

            while (!m_MessageQueue.empty()) {
                LogMessage msg = m_MessageQueue.front();
                m_MessageQueue.pop();
                lock.unlock();

                ProcessMessage(msg);

                lock.lock();
            }
        }
    }

    /**
     * @brief Ajoute un message √† la file
     */
    bool AsyncLogger::Enqueue(const LogMessage& message) {
        std::unique_lock<std::mutex> lock(m_QueueMutex);

        if (m_MessageQueue.size() >= m_MaxQueueSize) {
            return false; // File pleine
        }

        m_MessageQueue.push(message);
        lock.unlock();

        m_Condition.notify_one();
        return true;
    }

    /**
     * @brief Traite un message de la file
     */
    void AsyncLogger::ProcessMessage(const LogMessage& message) {
        // Utiliser le logger parent pour traiter
        std::lock_guard<std::mutex> lock(m_Mutex);
        
        std::string formatted;
        if (m_Formatter) {
            formatted = m_Formatter->Format(message);
        } else {
            formatted = message.message;
        }

        for (auto& sink : m_Sinks) {
            if (sink) {
                sink->Log(message);
            }
        }
    }

    /**
     * @brief Vide toute la file d'attente
     */
    void AsyncLogger::FlushQueue() {
        std::unique_lock<std::mutex> lock(m_QueueMutex);

        while (!m_MessageQueue.empty()) {
            LogMessage msg = m_MessageQueue.front();
            m_MessageQueue.pop();
            lock.unlock();

            ProcessMessage(msg);

            lock.lock();
        }
    }

} // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\AsyncSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/AsyncSink.h
// DESCRIPTION: Logger asynchrone pour les performances.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Logger.h"
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <memory>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: AsyncLogger
        // DESCRIPTION: Logger asynchrone avec file d'attente
        // -------------------------------------------------------------------------
        class LOGGER_API AsyncLogger : public Logger {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS ET DESTRUCTEUR
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur avec nom et configuration
                 * @param name Nom du logger
                 * @param queueSize Taille maximum de la file d'attente
                 * @param flushInterval Intervalle de flush en ms
                 */
                AsyncLogger(const std::string& name, size_t queueSize = 8192, uint32 flushInterval = 1000);
                
                /**
                 * @brief Destructeur
                 */
                ~AsyncLogger();
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE Logger
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Log asynchrone
                 */
                virtual void Log(LogLevel level, const char* format, ...) override;
                void Log(LogLevel level, const std::string& message);
                /**
                 * @brief Force le flush des messages en attente
                 */
                void Flush() override;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION ASYNCHRONE
                // ---------------------------------------------------------------------
                
                /**
                 * @brief D√©marre le thread de traitement
                 */
                void Start();
                
                /**
                 * @brief Arr√™te le thread de traitement
                 */
                void Stop();
                
                /**
                 * @brief V√©rifie si le logger est en cours d'ex√©cution
                 * @return true si en cours d'ex√©cution, false sinon
                 */
                bool IsRunning() const;
                
                /**
                 * @brief Obtient la taille actuelle de la file d'attente
                 * @return Taille de la file
                 */
                size_t GetQueueSize() const;
                
                /**
                 * @brief D√©finit la taille maximum de la file
                 * @param size Taille maximum
                 */
                void SetMaxQueueSize(size_t size);
                
                /**
                 * @brief Obtient la taille maximum de la file
                 * @return Taille maximum
                 */
                size_t GetMaxQueueSize() const;
                
                /**
                 * @brief D√©finit l'intervalle de flush
                 * @param ms Intervalle en millisecondes
                 */
                void SetFlushInterval(uint32 ms);
                
                /**
                 * @brief Obtient l'intervalle de flush
                 * @return Intervalle en millisecondes
                 */
                uint32 GetFlushInterval() const;

            private:
                // ---------------------------------------------------------------------
                // M√âTHODES PRIV√âES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Fonction du thread de traitement
                 */
                void WorkerThread();
                
                /**
                 * @brief Ajoute un message √† la file d'attente
                 * @param message Message √† ajouter
                 * @return true si ajout√©, false si file pleine
                 */
                bool Enqueue(const LogMessage& message);
                
                /**
                 * @brief Traite un message de la file
                 * @param message Message √† traiter
                 */
                void ProcessMessage(const LogMessage& message);
                
                /**
                 * @brief Vide toute la file d'attente
                 */
                void FlushQueue();
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// File d'attente des messages
                std::queue<LogMessage> m_MessageQueue;
                
                /// Taille maximum de la file
                size_t m_MaxQueueSize;
                
                /// Intervalle de flush en ms
                uint32 m_FlushInterval;
                
                /// Thread de traitement
                std::thread m_WorkerThread;
                
                /// Mutex pour la file d'attente
                mutable std::mutex m_QueueMutex;
                
                /// Condition variable pour la synchronisation
                std::condition_variable m_Condition;
                
                /// Indicateur d'ex√©cution
                std::atomic<bool> m_Running;
                
                /// Indicateur d'arr√™t demand√©
                std::atomic<bool> m_StopRequested;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\ConsoleSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/ConsoleSink.cpp
// DESCRIPTION: Impl√©mentation du sink console avec support couleur.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/ConsoleSink.h"
#include "Logger/LogLevel.h"

#ifdef _WIN32
#include <Windows.h>
#endif

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE ConsoleSink
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur par d√©faut
         */
        ConsoleSink::ConsoleSink()
            : m_Stream(ConsoleStream::StdOut)
            , m_UseColors(true)
            , m_UseStderrForErrors(true) {
            m_Formatter = std::make_unique<Formatter>(Formatter::COLOR_PATTERN);
        }
        
        /**
         * @brief Constructeur avec flux sp√©cifique
         */
        ConsoleSink::ConsoleSink(ConsoleStream stream, bool useColors)
            : m_Stream(stream)
            , m_UseColors(useColors)
            , m_UseStderrForErrors(true) {
            m_Formatter = std::make_unique<Formatter>(
                useColors ? Formatter::COLOR_PATTERN : Formatter::DEFAULT_PATTERN);
        }
        
        /**
         * @brief Destructeur
         */
        ConsoleSink::~ConsoleSink() {
            Flush();
        }
        
        /**
         * @brief Logge un message dans la console
         */
        void ConsoleSink::Log(const LogMessage& message) {
            if (!IsEnabled() || !ShouldLog(message.level)) {
                return;
            }
            
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            // Formater le message
            std::string formatted = m_Formatter->Format(message, m_UseColors && SupportsColors());
            
            // Obtenir le flux appropri√©
            std::ostream& stream = GetStreamForLevel(message.level);
            
            // √âcrire le message
            stream << formatted << std::endl;
            
            // Flush pour les niveaux critiques
            if (message.level >= LogLevel::Error) {
                stream.flush();
            }
        }
        
        /**
         * @brief Force l'√©criture des donn√©es en attente
         */
        void ConsoleSink::Flush() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            if (m_Stream == ConsoleStream::StdOut || 
                (m_UseStderrForErrors && m_Stream == ConsoleStream::StdOut)) {
                std::cout.flush();
            }
            
            if (m_Stream == ConsoleStream::StdErr || 
                (m_UseStderrForErrors && m_Stream == ConsoleStream::StdOut)) {
                std::cerr.flush();
            }
        }
        
        /**
         * @brief D√©finit le formatter pour ce sink
         */
        void ConsoleSink::SetFormatter(std::unique_ptr<Formatter> formatter) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Formatter = std::move(formatter);
        }
        
        /**
         * @brief D√©finit le pattern de formatage
         */
        void ConsoleSink::SetPattern(const std::string& pattern) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_Formatter) {
                m_Formatter->SetPattern(pattern);
            }
        }
        
        /**
         * @brief Obtient le formatter courant
         */
        Formatter* ConsoleSink::GetFormatter() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Formatter.get();
        }
        
        /**
         * @brief Obtient le pattern courant
         */
        std::string ConsoleSink::GetPattern() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_Formatter) {
                return m_Formatter->GetPattern();
            }
            return "";
        }
        
        /**
         * @brief Active ou d√©sactive les couleurs
         */
        void ConsoleSink::SetColorEnabled(bool enable) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_UseColors = enable;
        }
        
        /**
         * @brief V√©rifie si les couleurs sont activ√©es
         */
        bool ConsoleSink::IsColorEnabled() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_UseColors;
        }
        
        /**
         * @brief D√©finit le flux de console
         */
        void ConsoleSink::SetStream(ConsoleStream stream) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Stream = stream;
        }
        
        /**
         * @brief Obtient le flux de console courant
         */
        ConsoleStream ConsoleSink::GetStream() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Stream;
        }
        
        /**
         * @brief D√©finit si le sink doit utiliser stderr pour les niveaux d'erreur
         */
        void ConsoleSink::SetUseStderrForErrors(bool enable) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_UseStderrForErrors = enable;
        }
        
        /**
         * @brief V√©rifie si le sink utilise stderr pour les erreurs
         */
        bool ConsoleSink::IsUsingStderrForErrors() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_UseStderrForErrors;
        }
        
        /**
         * @brief Obtient le flux de sortie appropri√© pour un niveau de log
         */
        std::ostream& ConsoleSink::GetStreamForLevel(LogLevel level) {
            if (m_UseStderrForErrors && 
                (level == LogLevel::Error || 
                level == LogLevel::Critical || 
                level == LogLevel::Fatal)) {
                return std::cerr;
            }
            
            return (m_Stream == ConsoleStream::StdOut) ? std::cout : std::cerr;
        }
        
        /**
         * @brief V√©rifie si la console supporte les couleurs
         */
        bool ConsoleSink::SupportsColors() const {
            #ifdef _WIN32
                // Windows: v√©rifier si la console supporte les couleurs
                HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
                if (hConsole == INVALID_HANDLE_VALUE) {
                    return false;
                }
                
                DWORD mode;
                if (!GetConsoleMode(hConsole, &mode)) {
                    return false;
                }
                
                return (mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) != 0;
            #else
                // Unix: v√©rifier si c'est un terminal et supporte les couleurs
                static bool checked = false;
                static bool supports = false;
                
                if (!checked) {
                    const char* term = getenv("TERM");
                    supports = (isatty(fileno(stdout)) && term != nullptr && 
                            strstr(term, "xterm") != nullptr);
                    checked = true;
                }
                
                return supports;
            #endif
        }
        
        /**
         * @brief Obtient le code couleur pour un niveau de log
         */
        std::string ConsoleSink::GetColorCode(LogLevel level) const {
            return LogLevelToANSIColor(level);
        }
        
        /**
         * @brief Obtient le code de r√©initialisation de couleur
         */
        std::string ConsoleSink::GetResetCode() const {
            return "\033[0m";
        }
        
        /**
         * @brief Configure la couleur Windows pour un niveau de log
         */
        void ConsoleSink::SetWindowsColor(LogLevel level) {
            #ifdef _WIN32
                HANDLE hConsole = GetStdHandle(
                    (m_Stream == ConsoleStream::StdOut) ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);
                
                if (hConsole != INVALID_HANDLE_VALUE) {
                    WORD color = LogLevelToWindowsColor(level);
                    SetConsoleTextAttribute(hConsole, color);
                }
            #endif
        }
        
        /**
         * @brief R√©initialise la couleur Windows
         */
        void ConsoleSink::ResetWindowsColor() {
            #ifdef _WIN32
                HANDLE hConsole = GetStdHandle(
                    (m_Stream == ConsoleStream::StdOut) ? STD_OUTPUT_HANDLE : STD_ERROR_HANDLE);
                
                if (hConsole != INVALID_HANDLE_VALUE) {
                    SetConsoleTextAttribute(hConsole, 0x07); // Gris sur noir
                }
            #endif
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\ConsoleSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/ConsoleSink.h
// DESCRIPTION: Sink pour la sortie console (stdout/stderr) avec support couleur.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Sink.h"
#include <iostream>
#include <mutex>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // √âNUM√âRATION: ConsoleStream
        // DESCRIPTION: Flux de console disponibles
        // -------------------------------------------------------------------------
        enum class ConsoleStream {
            StdOut,  // Sortie standard (stdout)
            StdErr   // Erreur standard (stderr)
        };

        // -------------------------------------------------------------------------
        // CLASSE: ConsoleSink
        // DESCRIPTION: Sink pour la sortie console avec couleurs
        // -------------------------------------------------------------------------
        class LOGGER_API ConsoleSink : public ISink {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur par d√©faut (stdout, avec couleurs)
                 */
                ConsoleSink();
                
                /**
                 * @brief Constructeur avec flux sp√©cifique
                 * @param stream Flux √† utiliser
                 * @param useColors Utiliser les couleurs (si support√©)
                 */
                explicit ConsoleSink(ConsoleStream stream, bool useColors = true);
                
                /**
                 * @brief Destructeur
                 */
                ~ConsoleSink() override;
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE ISink
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Logge un message dans la console
                 */
                void Log(const LogMessage& message) override;
                
                /**
                 * @brief Force l'√©criture des donn√©es en attente
                 */
                void Flush() override;
                
                /**
                 * @brief D√©finit le formatter pour ce sink
                 */
                void SetFormatter(std::unique_ptr<Formatter> formatter) override;
                
                /**
                 * @brief D√©finit le pattern de formatage
                 */
                void SetPattern(const std::string& pattern) override;
                
                /**
                 * @brief Obtient le formatter courant
                 */
                Formatter* GetFormatter() const override;
                
                /**
                 * @brief Obtient le pattern courant
                 */
                std::string GetPattern() const override;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION SP√âCIFIQUE √Ä LA CONSOLE
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Active ou d√©sactive les couleurs
                 * @param enable true pour activer les couleurs
                 */
                void SetColorEnabled(bool enable);
                
                /**
                 * @brief V√©rifie si les couleurs sont activ√©es
                 * @return true si activ√©es, false sinon
                 */
                bool IsColorEnabled() const;
                
                /**
                 * @brief D√©finit le flux de console
                 * @param stream Flux √† utiliser
                 */
                void SetStream(ConsoleStream stream);
                
                /**
                 * @brief Obtient le flux de console courant
                 * @return Flux courant
                 */
                ConsoleStream GetStream() const;
                
                /**
                 * @brief D√©finit si le sink doit utiliser stderr pour les niveaux d'erreur
                 * @param enable true pour utiliser stderr pour Error/Critical/Fatal
                 */
                void SetUseStderrForErrors(bool enable);
                
                /**
                 * @brief V√©rifie si le sink utilise stderr pour les erreurs
                 * @return true si activ√©, false sinon
                 */
                bool IsUsingStderrForErrors() const;

            private:
                // ---------------------------------------------------------------------
                // M√âTHODES PRIV√âES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Obtient le flux de sortie appropri√© pour un niveau de log
                 * @param level Niveau de log
                 * @return R√©f√©rence au flux ostream appropri√©
                 */
                std::ostream& GetStreamForLevel(LogLevel level);
                
                /**
                 * @brief V√©rifie si la console supporte les couleurs
                 * @return true si support√©, false sinon
                 */
                bool SupportsColors() const;
                
                /**
                 * @brief Obtient le code couleur pour un niveau de log
                 * @param level Niveau de log
                 * @return Code couleur ANSI
                 */
                std::string GetColorCode(LogLevel level) const;
                
                /**
                 * @brief Obtient le code de r√©initialisation de couleur
                 * @return Code de r√©initialisation ANSI
                 */
                std::string GetResetCode() const;
                
                /**
                 * @brief Configure la couleur Windows pour un niveau de log
                 * @param level Niveau de log
                 */
                void SetWindowsColor(LogLevel level);
                
                /**
                 * @brief R√©initialise la couleur Windows
                 */
                void ResetWindowsColor();
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Formatter pour ce sink
                std::unique_ptr<Formatter> m_Formatter;
                
                /// Flux de console principal
                ConsoleStream m_Stream;
                
                /// Utiliser les couleurs
                bool m_UseColors;
                
                /// Utiliser stderr pour les niveaux d'erreur
                bool m_UseStderrForErrors;
                
                /// Mutex pour la synchronisation thread-safe
                mutable std::mutex m_Mutex;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\DailyFileSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/DailyFileSink.cpp
// DESCRIPTION: Impl√©mentation du sink avec rotation quotidienne.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/DailyFileSink.h"
#include <filesystem>
#include <sstream>
#include <iomanip>
#include <ctime>

namespace nkentseu {
namespace logger {

    /**
     * @brief Constructeur avec configuration
     */
    DailyFileSink::DailyFileSink(const std::string& filename, int hour, int minute, size_t maxDays)
        : FileSink(filename, false)
        , m_RotationHour(hour)
        , m_RotationMinute(minute)
        , m_MaxDays(maxDays)
        , m_LastCheck(std::chrono::system_clock::now()) {
        
        // Initialiser la date courante
        auto now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
        #ifdef _WIN32
            localtime_s(&m_CurrentDate, &now);
        #else
            localtime_r(&now, &m_CurrentDate);
        #endif
    }

    /**
     * @brief Destructeur
     */
    DailyFileSink::~DailyFileSink() {
    }

    /**
     * @brief Logge un message avec v√©rification de rotation quotidienne
     */
    void DailyFileSink::Log(const LogMessage& message) {
        FileSink::Log(message);
    }

    /**
     * @brief D√©finit l'heure de rotation
     */
    void DailyFileSink::SetRotationTime(int hour, int minute) {
        std::lock_guard<std::mutex> lock(m_Mutex);
        m_RotationHour = hour;
        m_RotationMinute = minute;
    }

    /**
     * @brief Obtient l'heure de rotation
     */
    int DailyFileSink::GetRotationHour() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_RotationHour;
    }

    /**
     * @brief Obtient la minute de rotation
     */
    int DailyFileSink::GetRotationMinute() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_RotationMinute;
    }

    /**
     * @brief D√©finit le nombre maximum de jours √† conserver
     */
    void DailyFileSink::SetMaxDays(size_t maxDays) {
        std::lock_guard<std::mutex> lock(m_Mutex);
        m_MaxDays = maxDays;
    }

    /**
     * @brief Obtient le nombre maximum de jours √† conserver
     */
    size_t DailyFileSink::GetMaxDays() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_MaxDays;
    }

    /**
     * @brief Force la rotation du fichier
     */
    bool DailyFileSink::Rotate() {
        PerformRotation();
        return true;
    }

    /**
     * @brief V√©rifie et effectue la rotation si n√©cessaire
     */
    void DailyFileSink::CheckRotation() {
        auto now = std::chrono::system_clock::now();
        
        // V√©rifier seulement toutes les minutes
        if (std::chrono::duration_cast<std::chrono::minutes>(now - m_LastCheck).count() < 1) {
            return;
        }
        
        m_LastCheck = now;
        
        // V√©rifier si changement de jour
        auto nowTime = std::chrono::system_clock::to_time_t(now);
        std::tm nowDate;
        #ifdef _WIN32
            localtime_s(&nowDate, &nowTime);
        #else
            localtime_r(&nowTime, &nowDate);
        #endif
        
        if (nowDate.tm_year != m_CurrentDate.tm_year ||
            nowDate.tm_mon != m_CurrentDate.tm_mon ||
            nowDate.tm_mday != m_CurrentDate.tm_mday) {
            
            // V√©rifier l'heure de rotation
            if (nowDate.tm_hour >= m_RotationHour && 
                nowDate.tm_min >= m_RotationMinute) {
                PerformRotation();
                m_CurrentDate = nowDate;
            }
        }
    }

    /**
     * @brief Effectue la rotation quotidienne
     */
    void DailyFileSink::PerformRotation() {
        Close();
        
        // G√©n√©rer le nom de fichier avec la date
        std::string rotatedFile = GetFilenameForDate(m_CurrentDate);
        
        // Renommer le fichier courant
        if (std::filesystem::exists(GetFilename())) {
            std::filesystem::rename(GetFilename(), rotatedFile);
        }
        
        // Nettoyer les anciens fichiers
        if (m_MaxDays > 0) {
            CleanOldFiles();
        }
        
        Open();
    }

    /**
     * @brief Nettoie les anciens fichiers
     */
    void DailyFileSink::CleanOldFiles() {
        // TODO: Impl√©menter le nettoyage des fichiers plus anciens que maxDays
    }

    /**
     * @brief G√©n√®re le nom de fichier pour une date donn√©e
     */
    std::string DailyFileSink::GetFilenameForDate(const std::tm& date) const {
        std::ostringstream oss;
        oss << GetFilename() << "."
            << std::setfill('0') << std::setw(4) << (date.tm_year + 1900)
            << std::setw(2) << (date.tm_mon + 1)
            << std::setw(2) << date.tm_mday;
        return oss.str();
    }

    /**
     * @brief Extrait la date d'un nom de fichier
     */
    std::tm DailyFileSink::ExtractDateFromFilename(const std::string& filename) const {
        std::tm date = {};
        // TODO: Parser le nom de fichier
        return date;
    }

    /**
     * @brief V√©rifie si une date est plus ancienne que maxDays
     */
    bool DailyFileSink::IsDateTooOld(const std::tm& date) const {
        // TODO: Comparer avec la date courante
        return false;
    }

} // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\DailyFileSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/DailyFileSink.h
// DESCRIPTION: Sink pour fichiers avec rotation quotidienne.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Sinks/FileSink.h"
#include <chrono>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: DailyFileSink
        // DESCRIPTION: Sink avec rotation quotidienne de fichiers
        // -------------------------------------------------------------------------
        class LOGGER_API DailyFileSink : public FileSink {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur avec configuration
                 * @param filename Chemin du fichier (peut contenir des patterns de date)
                 * @param hour Heure de rotation (0-23)
                 * @param minute Minute de rotation (0-59)
                 * @param maxDays Nombre maximum de jours √† conserver (0 = illimit√©)
                 */
                DailyFileSink(const std::string& filename, int hour = 0, int minute = 0, size_t maxDays = 0);
                
                /**
                 * @brief Destructeur
                 */
                ~DailyFileSink() override;
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE FileSink
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Logge un message avec v√©rification de rotation quotidienne
                 */
                void Log(const LogMessage& message) override;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION DE LA ROTATION QUOTIDIENNE
                // ---------------------------------------------------------------------
                
                /**
                 * @brief D√©finit l'heure de rotation
                 * @param hour Heure (0-23)
                 * @param minute Minute (0-59)
                 */
                void SetRotationTime(int hour, int minute);
                
                /**
                 * @brief Obtient l'heure de rotation
                 * @return Heure de rotation
                 */
                int GetRotationHour() const;
                
                /**
                 * @brief Obtient la minute de rotation
                 * @return Minute de rotation
                 */
                int GetRotationMinute() const;
                
                /**
                 * @brief D√©finit le nombre maximum de jours √† conserver
                 * @param maxDays Nombre de jours (0 = illimit√©)
                 */
                void SetMaxDays(size_t maxDays);
                
                /**
                 * @brief Obtient le nombre maximum de jours √† conserver
                 * @return Nombre de jours
                 */
                size_t GetMaxDays() const;
                
                /**
                 * @brief Force la rotation du fichier
                 * @return true si rotation r√©ussie, false sinon
                 */
                bool Rotate();

            private:
                // ---------------------------------------------------------------------
                // M√âTHODES PRIV√âES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief V√©rifie et effectue la rotation si n√©cessaire
                 */
                void CheckRotation() override;
                
                /**
                 * @brief Effectue la rotation quotidienne
                 */
                void PerformRotation();
                
                /**
                 * @brief Nettoie les anciens fichiers
                 */
                void CleanOldFiles();
                
                /**
                 * @brief G√©n√®re le nom de fichier pour une date donn√©e
                 * @param date Date
                 * @return Nom de fichier
                 */
                std::string GetFilenameForDate(const std::tm& date) const;
                
                /**
                 * @brief Extrait la date d'un nom de fichier
                 * @param filename Nom de fichier
                 * @return Structure tm avec la date
                 */
                std::tm ExtractDateFromFilename(const std::string& filename) const;
                
                /**
                 * @brief V√©rifie si une date est plus ancienne que maxDays
                 * @param date Date √† v√©rifier
                 * @return true si trop ancienne, false sinon
                 */
                bool IsDateTooOld(const std::tm& date) const;
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Heure de rotation (0-23)
                int m_RotationHour;
                
                /// Minute de rotation (0-59)
                int m_RotationMinute;
                
                /// Nombre maximum de jours √† conserver
                size_t m_MaxDays;
                
                /// Date du fichier courant
                std::tm m_CurrentDate;
                
                /// Derni√®re v√©rification de rotation
                std::chrono::system_clock::time_point m_LastCheck;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\DistributingSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/DistributingSink.cpp
// DESCRIPTION: Impl√©mentation du sink distribuant les messages √† plusieurs sous-sinks.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/DistributingSink.h"
#include <algorithm>

namespace nkentseu {
namespace logger {

    /**
     * @brief Constructeur par d√©faut
     */
    DistributingSink::DistributingSink() {
    }

    /**
     * @brief Constructeur avec liste initiale de sinks
     */
    DistributingSink::DistributingSink(const std::vector<std::shared_ptr<ISink>>& sinks)
        : m_Sinks(sinks) {
    }

    /**
     * @brief Destructeur
     */
    DistributingSink::~DistributingSink() {
    }

    /**
     * @brief Distribue un message √† tous les sous-sinks
     */
    void DistributingSink::Log(const LogMessage& message) {
        if (!IsEnabled() || !ShouldLog(message.level)) {
            return;
        }

        std::lock_guard<std::mutex> lock(m_Mutex);
        for (auto& sink : m_Sinks) {
            if (sink) {
                sink->Log(message);
            }
        }
    }

    /**
     * @brief Force le flush de tous les sous-sinks
     */
    void DistributingSink::Flush() {
        std::lock_guard<std::mutex> lock(m_Mutex);
        for (auto& sink : m_Sinks) {
            if (sink) {
                sink->Flush();
            }
        }
    }

    /**
     * @brief D√©finit le formatter pour tous les sous-sinks
     */
    void DistributingSink::SetFormatter(std::unique_ptr<Formatter> formatter) {
        std::lock_guard<std::mutex> lock(m_Mutex);
        // Clone le formatter pour chaque sink
        for (auto& sink : m_Sinks) {
            if (sink && formatter) {
                auto clonedFormatter = std::make_unique<Formatter>(formatter->GetPattern());
                sink->SetFormatter(std::move(clonedFormatter));
            }
        }
    }

    /**
     * @brief D√©finit le pattern de formatage pour tous les sous-sinks
     */
    void DistributingSink::SetPattern(const std::string& pattern) {
        std::lock_guard<std::mutex> lock(m_Mutex);
        for (auto& sink : m_Sinks) {
            if (sink) {
                sink->SetPattern(pattern);
            }
        }
    }

    /**
     * @brief Obtient le formatter (du premier sink)
     */
    Formatter* DistributingSink::GetFormatter() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        if (!m_Sinks.empty() && m_Sinks[0]) {
            return m_Sinks[0]->GetFormatter();
        }
        return nullptr;
    }

    /**
     * @brief Obtient le pattern (du premier sink)
     */
    std::string DistributingSink::GetPattern() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        if (!m_Sinks.empty() && m_Sinks[0]) {
            return m_Sinks[0]->GetPattern();
        }
        return "";
    }

    /**
     * @brief Ajoute un sous-sink
     */
    void DistributingSink::AddSink(std::shared_ptr<ISink> sink) {
        if (!sink) return;
        
        std::lock_guard<std::mutex> lock(m_Mutex);
        m_Sinks.push_back(sink);
    }

    /**
     * @brief Supprime un sous-sink
     */
    void DistributingSink::RemoveSink(std::shared_ptr<ISink> sink) {
        if (!sink) return;
        
        std::lock_guard<std::mutex> lock(m_Mutex);
        auto it = std::find(m_Sinks.begin(), m_Sinks.end(), sink);
        if (it != m_Sinks.end()) {
            m_Sinks.erase(it);
        }
    }

    /**
     * @brief Supprime tous les sous-sinks
     */
    void DistributingSink::ClearSinks() {
        std::lock_guard<std::mutex> lock(m_Mutex);
        m_Sinks.clear();
    }

    /**
     * @brief Obtient la liste des sous-sinks
     */
    std::vector<std::shared_ptr<ISink>> DistributingSink::GetSinks() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_Sinks;
    }

    /**
     * @brief Obtient le nombre de sous-sinks
     */
    size_t DistributingSink::GetSinkCount() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_Sinks.size();
    }

    /**
     * @brief V√©rifie si un sink sp√©cifique est pr√©sent
     */
    bool DistributingSink::ContainsSink(std::shared_ptr<ISink> sink) const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return std::find(m_Sinks.begin(), m_Sinks.end(), sink) != m_Sinks.end();
    }

} // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\DistributingSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/DistributingSink.h
// DESCRIPTION: Sink qui distribue les messages √† plusieurs sous-sinks.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Sink.h"
#include <vector>
#include <memory>
#include <mutex>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: DistributingSink
        // DESCRIPTION: Sink qui distribue les messages √† plusieurs sous-sinks
        // -------------------------------------------------------------------------
        class LOGGER_API DistributingSink : public ISink {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur par d√©faut
                 */
                DistributingSink();
                
                /**
                 * @brief Constructeur avec liste initiale de sinks
                 * @param sinks Liste de sinks √† ajouter
                 */
                explicit DistributingSink(const std::vector<std::shared_ptr<ISink>>& sinks);
                
                /**
                 * @brief Destructeur
                 */
                ~DistributingSink() override;
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE ISink
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Distribue un message √† tous les sous-sinks
                 */
                void Log(const LogMessage& message) override;
                
                /**
                 * @brief Force le flush de tous les sous-sinks
                 */
                void Flush() override;
                
                /**
                 * @brief D√©finit le formatter pour tous les sous-sinks
                 */
                void SetFormatter(std::unique_ptr<Formatter> formatter) override;
                
                /**
                 * @brief D√©finit le pattern de formatage pour tous les sous-sinks
                 */
                void SetPattern(const std::string& pattern) override;
                
                /**
                 * @brief Obtient le formatter (du premier sink)
                 */
                Formatter* GetFormatter() const override;
                
                /**
                 * @brief Obtient le pattern (du premier sink)
                 */
                std::string GetPattern() const override;
                
                // ---------------------------------------------------------------------
                // GESTION DES SOUS-SINKS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Ajoute un sous-sink
                 * @param sink Sink √† ajouter
                 */
                void AddSink(std::shared_ptr<ISink> sink);
                
                /**
                 * @brief Supprime un sous-sink
                 * @param sink Sink √† supprimer
                 */
                void RemoveSink(std::shared_ptr<ISink> sink);
                
                /**
                 * @brief Supprime tous les sous-sinks
                 */
                void ClearSinks();
                
                /**
                 * @brief Obtient la liste des sous-sinks
                 * @return Vecteur des sous-sinks
                 */
                std::vector<std::shared_ptr<ISink>> GetSinks() const;
                
                /**
                 * @brief Obtient le nombre de sous-sinks
                 * @return Nombre de sous-sinks
                 */
                size_t GetSinkCount() const;
                
                /**
                 * @brief V√©rifie si un sink sp√©cifique est pr√©sent
                 * @param sink Sink √† rechercher
                 * @return true si pr√©sent, false sinon
                 */
                bool ContainsSink(std::shared_ptr<ISink> sink) const;

            private:
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Liste des sous-sinks
                std::vector<std::shared_ptr<ISink>> m_Sinks;
                
                /// Mutex pour la synchronisation thread-safe
                mutable std::mutex m_Mutex;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\FileSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/FileSink.cpp
// DESCRIPTION: Impl√©mentation du sink fichier.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/FileSink.h"
#include <filesystem>
#include <chrono>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // IMPL√âMENTATION DE FileSink
        // -------------------------------------------------------------------------
        
        /**
         * @brief Constructeur avec chemin de fichier
         */
        FileSink::FileSink(const std::string& filename, bool truncate)
            : m_Filename(filename)
            , m_Truncate(truncate) {
            m_Formatter = std::make_unique<Formatter>(Formatter::DEFAULT_PATTERN);
            
            // Cr√©er le r√©pertoire parent si n√©cessaire
            std::filesystem::path path(filename);
            if (path.has_parent_path()) {
                std::filesystem::create_directories(path.parent_path());
            }
            
            Open();
        }
        
        /**
         * @brief Destructeur
         */
        FileSink::~FileSink() {
            Close();
        }
        
        /**
         * @brief Logge un message dans le fichier
         */
        void FileSink::Log(const LogMessage& message) {
            if (!IsEnabled() || !ShouldLog(message.level)) {
                return;
            }
            
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            // V√©rifier si le fichier est ouvert
            if (!m_FileStream.is_open()) {
                if (!OpenFile()) {
                    return; // Impossible d'ouvrir le fichier
                }
            }
            
            // Formater le message
            std::string formatted = m_Formatter->Format(message, false);
            
            // √âcrire dans le fichier
            m_FileStream << formatted << std::endl;
            
            // V√©rifier la rotation si n√©cessaire
            CheckRotation();
        }
        
        /**
         * @brief Force l'√©criture des donn√©es en attente
         */
        void FileSink::Flush() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_FileStream.is_open()) {
                m_FileStream.flush();
            }
        }
        
        /**
         * @brief D√©finit le formatter pour ce sink
         */
        void FileSink::SetFormatter(std::unique_ptr<Formatter> formatter) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            m_Formatter = std::move(formatter);
        }
        
        /**
         * @brief D√©finit le pattern de formatage
         */
        void FileSink::SetPattern(const std::string& pattern) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_Formatter) {
                m_Formatter->SetPattern(pattern);
            }
        }
        
        /**
         * @brief Obtient le formatter courant
         */
        Formatter* FileSink::GetFormatter() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Formatter.get();
        }
        
        /**
         * @brief Obtient le pattern courant
         */
        std::string FileSink::GetPattern() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_Formatter) {
                return m_Formatter->GetPattern();
            }
            return "";
        }
        
        /**
         * @brief Ouvre le fichier
         */
        bool FileSink::Open() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return OpenFile();
        }
        
        /**
         * @brief Ferme le fichier
         */
        void FileSink::Close() {
            std::lock_guard<std::mutex> lock(m_Mutex);
            if (m_FileStream.is_open()) {
                m_FileStream.close();
            }
        }
        
        /**
         * @brief V√©rifie si le fichier est ouvert
         */
        bool FileSink::IsOpen() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_FileStream.is_open();
        }
        
        /**
         * @brief Obtient le nom du fichier
         */
        std::string FileSink::GetFilename() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Filename;
        }
        
        /**
         * @brief D√©finit un nouveau nom de fichier
         */
        void FileSink::SetFilename(const std::string& filename) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            if (m_Filename != filename) {
                // Fermer l'ancien fichier
                if (m_FileStream.is_open()) {
                    m_FileStream.close();
                }
                
                // Mettre √† jour le nom
                m_Filename = filename;
                
                // Cr√©er le r√©pertoire parent si n√©cessaire
                std::filesystem::path path(filename);
                if (path.has_parent_path()) {
                    std::filesystem::create_directories(path.parent_path());
                }
                
                // Ouvrir le nouveau fichier
                OpenFile();
            }
        }
        
        /**
         * @brief Obtient la taille actuelle du fichier
         */
        size_t FileSink::GetFileSize() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            if (!std::filesystem::exists(m_Filename)) {
                return 0;
            }
            
            try {
                return std::filesystem::file_size(m_Filename);
            } catch (...) {
                return 0;
            }
        }
        
        /**
         * @brief D√©finit le mode d'ouverture
         */
        void FileSink::SetTruncate(bool truncate) {
            std::lock_guard<std::mutex> lock(m_Mutex);
            
            if (m_Truncate != truncate) {
                m_Truncate = truncate;
                
                // Re-ouvrir le fichier avec le nouveau mode
                if (m_FileStream.is_open()) {
                    m_FileStream.close();
                    OpenFile();
                }
            }
        }
        
        /**
         * @brief Obtient le mode d'ouverture
         */
        bool FileSink::GetTruncate() const {
            std::lock_guard<std::mutex> lock(m_Mutex);
            return m_Truncate;
        }
        
        /**
         * @brief Ouvre le fichier avec le mode appropri√©
         */
        bool FileSink::OpenFile() {
            if (m_Filename.empty()) {
                return false;
            }
            
            // D√©terminer le mode d'ouverture
            std::ios_base::openmode mode = std::ios_base::out;
            if (!m_Truncate) {
                mode |= std::ios_base::app;
            }
            
            // Ouvrir le fichier
            m_FileStream.open(m_Filename, mode);
            
            if (!m_FileStream.is_open()) {
                // Essayer de cr√©er le r√©pertoire parent
                std::filesystem::path path(m_Filename);
                if (path.has_parent_path()) {
                    std::filesystem::create_directories(path.parent_path());
                    m_FileStream.open(m_Filename, mode);
                }
            }
            
            // V√©rifier l'ouverture
            if (!m_FileStream.is_open()) {
                return false;
            }
            
            // Configurer le flux
            m_FileStream << std::unitbuf; // Pas de buffering
            return true;
        }
        
        /**
         * @brief V√©rifie et g√®re la rotation de fichier si n√©cessaire
         */
        void FileSink::CheckRotation() {
            // Par d√©faut, pas de rotation
            // Les sous-classes peuvent override cette m√©thode
        }

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\FileSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/FileSink.h
// DESCRIPTION: Sink pour l'√©criture dans un fichier.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Sink.h"
#include <fstream>
#include <mutex>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: FileSink
        // DESCRIPTION: Sink pour l'√©criture dans un fichier
        // -------------------------------------------------------------------------
        class LOGGER_API FileSink : public ISink {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur avec chemin de fichier
                 * @param filename Chemin du fichier
                 * @param truncate true pour tronquer le fichier existant
                 */
                explicit FileSink(const std::string& filename, bool truncate = false);
                
                /**
                 * @brief Destructeur
                 */
                ~FileSink() override;
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE ISink
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Logge un message dans le fichier
                 */
                void Log(const LogMessage& message) override;
                
                /**
                 * @brief Force l'√©criture des donn√©es en attente
                 */
                void Flush() override;
                
                /**
                 * @brief D√©finit le formatter pour ce sink
                 */
                void SetFormatter(std::unique_ptr<Formatter> formatter) override;
                
                /**
                 * @brief D√©finit le pattern de formatage
                 */
                void SetPattern(const std::string& pattern) override;
                
                /**
                 * @brief Obtient le formatter courant
                 */
                Formatter* GetFormatter() const override;
                
                /**
                 * @brief Obtient le pattern courant
                 */
                std::string GetPattern() const override;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION SP√âCIFIQUE AU FICHIER
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Ouvre le fichier (si non ouvert)
                 * @return true si ouvert avec succ√®s, false sinon
                 */
                bool Open();
                
                /**
                 * @brief Ferme le fichier
                 */
                void Close();
                
                /**
                 * @brief V√©rifie si le fichier est ouvert
                 * @return true si ouvert, false sinon
                 */
                bool IsOpen() const;
                
                /**
                 * @brief Obtient le nom du fichier
                 * @return Nom du fichier
                 */
                std::string GetFilename() const;
                
                /**
                 * @brief D√©finit un nouveau nom de fichier
                 * @param filename Nouveau nom de fichier
                 */
                void SetFilename(const std::string& filename);
                
                /**
                 * @brief Obtient la taille actuelle du fichier
                 * @return Taille en octets
                 */
                size_t GetFileSize() const;
                
                /**
                 * @brief D√©finit le mode d'ouverture (truncate/append)
                 * @param truncate true pour tronquer, false pour append
                 */
                void SetTruncate(bool truncate);
                
                /**
                 * @brief Obtient le mode d'ouverture
                 * @return true si truncate, false si append
                 */
                bool GetTruncate() const;

            private:
                // ---------------------------------------------------------------------
                // M√âTHODES PRIV√âES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Ouvre le fichier avec le mode appropri√©
                 */
                bool OpenFile();
                
                /**
                 * @brief V√©rifie et g√®re la rotation de fichier si n√©cessaire
                 */
                virtual void CheckRotation();
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Formatter pour ce sink
                std::unique_ptr<Formatter> m_Formatter;
                
                /// Flux de fichier
                std::ofstream m_FileStream;
                
                /// Nom du fichier
                std::string m_Filename;
                
                /// Mode d'ouverture (truncate/append)
                bool m_Truncate;
            
            protected:
                /// Mutex pour la synchronisation thread-safe
                mutable std::mutex m_Mutex;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\NullSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/NullSink.cpp
// DESCRIPTION: Impl√©mentation du sink null (no-op).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/NullSink.h"

namespace nkentseu {
namespace logger {

    /**
     * @brief Constructeur par d√©faut
     */
    NullSink::NullSink() {
    }

    /**
     * @brief Destructeur
     */
    NullSink::~NullSink() {
    }

    /**
     * @brief Ignore le message (no-op)
     */
    void NullSink::Log(const LogMessage& message) {
        // No-op
    }

    /**
     * @brief No-op
     */
    void NullSink::Flush() {
        // No-op
    }

    /**
     * @brief No-op
     */
    void NullSink::SetFormatter(std::unique_ptr<Formatter> formatter) {
        // No-op
    }

    /**
     * @brief No-op
     */
    void NullSink::SetPattern(const std::string& pattern) {
        // No-op
    }

    /**
     * @brief Retourne nullptr
     */
    Formatter* NullSink::GetFormatter() const {
        return nullptr;
    }

    /**
     * @brief Retourne une cha√Æne vide
     */
    std::string NullSink::GetPattern() const {
        return "";
    }

} // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\NullSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/NullSink.h
// DESCRIPTION: Sink nul qui ignore tous les messages (pour d√©sactiver le logging).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Sink.h"

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: NullSink
        // DESCRIPTION: Sink qui ignore tous les messages (no-op)
        // -------------------------------------------------------------------------
        class LOGGER_API NullSink : public ISink {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur par d√©faut
                 */
                NullSink();
                
                /**
                 * @brief Destructeur
                 */
                ~NullSink() override;
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE ISink
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Ignore le message (no-op)
                 */
                void Log(const LogMessage& message) override;
                
                /**
                 * @brief No-op
                 */
                void Flush() override;
                
                /**
                 * @brief No-op
                 */
                void SetFormatter(std::unique_ptr<Formatter> formatter) override;
                
                /**
                 * @brief No-op
                 */
                void SetPattern(const std::string& pattern) override;
                
                /**
                 * @brief Retourne nullptr
                 */
                Formatter* GetFormatter() const override;
                
                /**
                 * @brief Retourne une cha√Æne vide
                 */
                std::string GetPattern() const override;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\RotatingFileSink.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/RotatingFileSink.cpp
// DESCRIPTION: Impl√©mentation du sink avec rotation bas√©e sur la taille.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Logger/Sinks/RotatingFileSink.h"
#include <filesystem>
#include <sstream>

namespace nkentseu {
namespace logger {

    /**
     * @brief Constructeur avec configuration de rotation
     */
    RotatingFileSink::RotatingFileSink(const std::string& filename, size_t maxSize, size_t maxFiles)
        : FileSink(filename, false)
        , m_MaxSize(maxSize)
        , m_MaxFiles(maxFiles)
        , m_CurrentSize(0) {
    }

    /**
     * @brief Destructeur
     */
    RotatingFileSink::~RotatingFileSink() {
    }

    /**
     * @brief Logge un message avec v√©rification de rotation
     */
    void RotatingFileSink::Log(const LogMessage& message) {
        FileSink::Log(message);
        m_CurrentSize = GetFileSize();
    }

    /**
     * @brief D√©finit la taille maximum des fichiers
     */
    void RotatingFileSink::SetMaxSize(size_t maxSize) {
        std::lock_guard<std::mutex> lock(m_Mutex);
        m_MaxSize = maxSize;
    }

    /**
     * @brief Obtient la taille maximum des fichiers
     */
    size_t RotatingFileSink::GetMaxSize() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_MaxSize;
    }

    /**
     * @brief D√©finit le nombre maximum de fichiers
     */
    void RotatingFileSink::SetMaxFiles(size_t maxFiles) {
        std::lock_guard<std::mutex> lock(m_Mutex);
        m_MaxFiles = maxFiles;
    }

    /**
     * @brief Obtient le nombre maximum de fichiers
     */
    size_t RotatingFileSink::GetMaxFiles() const {
        std::lock_guard<std::mutex> lock(m_Mutex);
        return m_MaxFiles;
    }

    /**
     * @brief Force la rotation du fichier
     */
    bool RotatingFileSink::Rotate() {
        PerformRotation();
        return true;
    }

    /**
     * @brief V√©rifie et effectue la rotation si n√©cessaire
     */
    void RotatingFileSink::CheckRotation() {
        if (m_CurrentSize >= m_MaxSize) {
            PerformRotation();
        }
    }

    /**
     * @brief Effectue la rotation des fichiers
     */
    void RotatingFileSink::PerformRotation() {
        // Fermer le fichier courant
        Close();

        // Rotation des fichiers: .log.N -> .log.N+1
        for (size_t i = m_MaxFiles - 1; i > 0; --i) {
            std::string oldFile = GetFilenameForIndex(i - 1);
            std::string newFile = GetFilenameForIndex(i);

            if (std::filesystem::exists(oldFile)) {
                std::filesystem::rename(oldFile, newFile);
            }
        }

        // Renommer le fichier courant en .log.0
        std::string currentFile = GetFilename();
        std::string rotatedFile = GetFilenameForIndex(0);

        if (std::filesystem::exists(currentFile)) {
            std::filesystem::rename(currentFile, rotatedFile);
        }

        // Rouvrir le fichier
        Open();
        m_CurrentSize = 0;
    }

    /**
     * @brief G√©n√®re le nom de fichier pour un index donn√©
     */
    std::string RotatingFileSink::GetFilenameForIndex(size_t index) const {
        std::ostringstream oss;
        oss << GetFilename() << "." << index;
        return oss.str();
    }

} // namespace logger
} // namespace nkentseu
==================================================


[FICHIER: Core\Logger\src\Logger\Sinks\RotatingFileSink.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Logger/src/Logger/Sinks/RotatingFileSink.h
// DESCRIPTION: Sink pour fichiers avec rotation bas√©e sur la taille.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Logger/Sinks/FileSink.h"

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu::logger
// -----------------------------------------------------------------------------
namespace nkentseu {
    namespace logger {

        // -------------------------------------------------------------------------
        // CLASSE: RotatingFileSink
        // DESCRIPTION: Sink avec rotation de fichier bas√©e sur la taille
        // -------------------------------------------------------------------------
        class LOGGER_API RotatingFileSink : public FileSink {
            public:
                // ---------------------------------------------------------------------
                // CONSTRUCTEURS
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Constructeur avec configuration de rotation
                 * @param filename Chemin du fichier
                 * @param maxSize Taille maximum par fichier (octets)
                 * @param maxFiles Nombre maximum de fichiers conserv√©s
                 */
                RotatingFileSink(const std::string& filename, size_t maxSize, size_t maxFiles);
                
                /**
                 * @brief Destructeur
                 */
                ~RotatingFileSink() override;
                
                // ---------------------------------------------------------------------
                // IMPL√âMENTATION DE FileSink
                // ---------------------------------------------------------------------
                
                /**
                 * @brief Logge un message avec v√©rification de rotation
                 */
                void Log(const LogMessage& message) override;
                
                // ---------------------------------------------------------------------
                // CONFIGURATION DE LA ROTATION
                // ---------------------------------------------------------------------
                
                /**
                 * @brief D√©finit la taille maximum des fichiers
                 * @param maxSize Taille en octets
                 */
                void SetMaxSize(size_t maxSize);
                
                /**
                 * @brief Obtient la taille maximum des fichiers
                 * @return Taille en octets
                 */
                size_t GetMaxSize() const;
                
                /**
                 * @brief D√©finit le nombre maximum de fichiers
                 * @param maxFiles Nombre maximum
                 */
                void SetMaxFiles(size_t maxFiles);
                
                /**
                 * @brief Obtient le nombre maximum de fichiers
                 * @return Nombre maximum
                 */
                size_t GetMaxFiles() const;
                
                /**
                 * @brief Force la rotation du fichier
                 * @return true si rotation r√©ussie, false sinon
                 */
                bool Rotate();

            private:
                // ---------------------------------------------------------------------
                // M√âTHODES PRIV√âES
                // ---------------------------------------------------------------------
                
                /**
                 * @brief V√©rifie et effectue la rotation si n√©cessaire
                 */
                void CheckRotation() override;
                
                /**
                 * @brief Effectue la rotation des fichiers
                 */
                void PerformRotation();
                
                /**
                 * @brief G√©n√®re le nom de fichier pour un index donn√©
                 * @param index Index du fichier
                 * @return Nom de fichier
                 */
                std::string GetFilenameForIndex(size_t index) const;
                
                // ---------------------------------------------------------------------
                // VARIABLES MEMBRE PRIV√âES
                // ---------------------------------------------------------------------
                
                /// Taille maximum par fichier (octets)
                size_t m_MaxSize;
                
                /// Nombre maximum de fichiers conserv√©s
                size_t m_MaxFiles;
                
                /// Taille courante du fichier
                size_t m_CurrentSize;
        };

    } // namespace logger
} // namespace nkentseu
==================================================


üìÅ DOSSIER: Core\Maths
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Maths\Maths.jenga]
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# FICHIER: Core/Math/Math.jenga
# DESCRIPTION: Configuration du projet Math (biblioth√®que math√©matique statique).
#              Fournit des structures et op√©rations math√©matiques optimis√©es.
# AUTEUR: Rihen
# DATE: 2026
# -----------------------------------------------------------------------------

from Jenga.core.api import *

with project("Maths"):
    # Type de projet: biblioth√®que statique
    staticlib()
    
    # Langage et version C++
    language("C++")
    cppdialect("C++17")
    
    # Fichiers sources globaux
    files([
        "src/Maths/**.cpp",
    ])
    
    # R√©pertoires d'inclusion publics
    includedirs([
        "src",
        "%{Nkentseu.location}/src",
        "%{Logger.location}/src",
    ])
    
    dependson(["Nkentseu", "Logger"])
    
    # Configuration des r√©pertoires de sortie
    targetdir("%{wks.location}/Build/Lib/%{cfg.buildcfg}")
    objdir("%{wks.location}/Build/Obj/%{cfg.buildcfg}/%{prj.name}")
    
    # Configuration Debug
    with filter("configurations:Debug"):
        defines(["DEBUG", "_DEBUG", "MATH_DEBUG"])
        optimize("Off")
        symbols("On")
    
    # Configuration Release
    with filter("configurations:Release"):
        defines(["NDEBUG", "RELEASE", "MATH_RELEASE"])
        optimize("Speed")
        symbols("Off")

    # Configuration des tests unitaires
    with test("MathTests"):
        # Les tests h√©ritent automatiquement de la configuration de Maths
        testfiles(["%{wks.location}/Core/Maths/tests/**.cpp"])
        
        # Options de test
        testoptions(["--verbose", "--color"])
==================================================


üìÅ DOSSIER: Core\Maths\src\Maths
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Maths\src\Maths\MathConstants.h]
==================================================
#pragma once

namespace nkentseu {
    namespace math {

        /**
         * @brief Constantes math√©matiques courantes
         */
        class Constants {
            public:
                static constexpr float PI = 3.14159265358979323846f;
                static constexpr float TWO_PI = 2.0f * PI;
                static constexpr float HALF_PI = PI / 2.0f;
                static constexpr float QUARTER_PI = PI / 4.0f;
                
                static constexpr float DEG_TO_RAD = PI / 180.0f;
                static constexpr float RAD_TO_DEG = 180.0f / PI;
                
                static constexpr float E = 2.71828182845904523536f;
                static constexpr float SQRT2 = 1.41421356237309504880f;
                static constexpr float SQRT3 = 1.73205080756887729352f;
                
                static constexpr float GOLDEN_RATIO = 1.61803398874989484820f;
        };

        // Constantes globales pour un acc√®s facile
        constexpr float PI = Constants::PI;
        constexpr float TWO_PI = Constants::TWO_PI;
        constexpr float HALF_PI = Constants::HALF_PI;
        constexpr float QUARTER_PI = Constants::QUARTER_PI;
        
        constexpr float DEG_TO_RAD = Constants::DEG_TO_RAD;
        constexpr float RAD_TO_DEG = Constants::RAD_TO_DEG;
        
        constexpr float E = Constants::E;
        constexpr float SQRT2 = Constants::SQRT2;
        constexpr float SQRT3 = Constants::SQRT3;
        
        constexpr float GOLDEN_RATIO = Constants::GOLDEN_RATIO;

    } // namespace math
} // namespace nkentseu
==================================================


[FICHIER: Core\Maths\src\Maths\Matrix3x3.cpp]
==================================================
#include "Matrix3x3.h"
#include <cmath>
#include <cstring>

namespace nkentseu {
    namespace math {
        Matrix3x3::Matrix3x3() {
            for (int i = 0; i < 3; i++)
                for (int j = 0; j < 3; j++)
                    m[i][j] = (i == j) ? 1.0f : 0.0f;
        }

        // Matrix3x3::Matrix3x3(const Matrix3x3& other) {
        //     std::memcpy(m, other.m, sizeof(m));
        // }
        
        Matrix3x3 Matrix3x3::Identity() {
            return Matrix3x3();
        }
        
        Matrix3x3 Matrix3x3::Translation(float x, float y) {
            Matrix3x3 mat = Identity();
            mat.m[0][2] = x;
            mat.m[1][2] = y;
            return mat;
        }
        
        Matrix3x3 Matrix3x3::Rotation(float angle) {
            Matrix3x3 mat = Identity();
            float cosA = std::cos(angle);
            float sinA = std::sin(angle);
            
            mat.m[0][0] = cosA;
            mat.m[0][1] = -sinA;
            mat.m[1][0] = sinA;
            mat.m[1][1] = cosA;
            
            return mat;
        }
        
        Matrix3x3 Matrix3x3::Scaling(float sx, float sy) {
            Matrix3x3 mat = Identity();
            mat.m[0][0] = sx;
            mat.m[1][1] = sy;
            return mat;
        }
        
        Matrix3x3 Matrix3x3::operator*(const Matrix3x3& other) const {
            Matrix3x3 result;
            
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    result.m[i][j] = 0.0f;
                    for (int k = 0; k < 3; k++) {
                        result.m[i][j] += m[i][k] * other.m[k][j];
                    }
                }
            }
            
            return result;
        }
        
        Vector2 Matrix3x3::TransformPoint(const Vector2& point) const {
            float x = m[0][0] * point.x + m[0][1] * point.y + m[0][2];
            float y = m[1][0] * point.x + m[1][1] * point.y + m[1][2];
            float w = m[2][0] * point.x + m[2][1] * point.y + m[2][2];
            
            if (w != 0.0f && w != 1.0f) {
                x /= w;
                y /= w;
            }
            
            return Vector2(x, y);
        }
        
        Vector2 Matrix3x3::TransformVector(const Vector2& vector) const {
            float x = m[0][0] * vector.x + m[0][1] * vector.y;
            float y = m[1][0] * vector.x + m[1][1] * vector.y;
            
            return Vector2(x, y);
        }
        
        float Matrix3x3::Determinant() const {
            // Formule du d√©terminant 3x3 : a(ei - fh) - b(di - fg) + c(dh - eg)
            return m[0][0] * (m[1][1]*m[2][2] - m[1][2]*m[2][1])
                 - m[0][1] * (m[1][0]*m[2][2] - m[1][2]*m[2][0])
                 + m[0][2] * (m[1][0]*m[2][1] - m[1][1]*m[2][0]);
        }
        
        Matrix3x3 Matrix3x3::Transpose() const {
            Matrix3x3 result;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    result.m[i][j] = m[j][i];
                }
            }
            return result;
        }
        
        Matrix3x3 Matrix3x3::Inverse() const {
            float det = Determinant();
            
            // V√©rifier si la matrice est inversible
            if (std::abs(det) < 1e-10f) {
                // Retourner la matrice identit√© comme fallback
                return Matrix3x3::Identity();
            }
            
            float invDet = 1.0f / det;
            Matrix3x3 result;
            
            // Calcul de la matrice des cofacteurs transpos√©e (comatrice)
            result.m[0][0] = invDet * (m[1][1]*m[2][2] - m[1][2]*m[2][1]);
            result.m[0][1] = invDet * (m[0][2]*m[2][1] - m[0][1]*m[2][2]);
            result.m[0][2] = invDet * (m[0][1]*m[1][2] - m[0][2]*m[1][1]);
            
            result.m[1][0] = invDet * (m[1][2]*m[2][0] - m[1][0]*m[2][2]);
            result.m[1][1] = invDet * (m[0][0]*m[2][2] - m[0][2]*m[2][0]);
            result.m[1][2] = invDet * (m[0][2]*m[1][0] - m[0][0]*m[1][2]);
            
            result.m[2][0] = invDet * (m[1][0]*m[2][1] - m[1][1]*m[2][0]);
            result.m[2][1] = invDet * (m[0][1]*m[2][0] - m[0][0]*m[2][1]);
            result.m[2][2] = invDet * (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
            
            return result;
        }
        
        // Op√©rateurs arithm√©tiques suppl√©mentaires
        Matrix3x3 Matrix3x3::operator+(const Matrix3x3& other) const {
            Matrix3x3 result;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    result.m[i][j] = m[i][j] + other.m[i][j];
                }
            }
            return result;
        }
        
        Matrix3x3 Matrix3x3::operator-(const Matrix3x3& other) const {
            Matrix3x3 result;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    result.m[i][j] = m[i][j] - other.m[i][j];
                }
            }
            return result;
        }
        
        Matrix3x3 Matrix3x3::operator*(float scalar) const {
            Matrix3x3 result;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    result.m[i][j] = m[i][j] * scalar;
                }
            }
            return result;
        }
        
        Matrix3x3 Matrix3x3::operator/(float scalar) const {
            if (std::abs(scalar) < 1e-10f) {
                // Division par z√©ro, retourner la matrice identit√© comme fallback
                return Matrix3x3::Identity();
            }
            
            float invScalar = 1.0f / scalar;
            Matrix3x3 result;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    result.m[i][j] = m[i][j] * invScalar;
                }
            }
            return result;
        }
        
        // Op√©rateurs d'affectation compos√©s
        Matrix3x3& Matrix3x3::operator+=(const Matrix3x3& other) {
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    m[i][j] += other.m[i][j];
                }
            }
            return *this;
        }
        
        Matrix3x3& Matrix3x3::operator-=(const Matrix3x3& other) {
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    m[i][j] -= other.m[i][j];
                }
            }
            return *this;
        }
        
        Matrix3x3& Matrix3x3::operator*=(float scalar) {
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    m[i][j] *= scalar;
                }
            }
            return *this;
        }
        
        Matrix3x3& Matrix3x3::operator/=(float scalar) {
            if (std::abs(scalar) < 1e-10f) {
                // Division par z√©ro, ne rien faire ou mettre √† z√©ro
                for (int i = 0; i < 3; ++i) {
                    for (int j = 0; j < 3; ++j) {
                        m[i][j] = 0.0f;
                    }
                }
                return *this;
            }
            
            float invScalar = 1.0f / scalar;
            for (int i = 0; i < 3; ++i) {
                for (int j = 0; j < 3; ++j) {
                    m[i][j] *= invScalar;
                }
            }
            return *this;
        }
        
        // Op√©rateur de multiplication par un vecteur (si utile)
        Vector2 Matrix3x3::operator*(const Vector2& v) const {
            return TransformPoint(v);
        }
    }
}
==================================================


[FICHIER: Core\Maths\src\Maths\Matrix3x3.h]
==================================================
#pragma once
#include "Vector2.h"

namespace nkentseu {
    namespace math {
        class Matrix3x3 {
            public:
                float m[3][3];
                
                Matrix3x3();
                // Matrix3x3(const Matrix3x3& other);
                
                // Matrice identit√©
                static Matrix3x3 Identity();
                
                // Matrices de transformation
                static Matrix3x3 Translation(float x, float y);
                static Matrix3x3 Rotation(float angle);
                static Matrix3x3 Scaling(float sx, float sy);
                
                // Op√©rations matricielles
                Matrix3x3 operator*(const Matrix3x3& other) const;
                Matrix3x3 operator+(const Matrix3x3& other) const;
                Matrix3x3 operator-(const Matrix3x3& other) const;
                Matrix3x3 operator*(float scalar) const;
                Matrix3x3 operator/(float scalar) const;
                
                // Op√©rations d'affectation
                Matrix3x3& operator+=(const Matrix3x3& other);
                Matrix3x3& operator-=(const Matrix3x3& other);
                Matrix3x3& operator*=(float scalar);
                Matrix3x3& operator/=(float scalar);
                
                // Multiplication par vecteur
                Vector2 operator*(const Vector2& v) const;
                
                Vector2 TransformPoint(const Vector2& point) const;
                Vector2 TransformVector(const Vector2& vector) const;
                
                // M√©thodes utilitaires
                Matrix3x3 Inverse() const;
                Matrix3x3 Transpose() const;
                float Determinant() const;

                bool operator==(const Matrix3x3& other) const {
                    for (int i = 0; i < 3; ++i) {
                        for (int j = 0; j < 3; ++j) {
                            if (m[i][j] != other.m[i][j]) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                bool operator!=(const Matrix3x3& other) const {
                    return !(*this == other);
                }
        };
        
        // Op√©rateur de multiplication scalaire √† gauche (non-membre)
        inline Matrix3x3 operator*(float scalar, const Matrix3x3& matrix) {
            return matrix * scalar;
        }
    }
}
==================================================


[FICHIER: Core\Maths\src\Maths\Random.cpp]
==================================================
#include "Random.h"
#include "MathConstants.h"

namespace nkentseu {
    namespace math {
        std::mt19937 Random::sGenerator;
        bool Random::sSeeded = false;
        
        void Random::Seed(unsigned int seed) {
            sGenerator.seed(seed);
            sSeeded = true;
        }
        
        bool Random::Bool(float probability) {
            if (!sSeeded) Seed();
            std::bernoulli_distribution dist(probability);
            return dist(sGenerator);
        }
        
        float Random::Value() {
            return Range(0.0f, 1.0f);
        }
        
        float Random::Angle() {
            return Range(0.0f, TWO_PI);
        }
        
        float Random::AngleDegrees() {
            return Range(0.0f, 360.0f);
        }
        
        Vector2 Random::Vector(float minLength, float maxLength) {
            float angle = Angle();
            float length = Range(minLength, maxLength);
            return Vector2(std::cos(angle) * length, std::sin(angle) * length);
        }
        
        Vector2 Random::VectorInCircle(float radius) {
            return Vector(0.0f, radius) * std::sqrt(Value());
        }
        
        Vector2 Random::VectorOnCircle(float radius) {
            float angle = Angle();
            return Vector2(std::cos(angle) * radius, std::sin(angle) * radius);
        }

        // Impl√©mentation simplifi√©e de bruit Perlin
        float Random::Noise(float x, float y, float z) {
            // Impl√©mentation simplifi√©e de bruit value noise
            // Pour une impl√©mentation plus compl√®te, voir: https://github.com/sol-prog/Perlin_Noise
            
            // Utiliser le g√©n√©rateur pour cr√©er un bruit coh√©rent
            static auto hash = [](int n) {
                n = (n << 13) ^ n;
                return (1.0f - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0f);
            };
            
            int xi = static_cast<int>(std::floor(x)) & 255;
            int yi = static_cast<int>(std::floor(y)) & 255;
            int zi = static_cast<int>(std::floor(z)) & 255;
            
            float xf = x - std::floor(x);
            float yf = y - std::floor(y);
            float zf = z - std::floor(z);
            
            float u = Fade(xf);
            float v = Fade(yf);
            float w = Fade(zf);
            
            int a = hash(xi) + yi;
            int aa = hash(a) + zi;
            int ab = hash(a + 1) + zi;
            int b = hash(xi + 1) + yi;
            int ba = hash(b) + zi;
            int bb = hash(b + 1) + zi;
            
            float x1 = Lerp(Grad(hash(aa), xf, yf, zf),
                          Grad(hash(ba), xf - 1, yf, zf), u);
            float x2 = Lerp(Grad(hash(ab), xf, yf - 1, zf),
                          Grad(hash(bb), xf - 1, yf - 1, zf), u);
            float y1 = Lerp(x1, x2, v);
            
            x1 = Lerp(Grad(hash(aa + 1), xf, yf, zf - 1),
                     Grad(hash(ba + 1), xf - 1, yf, zf - 1), u);
            x2 = Lerp(Grad(hash(ab + 1), xf, yf - 1, zf - 1),
                     Grad(hash(bb + 1), xf - 1, yf - 1, zf - 1), u);
            float y2 = Lerp(x1, x2, v);
            
            return (Lerp(y1, y2, w) + 1.0f) / 2.0f;
        }
        
        // Fonctions helper pour le bruit Perlin
        float Random::Fade(float t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        
        float Random::Lerp(float a, float b, float t) {
            return a + t * (b - a);
        }
        
        float Random::Grad(int hash, float x, float y, float z) {
            int h = hash & 15;
            float u = h < 8 ? x : y;
            float v = h < 4 ? y : (h == 12 || h == 14 ? x : z);
            return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
        }
    }
}
==================================================


[FICHIER: Core\Maths\src\Maths\Random.h]
==================================================
#pragma once
#include <random>
#include <type_traits>
#include <stdexcept> // Pour std::out_of_range
#include <algorithm> // Pour std::shuffle
#include "Vector2.h"

namespace nkentseu {
    namespace math {
        class Random {
            private:
                static std::mt19937 sGenerator;
                static bool sSeeded;
                
            public:
                // Initialisation
                static void Seed(unsigned int seed = std::random_device{}());
                
                // M√©thode Range unique avec if constexpr
                template<typename T>
                static T Range(T min, T max) {
                    if (!sSeeded) Seed();
                    
                    if constexpr (std::is_integral_v<T>) {
                        std::uniform_int_distribution<T> dist(min, max);
                        return dist(sGenerator);
                    } else {
                        std::uniform_real_distribution<T> dist(min, max);
                        return dist(sGenerator);
                    }
                }
                
                // Bool√©en
                static bool Bool(float probability = 0.5f);
                
                // Valeur entre 0.0 et 1.0
                static float Value();
                
                // Angle al√©atoire en radians
                static float Angle();
                
                // Angle al√©atoire en degr√©s
                static float AngleDegrees();
                
                // Vecteur al√©atoire
                static Vector2 Vector(float minLength = 0.0f, float maxLength = 1.0f);
                static Vector2 VectorInCircle(float radius = 1.0f);
                static Vector2 VectorOnCircle(float radius = 1.0f);
                
                // S√©lection al√©atoire dans un conteneur
                template<typename Container>
                static auto Choice(const Container& container) -> typename Container::value_type {
                    if (container.empty()) {
                        throw std::out_of_range("Random::Choice: container is empty");
                    }
                    auto it = container.begin();
                    std::advance(it, Range<size_t>(0, container.size() - 1));
                    return *it;
                }
                
                // M√©langer un conteneur
                template<typename Container>
                static void Shuffle(Container& container) {
                    if (!sSeeded) Seed();
                    std::shuffle(container.begin(), container.end(), sGenerator);
                }
                
                // Distribution normale (gaussienne)
                template<typename T>
                static T Gaussian(T mean = 0.0, T stddev = 1.0) {
                    if (!sSeeded) Seed();
                    std::normal_distribution<T> dist(mean, stddev);
                    return dist(sGenerator);
                }
                
                // Fonction de bruit Perlin (impl√©mentation simplifi√©e)
                static float Noise(float x, float y = 0.0f, float z = 0.0f);
                
                // Fonction de mapping
                template<typename T>
                static T Map(T value, T inMin, T inMax, T outMin, T outMax) {
                    return outMin + (outMax - outMin) * ((value - inMin) / (inMax - inMin));
                }
        
                // Fonctions helper pour le bruit Perlin
                static float Fade(float t);
                static float Lerp(float a, float b, float t);
                static float Grad(int hash, float x, float y, float z);
        };
    }
}
==================================================


[FICHIER: Core\Maths\src\Maths\Vector2.cpp]
==================================================
#include "Vector2.h"

namespace nkentseu {
    namespace math {

        // D√©finition des constantes statiques
        const Vector2 Vector2::Zero(0.0f, 0.0f);
        const Vector2 Vector2::One(1.0f, 1.0f);
        const Vector2 Vector2::Up(0.0f, -1.0f);
        const Vector2 Vector2::Down(0.0f, 1.0f);
        const Vector2 Vector2::Left(-1.0f, 0.0f);
        const Vector2 Vector2::Right(1.0f, 0.0f);

    } // namespace math
} // namespace nkentseu
==================================================


[FICHIER: Core\Maths\src\Maths\Vector2.h]
==================================================
#pragma once
#include <cmath>

namespace nkentseu {
    namespace math {

        /**
         * @brief Classe de vecteur 2D pour la gestion des positions, dimensions, etc.
         */
        class Vector2 {
            public:
                // Constructeurs
                Vector2() : x(0.0f), y(0.0f) {}
                Vector2(float value) : x(value), y(value) {}
                Vector2(float x, float y) : x(x), y(y) {}

                // Op√©rateurs arithm√©tiques
                Vector2 operator+(const Vector2& other) const { return Vector2(x + other.x, y + other.y); }
                Vector2 operator-(const Vector2& other) const { return Vector2(x - other.x, y - other.y); }
                Vector2 operator*(const Vector2& other) const { return Vector2(x * other.x, y * other.y); }
                Vector2 operator/(const Vector2& other) const { return Vector2(x / other.x, y / other.y); }

                Vector2 operator*(float scalar) const { return Vector2(x * scalar, y * scalar); }
                Vector2 operator/(float scalar) const { return Vector2(x / scalar, y / scalar); }

                // Op√©rateurs d'affectation
                Vector2& operator+=(const Vector2& other) { x += other.x; y += other.y; return *this; }
                Vector2& operator-=(const Vector2& other) { x -= other.x; y -= other.y; return *this; }
                Vector2& operator*=(const Vector2& other) { x *= other.x; y *= other.y; return *this; }
                Vector2& operator/=(const Vector2& other) { x /= other.x; y /= other.y; return *this; }

                // Op√©rateurs de comparaison
                bool operator==(const Vector2& other) const { return x == other.x && y == other.y; }
                bool operator!=(const Vector2& other) const { return x != other.x || y != other.y; }

                // M√©thodes utilitaires
                float Magnitude() const { return std::sqrt(x * x + y * y); }
                Vector2 Normalized() const { float mag = Magnitude(); return mag > 0.0f ? *this / mag : Zero; }
                float Distance(const Vector2& other) const { return (*this - other).Magnitude(); }
                float Dot(const Vector2& other) const { return x * other.x + y * other.y; }

                // Acc√®s flexible aux donn√©es
                union {
                    struct { float x, y; };
                    struct { float width, height; };
                    struct { float u, v; };
                    float data[2];
                };

                // Constantes statiques
                static const Vector2 Zero;
                static const Vector2 One;
                static const Vector2 Up;
                static const Vector2 Down;
                static const Vector2 Left;
                static const Vector2 Right;
        };

    } // namespace math
} // namespace nkentseu
==================================================


üìÅ DOSSIER: Core\Maths\tests
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Maths\tests\ConstantsTest.cpp]
==================================================
#include <Maths/MathConstants.h>
#include <Unitest/Unitest.h>

TEST_CASE(Math, Constants_PI) {
    // Test des constantes PI
    ASSERT_NEAR(3.14159265f, nkentseu::math::PI, 0.000001f);
    ASSERT_NEAR(6.28318531f, nkentseu::math::TWO_PI, 0.000001f);
    ASSERT_NEAR(1.57079633f, nkentseu::math::HALF_PI, 0.000001f);
    ASSERT_NEAR(0.78539816f, nkentseu::math::Constants::QUARTER_PI, 0.000001f);
}

TEST_CASE(Math, Constants_Conversions) {
    // Test conversions degr√©s/radians
    float radians = 180.0f * nkentseu::math::DEG_TO_RAD;
    ASSERT_NEAR(nkentseu::math::PI, radians, 0.000001f);
    
    float degrees = nkentseu::math::PI * nkentseu::math::RAD_TO_DEG;
    ASSERT_NEAR(180.0f, degrees, 0.000001f);
    
    // Conversions sp√©cifiques
    ASSERT_NEAR(90.0f, nkentseu::math::HALF_PI * nkentseu::math::RAD_TO_DEG, 0.000001f);
    ASSERT_NEAR(45.0f, nkentseu::math::Constants::QUARTER_PI * nkentseu::math::RAD_TO_DEG, 0.000001f);
}

TEST_CASE(Math, Constants_MathConstants) {
    // Test autres constantes math√©matiques
    ASSERT_NEAR(2.71828183f, nkentseu::math::Constants::E, 0.000001f);
    ASSERT_NEAR(1.41421356f, nkentseu::math::Constants::SQRT2, 0.000001f);
    ASSERT_NEAR(1.73205081f, nkentseu::math::Constants::SQRT3, 0.000001f);
    ASSERT_NEAR(1.61803399f, nkentseu::math::Constants::GOLDEN_RATIO, 0.000001f);
}

TEST_CASE(Math, Constants_GlobalAccess) {
    // Test acc√®s global aux constantes
    float pi = nkentseu::math::PI;
    float twoPi = nkentseu::math::TWO_PI;
    float halfPi = nkentseu::math::HALF_PI;
    
    ASSERT_NEAR(3.14159265f, pi, 0.000001f);
    ASSERT_NEAR(6.28318531f, twoPi, 0.000001f);
    ASSERT_NEAR(1.57079633f, halfPi, 0.000001f);
}

TEST_CASE(Math, Constants_UsageInCalculations) {
    // Test utilisation des constantes dans des calculs
    float circleArea = nkentseu::math::PI * 5.0f * 5.0f;
    ASSERT_NEAR(78.53981635f, circleArea, 0.000001f);
    
    float circumference = nkentseu::math::TWO_PI * 5.0f;
    ASSERT_NEAR(31.41592654f, circumference, 0.000001f);
    
    // Conversion d'angle
    float angleDegrees = 45.0f;
    float angleRadians = angleDegrees * nkentseu::math::DEG_TO_RAD;
    ASSERT_NEAR(nkentseu::math::Constants::QUARTER_PI, angleRadians, 0.000001f);
}
==================================================


[FICHIER: Core\Maths\tests\Matrix3x3Test.cpp]
==================================================
#include <Maths/Matrix3x3.h>
#include <Maths/MathConstants.h>
#include <Maths/Vector2.h>
#include <Unitest/Unitest.h>

TEST_CASE(Math, Matrix3x3_DefaultConstructor) {
    nkentseu::math::Matrix3x3 m;
    
    // Matrice par d√©faut devrait √™tre l'identit√©
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            if (i == j) {
                ASSERT_EQUAL(1.0f, m.m[i][j]);
            } else {
                ASSERT_EQUAL(0.0f, m.m[i][j]);
            }
        }
    }
}

TEST_CASE(Math, Matrix3x3_Identity) {
    nkentseu::math::Matrix3x3 identity = nkentseu::math::Matrix3x3::Identity();
    
    ASSERT_EQUAL(1.0f, identity.m[0][0]);
    ASSERT_EQUAL(0.0f, identity.m[0][1]);
    ASSERT_EQUAL(0.0f, identity.m[0][2]);
    
    ASSERT_EQUAL(0.0f, identity.m[1][0]);
    ASSERT_EQUAL(1.0f, identity.m[1][1]);
    ASSERT_EQUAL(0.0f, identity.m[1][2]);
    
    ASSERT_EQUAL(0.0f, identity.m[2][0]);
    ASSERT_EQUAL(0.0f, identity.m[2][1]);
    ASSERT_EQUAL(1.0f, identity.m[2][2]);
}

TEST_CASE(Math, Matrix3x3_Translation) {
    nkentseu::math::Matrix3x3 translation = nkentseu::math::Matrix3x3::Translation(5.0f, 10.0f);
    
    // Matrice de translation
    // [1 0 tx]
    // [0 1 ty]
    // [0 0 1]
    ASSERT_EQUAL(1.0f, translation.m[0][0]);
    ASSERT_EQUAL(0.0f, translation.m[0][1]);
    ASSERT_EQUAL(5.0f, translation.m[0][2]);
    
    ASSERT_EQUAL(0.0f, translation.m[1][0]);
    ASSERT_EQUAL(1.0f, translation.m[1][1]);
    ASSERT_EQUAL(10.0f, translation.m[1][2]);
    
    ASSERT_EQUAL(0.0f, translation.m[2][0]);
    ASSERT_EQUAL(0.0f, translation.m[2][1]);
    ASSERT_EQUAL(1.0f, translation.m[2][2]);
}

TEST_CASE(Math, Matrix3x3_Rotation) {
    // Rotation de 90 degr√©s (œÄ/2 radians)
    nkentseu::math::Matrix3x3 rotation = nkentseu::math::Matrix3x3::Rotation(nkentseu::math::HALF_PI);
    
    // Matrice de rotation 2D
    // [cosŒ∏ -sinŒ∏ 0]
    // [sinŒ∏  cosŒ∏ 0]
    // [0    0    1]
    ASSERT_NEAR(0.0f, rotation.m[0][0], 0.0001f);  // cos(œÄ/2) ‚âà 0
    ASSERT_NEAR(-1.0f, rotation.m[0][1], 0.0001f); // -sin(œÄ/2) = -1
    ASSERT_EQUAL(0.0f, rotation.m[0][2]);
    
    ASSERT_NEAR(1.0f, rotation.m[1][0], 0.0001f);  // sin(œÄ/2) = 1
    ASSERT_NEAR(0.0f, rotation.m[1][1], 0.0001f);  // cos(œÄ/2) ‚âà 0
    ASSERT_EQUAL(0.0f, rotation.m[1][2]);
    
    ASSERT_EQUAL(0.0f, rotation.m[2][0]);
    ASSERT_EQUAL(0.0f, rotation.m[2][1]);
    ASSERT_EQUAL(1.0f, rotation.m[2][2]);
    
    // Rotation de 180 degr√©s
    rotation = nkentseu::math::Matrix3x3::Rotation(nkentseu::math::PI);
    ASSERT_NEAR(-1.0f, rotation.m[0][0], 0.0001f);  // cos(œÄ) = -1
    ASSERT_NEAR(0.0f, rotation.m[0][1], 0.0001f);   // -sin(œÄ) = 0
    ASSERT_NEAR(0.0f, rotation.m[1][0], 0.0001f);   // sin(œÄ) = 0
    ASSERT_NEAR(-1.0f, rotation.m[1][1], 0.0001f);  // cos(œÄ) = -1
}

TEST_CASE(Math, Matrix3x3_Scaling) {
    nkentseu::math::Matrix3x3 scaling = nkentseu::math::Matrix3x3::Scaling(2.0f, 3.0f);
    
    // Matrice d'√©chelle
    // [sx 0  0]
    // [0  sy 0]
    // [0  0  1]
    ASSERT_EQUAL(2.0f, scaling.m[0][0]);
    ASSERT_EQUAL(0.0f, scaling.m[0][1]);
    ASSERT_EQUAL(0.0f, scaling.m[0][2]);
    
    ASSERT_EQUAL(0.0f, scaling.m[1][0]);
    ASSERT_EQUAL(3.0f, scaling.m[1][1]);
    ASSERT_EQUAL(0.0f, scaling.m[1][2]);
    
    ASSERT_EQUAL(0.0f, scaling.m[2][0]);
    ASSERT_EQUAL(0.0f, scaling.m[2][1]);
    ASSERT_EQUAL(1.0f, scaling.m[2][2]);
}

TEST_CASE(Math, Matrix3x3_Multiplication) {
    nkentseu::math::Matrix3x3 a;
    nkentseu::math::Matrix3x3 b;
    
    // Initialiser avec des valeurs testables
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            a.m[i][j] = static_cast<float>(i * 3 + j + 1); // 1-9
            b.m[i][j] = static_cast<float>(9 - (i * 3 + j)); // 9-1
        }
    }
    
    nkentseu::math::Matrix3x3 c = a * b;
    
    // Calcul manuel de la premi√®re cellule
    // c[0][0] = a[0][0]*b[0][0] + a[0][1]*b[1][0] + a[0][2]*b[2][0]
    //         = 1*9 + 2*6 + 3*3 = 9 + 12 + 9 = 30
    ASSERT_EQUAL(30.0f, c.m[0][0]);
    
    // c[0][1] = a[0][0]*b[0][1] + a[0][1]*b[1][1] + a[0][2]*b[2][1]
    //         = 1*8 + 2*5 + 3*2 = 8 + 10 + 6 = 24
    ASSERT_EQUAL(24.0f, c.m[0][1]);
}

TEST_CASE(Math, Matrix3x3_TransformPoint) {
    nkentseu::math::Matrix3x3 translation = nkentseu::math::Matrix3x3::Translation(5.0f, 10.0f);
    nkentseu::math::Vector2 point(2.0f, 3.0f);
    
    nkentseu::math::Vector2 transformed = translation.TransformPoint(point);
    
    // Point translat√©
    ASSERT_EQUAL(7.0f, transformed.x);  // 2 + 5
    ASSERT_EQUAL(13.0f, transformed.y); // 3 + 10
    
    // Test avec matrice d'identit√©
    nkentseu::math::Matrix3x3 identity = nkentseu::math::Matrix3x3::Identity();
    transformed = identity.TransformPoint(point);
    ASSERT_EQUAL(2.0f, transformed.x);
    ASSERT_EQUAL(3.0f, transformed.y);
}

TEST_CASE(Math, Matrix3x3_TransformVector) {
    nkentseu::math::Matrix3x3 scaling = nkentseu::math::Matrix3x3::Scaling(2.0f, 3.0f);
    nkentseu::math::Vector2 vector(1.0f, 1.0f);
    
    nkentseu::math::Vector2 transformed = scaling.TransformVector(vector);
    
    // Vecteur mis √† l'√©chelle (la translation ne s'applique pas aux vecteurs)
    ASSERT_EQUAL(2.0f, transformed.x); // 1 * 2
    ASSERT_EQUAL(3.0f, transformed.y); // 1 * 3
    
    // Rotation d'un vecteur
    nkentseu::math::Matrix3x3 rotation = nkentseu::math::Matrix3x3::Rotation(nkentseu::math::PI);
    vector = nkentseu::math::Vector2(1.0f, 0.0f);
    transformed = rotation.TransformVector(vector);
    
    ASSERT_NEAR(-1.0f, transformed.x, 0.0001f); // cos(œÄ) = -1
    ASSERT_NEAR(0.0f, transformed.y, 0.0001f);  // sin(œÄ) = 0
}

TEST_CASE(Math, Matrix3x3_Determinant) {
    // D√©terminant d'une matrice identit√© = 1
    nkentseu::math::Matrix3x3 identity = nkentseu::math::Matrix3x3::Identity();
    ASSERT_EQUAL(1.0f, identity.Determinant());
    
    // Matrice simple
    nkentseu::math::Matrix3x3 m;
    m.m[0][0] = 1; m.m[0][1] = 2; m.m[0][2] = 3;
    m.m[1][0] = 4; m.m[1][1] = 5; m.m[1][2] = 6;
    m.m[2][0] = 7; m.m[2][1] = 8; m.m[2][2] = 9;
    
    // det = 1*(5*9 - 6*8) - 2*(4*9 - 6*7) + 3*(4*8 - 5*7)
    //     = 1*(45-48) - 2*(36-42) + 3*(32-35)
    //     = 1*(-3) - 2*(-6) + 3*(-3)
    //     = -3 + 12 - 9 = 0
    ASSERT_EQUAL(0.0f, m.Determinant());
    
    // Matrice avec d√©terminant non nul
    m.m[2][2] = 10;
    // det = 1*(5*10 - 6*8) - 2*(4*10 - 6*7) + 3*(4*8 - 5*7)
    //     = 1*(50-48) - 2*(40-42) + 3*(32-35)
    //     = 1*(2) - 2*(-2) + 3*(-3)
    //     = 2 + 4 - 9 = -3
    ASSERT_EQUAL(-3.0f, m.Determinant());
}

TEST_CASE(Math, Matrix3x3_Transpose) {
    nkentseu::math::Matrix3x3 m;
    m.m[0][0] = 1; m.m[0][1] = 2; m.m[0][2] = 3;
    m.m[1][0] = 4; m.m[1][1] = 5; m.m[1][2] = 6;
    m.m[2][0] = 7; m.m[2][1] = 8; m.m[2][2] = 9;
    
    nkentseu::math::Matrix3x3 transposed = m.Transpose();
    
    ASSERT_EQUAL(1.0f, transposed.m[0][0]);
    ASSERT_EQUAL(4.0f, transposed.m[0][1]);
    ASSERT_EQUAL(7.0f, transposed.m[0][2]);
    
    ASSERT_EQUAL(2.0f, transposed.m[1][0]);
    ASSERT_EQUAL(5.0f, transposed.m[1][1]);
    ASSERT_EQUAL(8.0f, transposed.m[1][2]);
    
    ASSERT_EQUAL(3.0f, transposed.m[2][0]);
    ASSERT_EQUAL(6.0f, transposed.m[2][1]);
    ASSERT_EQUAL(9.0f, transposed.m[2][2]);
    
    // Transposer deux fois donne la matrice originale
    ASSERT_TRUE(m == transposed.Transpose());
}

TEST_CASE(Math, Matrix3x3_Inverse) {
    // Matrice identit√© est son propre inverse
    nkentseu::math::Matrix3x3 identity = nkentseu::math::Matrix3x3::Identity();
    nkentseu::math::Matrix3x3 inverse = identity.Inverse();
    
    ASSERT_TRUE(identity == inverse);
    
    // Test avec une matrice simple inversible
    nkentseu::math::Matrix3x3 m = nkentseu::math::Matrix3x3::Scaling(2.0f, 3.0f);
    inverse = m.Inverse();
    
    // Inverse d'une matrice d'√©chelle est l'√©chelle inverse
    nkentseu::math::Matrix3x3 expectedInverse = nkentseu::math::Matrix3x3::Scaling(0.5f, 1.0f/3.0f);
    
    ASSERT_NEAR(expectedInverse.m[0][0], inverse.m[0][0], 0.0001f);
    ASSERT_NEAR(expectedInverse.m[1][1], inverse.m[1][1], 0.0001f);
    
    // V√©rifier que m * inverse = identit√©
    nkentseu::math::Matrix3x3 product = m * inverse;
    
    ASSERT_NEAR(1.0f, product.m[0][0], 0.0001f);
    ASSERT_NEAR(0.0f, product.m[0][1], 0.0001f);
    ASSERT_NEAR(0.0f, product.m[1][0], 0.0001f);
    ASSERT_NEAR(1.0f, product.m[1][1], 0.0001f);
}
==================================================


[FICHIER: Core\Maths\tests\RandomTest.cpp]
==================================================
#include <Maths/Random.h>
#include <Maths/MathConstants.h>
// #include <Maths/Vector2.h>
#include <Unitest/Unitest.h>
#include <vector>
#include <array>
#include <set>

TEST_CASE(Math, Random_Seed) {
    nkentseu::math::Random::Seed(42);
    
    // Test que le seed fonctionne (m√™me seed donne m√™mes r√©sultats)
    float firstValue = nkentseu::math::Random::Value();
    
    nkentseu::math::Random::Seed(42);
    float secondValue = nkentseu::math::Random::Value();
    
    ASSERT_EQUAL(firstValue, secondValue);
}

TEST_CASE(Math, Random_RangeInt) {
    // Test avec entier
    int value = nkentseu::math::Random::Range(1, 10);
    
    ASSERT_GREATER_EQUAL(value, 1);
    ASSERT_LESS_EQUAL(value, 10);
    
    // Test plusieurs fois pour s'assurer de la distribution
    for (int i = 0; i < 100; ++i) {
        value = nkentseu::math::Random::Range(1, 10);
        ASSERT_TRUE(value >= 1 && value <= 10);
    }
}

TEST_CASE(Math, Random_RangeFloat) {
    // Test avec float
    float value = nkentseu::math::Random::Range(0.0f, 1.0f);
    
    ASSERT_GREATER_EQUAL(value, 0.0f);
    ASSERT_LESS_EQUAL(value, 1.0f);
    
    // Test avec limites n√©gatives
    value = nkentseu::math::Random::Range(-10.0f, 10.0f);
    ASSERT_TRUE(value >= -10.0f && value <= 10.0f);
}

TEST_CASE(Math, Random_Bool) {
    // Test avec probabilit√© par d√©faut
    bool value = nkentseu::math::Random::Bool();
    // Pas d'assertion sp√©cifique car r√©sultat al√©atoire
    
    // Test avec probabilit√© 0.0
    value = nkentseu::math::Random::Bool(0.0f);
    ASSERT_FALSE(value);
    
    // Test avec probabilit√© 1.0
    value = nkentseu::math::Random::Bool(1.0f);
    ASSERT_TRUE(value);
}

TEST_CASE(Math, Random_Value) {
    float value = nkentseu::math::Random::Value();
    
    ASSERT_GREATER_EQUAL(value, 0.0f);
    ASSERT_LESS_EQUAL(value, 1.0f);
    
    // Test plusieurs valeurs
    for (int i = 0; i < 10; ++i) {
        value = nkentseu::math::Random::Value();
        ASSERT_TRUE(value >= 0.0f && value <= 1.0f);
    }
}

TEST_CASE(Math, Random_Angle) {
    float angle = nkentseu::math::Random::Angle();
    
    ASSERT_GREATER_EQUAL(angle, 0.0f);
    ASSERT_LESS(angle, nkentseu::math::TWO_PI);
    
    // Conversion en degr√©s
    float degrees = angle * nkentseu::math::RAD_TO_DEG;
    ASSERT_TRUE(degrees >= 0.0f && degrees < 360.0f);
}

TEST_CASE(Math, Random_AngleDegrees) {
    float degrees = nkentseu::math::Random::AngleDegrees();
    
    ASSERT_GREATER_EQUAL(degrees, 0.0f);
    ASSERT_LESS(degrees, 360.0f);
    
    // Conversion en radians
    float radians = degrees * nkentseu::math::DEG_TO_RAD;
    ASSERT_TRUE(radians >= 0.0f && radians < nkentseu::math::TWO_PI);
}

TEST_CASE(Math, Random_Vector) {
    nkentseu::math::Vector2 v = nkentseu::math::Random::Vector();
    
    // Magnitude entre 0 et 1
    float mag = v.Magnitude();
    ASSERT_GREATER_EQUAL(mag, 0.0f);
    ASSERT_LESS_EQUAL(mag, 1.0f);
    
    // Test avec longueurs sp√©cifiques
    v = nkentseu::math::Random::Vector(5.0f, 10.0f);
    mag = v.Magnitude();
    ASSERT_TRUE(mag >= 5.0f && mag <= 10.0f);
}

TEST_CASE(Math, Random_VectorInCircle) {
    nkentseu::math::Vector2 v = nkentseu::math::Random::VectorInCircle(5.0f);
    
    float distance = v.Magnitude();
    ASSERT_LESS_EQUAL(distance, 5.0f);
    
    // Test plusieurs points
    for (int i = 0; i < 100; ++i) {
        v = nkentseu::math::Random::VectorInCircle(1.0f);
        ASSERT_LESS_EQUAL(v.Magnitude(), 1.0f);
    }
}

TEST_CASE(Math, Random_VectorOnCircle) {
    nkentseu::math::Vector2 v = nkentseu::math::Random::VectorOnCircle(5.0f);
    
    float distance = v.Magnitude();
    ASSERT_NEAR(5.0f, distance, 0.0001f);
    
    // Test plusieurs points
    for (int i = 0; i < 100; ++i) {
        v = nkentseu::math::Random::VectorOnCircle(1.0f);
        ASSERT_NEAR(1.0f, v.Magnitude(), 0.0001f);
    }
}

TEST_CASE(Math, Random_Choice) {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    for (int i = 0; i < 20; ++i) {
        int choice = nkentseu::math::Random::Choice(numbers);
        ASSERT_CONTAINS(numbers, choice);
    }
    
    // Test avec conteneur vide
    std::vector<int> empty;
    ASSERT_THROWS(std::out_of_range, nkentseu::math::Random::Choice(empty));
}

TEST_CASE(Math, Random_Shuffle) {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    std::vector<int> original = numbers;
    
    nkentseu::math::Random::Shuffle(numbers);
    
    // V√©rifier que tous les √©l√©ments sont pr√©sents
    for (int num : original) {
        ASSERT_CONTAINS(numbers, num);
    }
    
    // V√©rifier que l'ordre est potentiellement diff√©rent
    bool sameOrder = true;
    for (size_t i = 0; i < numbers.size(); ++i) {
        if (numbers[i] != original[i]) {
            sameOrder = false;
            break;
        }
    }
    
    // Il est possible mais peu probable que shuffle donne le m√™me ordre
    if (sameOrder) {
        // Essayer une deuxi√®me fois
        nkentseu::math::Random::Shuffle(numbers);
        sameOrder = true;
        for (size_t i = 0; i < numbers.size(); ++i) {
            if (numbers[i] != original[i]) {
                sameOrder = false;
                break;
            }
        }
        // Si toujours le m√™me ordre apr√®s deux shuffles, c'est suspect
        ASSERT_FALSE(sameOrder);
    }
}

TEST_CASE(Math, Random_Gaussian) {
    // Test distribution normale
    float value = nkentseu::math::Random::Gaussian(0.0f, 1.0f);
    
    // La plupart des valeurs devraient √™tre entre -3 et 3
    for (int i = 0; i < 100; ++i) {
        value = nkentseu::math::Random::Gaussian(10.0f, 2.0f);
        // 99.7% des valeurs devraient √™tre entre 4 et 16 (moyenne ¬± 3*√©cart-type)
        if (value < 4.0f || value > 16.0f) {
            // Si on obtient une valeur hors de cet intervalle, c'est normal
            // mais on pourrait logger un warning
            break;
        }
    }
}

TEST_CASE(Math, Random_Map) {
    // Mapping lin√©aire
    float mapped = nkentseu::math::Random::Map(0.5f, 0.0f, 1.0f, 0.0f, 100.0f);
    ASSERT_EQUAL(50.0f, mapped);
    
    mapped = nkentseu::math::Random::Map(0.0f, 0.0f, 1.0f, 10.0f, 20.0f);
    ASSERT_EQUAL(10.0f, mapped);
    
    mapped = nkentseu::math::Random::Map(1.0f, 0.0f, 1.0f, 10.0f, 20.0f);
    ASSERT_EQUAL(20.0f, mapped);
    
    // Mapping avec valeurs n√©gatives
    mapped = nkentseu::math::Random::Map(0.5f, -1.0f, 1.0f, 0.0f, 100.0f);
    ASSERT_EQUAL(75.0f, mapped);
}
==================================================


[FICHIER: Core\Maths\tests\Vector2Test.cpp]
==================================================
#include <Maths/Vector2.h>
#include <Unitest/Unitest.h>

TEST_CASE(Math, Vector2_DefaultConstructor) {
    nkentseu::math::Vector2 v;
    ASSERT_EQUAL(0.0f, v.x);
    ASSERT_EQUAL(0.0f, v.y);
}

TEST_CASE(Math, Vector2_ValueConstructor) {
    nkentseu::math::Vector2 v(5.0f);
    ASSERT_EQUAL(5.0f, v.x);
    ASSERT_EQUAL(5.0f, v.y);
}

TEST_CASE(Math, Vector2_XYConstructor) {
    nkentseu::math::Vector2 v(3.0f, 4.0f);
    ASSERT_EQUAL(3.0f, v.x);
    ASSERT_EQUAL(4.0f, v.y);
}

TEST_CASE(Math, Vector2_Addition) {
    nkentseu::math::Vector2 v1(1.0f, 2.0f);
    nkentseu::math::Vector2 v2(3.0f, 4.0f);
    nkentseu::math::Vector2 result = v1 + v2;
    
    ASSERT_EQUAL(4.0f, result.x);
    ASSERT_EQUAL(6.0f, result.y);
}

TEST_CASE(Math, Vector2_Subtraction) {
    nkentseu::math::Vector2 v1(5.0f, 5.0f);
    nkentseu::math::Vector2 v2(2.0f, 3.0f);
    nkentseu::math::Vector2 result = v1 - v2;
    
    ASSERT_EQUAL(3.0f, result.x);
    ASSERT_EQUAL(2.0f, result.y);
}

TEST_CASE(Math, Vector2_Multiplication) {
    nkentseu::math::Vector2 v(2.0f, 3.0f);
    nkentseu::math::Vector2 result = v * 2.0f;
    
    ASSERT_EQUAL(4.0f, result.x);
    ASSERT_EQUAL(6.0f, result.y);
}

TEST_CASE(Math, Vector2_Division) {
    nkentseu::math::Vector2 v(6.0f, 8.0f);
    nkentseu::math::Vector2 result = v / 2.0f;
    
    ASSERT_EQUAL(3.0f, result.x);
    ASSERT_EQUAL(4.0f, result.y);
}

TEST_CASE(Math, Vector2_CompoundAssignment) {
    nkentseu::math::Vector2 v(1.0f, 2.0f);
    v += nkentseu::math::Vector2(3.0f, 4.0f);
    
    ASSERT_EQUAL(4.0f, v.x);
    ASSERT_EQUAL(6.0f, v.y);
}

TEST_CASE(Math, Vector2_Comparison) {
    nkentseu::math::Vector2 v1(1.0f, 2.0f);
    nkentseu::math::Vector2 v2(1.0f, 2.0f);
    nkentseu::math::Vector2 v3(3.0f, 4.0f);
    
    ASSERT_TRUE(v1 == v2);
    ASSERT_TRUE(v1 != v3);
    ASSERT_FALSE(v1 == v3);
    ASSERT_FALSE(v1 != v2);
}

TEST_CASE(Math, Vector2_Magnitude) {
    nkentseu::math::Vector2 v(3.0f, 4.0f);
    float magnitude = v.Magnitude();
    
    ASSERT_EQUAL(5.0f, magnitude);
    
    nkentseu::math::Vector2 zero;
    ASSERT_EQUAL(0.0f, zero.Magnitude());
}

TEST_CASE(Math, Vector2_Normalized) {
    nkentseu::math::Vector2 v(3.0f, 4.0f);
    nkentseu::math::Vector2 normalized = v.Normalized();
    
    ASSERT_NEAR(1.0f, normalized.Magnitude(), 0.0001f);
    ASSERT_NEAR(0.6f, normalized.x, 0.0001f);
    ASSERT_NEAR(0.8f, normalized.y, 0.0001f);
}

TEST_CASE(Math, Vector2_Distance) {
    nkentseu::math::Vector2 v1(0.0f, 0.0f);
    nkentseu::math::Vector2 v2(3.0f, 4.0f);
    float distance = v1.Distance(v2);
    
    ASSERT_EQUAL(5.0f, distance);
    
    // Distance entre deux points identiques
    ASSERT_EQUAL(0.0f, v1.Distance(v1));
}

TEST_CASE(Math, Vector2_DotProduct) {
    nkentseu::math::Vector2 v1(1.0f, 2.0f);
    nkentseu::math::Vector2 v2(3.0f, 4.0f);
    float dot = v1.Dot(v2);
    
    ASSERT_EQUAL(11.0f, dot); // 1*3 + 2*4 = 3 + 8 = 11
    
    // Vecteurs orthogonaux
    nkentseu::math::Vector2 up(0.0f, 1.0f);
    nkentseu::math::Vector2 right(1.0f, 0.0f);
    ASSERT_EQUAL(0.0f, up.Dot(right));
}

TEST_CASE(Math, Vector2_Accessors) {
    nkentseu::math::Vector2 v(10.0f, 20.0f);
    
    // Test des diff√©rents accesseurs
    ASSERT_EQUAL(10.0f, v.width);
    ASSERT_EQUAL(20.0f, v.height);
    
    ASSERT_EQUAL(10.0f, v.u);
    ASSERT_EQUAL(20.0f, v.v);
    
    ASSERT_EQUAL(10.0f, v.data[0]);
    ASSERT_EQUAL(20.0f, v.data[1]);
    
    // Modification via union
    v.width = 30.0f;
    v.height = 40.0f;
    
    ASSERT_EQUAL(30.0f, v.x);
    ASSERT_EQUAL(40.0f, v.y);
}

TEST_CASE(Math, Vector2_StaticConstants) {
    // Test des constantes statiques
    ASSERT_EQUAL(0.0f, nkentseu::math::Vector2::Zero.x);
    ASSERT_EQUAL(0.0f, nkentseu::math::Vector2::Zero.y);
    
    ASSERT_EQUAL(1.0f, nkentseu::math::Vector2::One.x);
    ASSERT_EQUAL(1.0f, nkentseu::math::Vector2::One.y);
    
    ASSERT_EQUAL(0.0f, nkentseu::math::Vector2::Up.x);
    ASSERT_EQUAL(1.0f, nkentseu::math::Vector2::Up.y);
    
    ASSERT_EQUAL(0.0f, nkentseu::math::Vector2::Down.x);
    ASSERT_EQUAL(-1.0f, nkentseu::math::Vector2::Down.y);
    
    ASSERT_EQUAL(-1.0f, nkentseu::math::Vector2::Left.x);
    ASSERT_EQUAL(0.0f, nkentseu::math::Vector2::Left.y);
    
    ASSERT_EQUAL(1.0f, nkentseu::math::Vector2::Right.x);
    ASSERT_EQUAL(0.0f, nkentseu::math::Vector2::Right.y);
}
==================================================


üìÅ DOSSIER: Core\Nkentseu
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Nkentseu\Nkentseu.jenga]
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# -----------------------------------------------------------------------------
# FICHIER: Core/Nkentseu/Nkentseu.jenga
# DESCRIPTION: Configuration du projet Nkentseu (biblioth√®que statique de principal).
# AUTEUR: Rihen
# DATE: 2026
# -----------------------------------------------------------------------------

from Jenga.core.api import *

with project("Nkentseu"):
    # Type de projet: biblioth√®que statique staticlib sharedlib consoleapp windowapp
    staticlib()
    
    # Langage et version C++
    language("C++")
    cppdialect("C++17")
    
    # Fichiers sources globaux
    files([
        "src/**.cpp",
    ])
    
    # R√©pertoires d'inclusion publics
    includedirs([
        "src"
    ])
    
    # Configuration sp√©cifique √† Windows
    with filter("system:Windows"):
        links(["gdi32", "user32"])
        addldflag("-lgdi32")
        addldflag("-luser32")
    
    # Configuration sp√©cifique √† Linux
    with filter("system:Linux"):
        links(["xcb"])
    
    # Configuration sp√©cifique √† Android
    with filter("system:Android"):
        links(["android", "log"])
    
    # Configuration sp√©cifique √† Emscripten
    with filter("system:Emscripten"):
        pass
    
    # Configuration des r√©pertoires de sortie
    targetdir("%{wks.location}/Build/Lib/%{cfg.buildcfg}")
    objdir("%{wks.location}/Build/Obj/%{cfg.buildcfg}/%{prj.name}")
    
    # Configuration Debug
    with filter("configurations:Debug"):
        defines(["DEBUG", "_DEBUG"])
        optimize("Off")
        symbols("On")
    
    # Configuration Release
    with filter("configurations:Release"):
        defines(["NDEBUG", "RELEASE"])
        optimize("Speed")
        symbols("Off")
==================================================


üìÅ DOSSIER: Core\Nkentseu\src\Nkentseu
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Nkentseu\src\Nkentseu\Sleep.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Core/Sleep.cpp
// DESCRIPTION: Impl√©mentation multiplateforme des fonctions de mise en veille.
//              Supporte Windows, Linux, Android, macOS et Emscripten.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Nkentseu/Sleep.h"
#include "Nkentseu/Config/Platform.h"

// -----------------------------------------------------------------------------
// INCLUDES SP√âCIFIQUES √Ä LA PLATEFORME
// -----------------------------------------------------------------------------

#if defined(NK_PLATFORM_WINDOWS)
    #define WIN32_LEAN_AND_MEAN
    #include <Windows.h>
    
#elif defined(NK_PLATFORM_DESKTOP) || defined(NK_PLATFORM_ANDROID)
    #include <time.h>
    #include <errno.h>
    
#elif defined(NK_PLATFORM_EMSCRIPTEN)
    #include <emscripten.h>
#endif

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // FONCTION: SleepNano
    // DESCRIPTION: Met le thread en veille avec pr√©cision nanoseconde
    // -------------------------------------------------------------------------
    void SleepNano(uint64 nanoseconds) {
        if (nanoseconds == 0) return;

        // ---------------------------------------------------------------------
        // IMPL√âMENTATION WINDOWS (QueryPerformanceCounter)
        // ---------------------------------------------------------------------
        #if defined(NK_PLATFORM_WINDOWS)
            LARGE_INTEGER freq, start, end;
            QueryPerformanceFrequency(&freq);
            QueryPerformanceCounter(&start);
            
            uint64 target = start.QuadPart + (nanoseconds * freq.QuadPart) / 1000000000ULL;
            
            // Pour les d√©lais > 2ms, utiliser Sleep() pour √©conomiser le CPU
            if (nanoseconds > 2000000) {
                ::Sleep(static_cast<DWORD>(nanoseconds / 1000000) - 1);
            }
            
            // Boucle d'attente active pour la pr√©cision
            do {
                QueryPerformanceCounter(&end);
            } while (end.QuadPart < target);

        // ---------------------------------------------------------------------
        // IMPL√âMENTATION POSIX (Linux, macOS, Android)
        // ---------------------------------------------------------------------
        #elif defined(NK_PLATFORM_DESKTOP) || defined(NK_PLATFORM_ANDROID)
            struct timespec req, rem;
            req.tv_sec = nanoseconds / 1000000000ULL;
            req.tv_nsec = nanoseconds % 1000000000ULL;
            
            // Gestion des interruptions (EINTR)
            while (nanosleep(&req, &rem) == -1 && errno == EINTR) {
                req = rem;
            }

        // ---------------------------------------------------------------------
        // IMPL√âMENTATION EMSCRIPTEN (WebAssembly)
        // ---------------------------------------------------------------------
        #elif defined(NK_PLATFORM_EMSCRIPTEN)
            emscripten_sleep(nanoseconds / 1000000);
        #endif
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Nkentseu\src\Nkentseu\Sleep.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Core/Sleep.h
// DESCRIPTION: Fonctions de mise en veille (sleep) multiplateforme avec
//              diff√©rentes unit√©s de temps (nanosecondes, microsecondes, etc.)
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Nkentseu/Config/Export.h"
#include "Types.h"

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    /**
     * @brief Met le thread en veille pour une dur√©e sp√©cifi√©e en nanosecondes
     * @param nanoseconds Dur√©e en nanosecondes
     */
    NK_API void SleepNano(uint64 nanoseconds);

    /**
     * @brief Met le thread en veille pour une dur√©e sp√©cifi√©e en microsecondes
     * @param microseconds Dur√©e en microsecondes
     */
    inline void SleepMicro(uint64 microseconds) {
        SleepNano(microseconds * 1000);
    }

    /**
     * @brief Met le thread en veille pour une dur√©e sp√©cifi√©e en millisecondes
     * @param milliseconds Dur√©e en millisecondes
     */
    inline void SleepMilli(uint64 milliseconds) {
        SleepNano(milliseconds * 1000000);
    }

    /**
     * @brief Met le thread en veille pour une dur√©e sp√©cifi√©e en secondes
     * @param seconds Dur√©e en secondes
     */
    inline void Sleep(uint64 seconds) {
        SleepNano(seconds * 1000000000);
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Nkentseu\src\Nkentseu\Types.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Core/Types.h
// DESCRIPTION: D√©finition des types de base du framework avec des alias
//              standardis√©s pour une portabilit√© optimale.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include <cstdint>
#include <cstddef>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // TYPES ENTIERS SIGN√âS
    // -------------------------------------------------------------------------
    
    /// Type entier 8-bit sign√©
    using int8   = std::int8_t;
    
    /// Type entier 16-bit sign√©
    using int16  = std::int16_t;
    
    /// Type entier 32-bit sign√©
    using int32  = std::int32_t;
    
    /// Type entier 64-bit sign√©
    using int64  = std::int64_t;

    // -------------------------------------------------------------------------
    // TYPES ENTIERS NON SIGN√âS
    // -------------------------------------------------------------------------
    
    /// Type entier 8-bit non sign√©
    using uint8  = std::uint8_t;
    
    /// Type entier 16-bit non sign√©
    using uint16 = std::uint16_t;
    
    /// Type entier 32-bit non sign√©
    using uint32 = std::uint32_t;
    
    /// Type entier 64-bit non sign√©
    using uint64 = std::uint64_t;

    // -------------------------------------------------------------------------
    // TYPES FLOTTANTS
    // -------------------------------------------------------------------------
    
    /// Type flottant 32-bit (simple pr√©cision)
    using float32 = float;
    
    /// Type flottant 64-bit (double pr√©cision)
    using float64 = double;

} // namespace nkentseu
==================================================


üìÅ DOSSIER: Core\Nkentseu\src\Nkentseu\Config
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Nkentseu\src\Nkentseu\Config\Architecture.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Config/Architecture.h
// DESCRIPTION: D√©tection de l'architecture processeur. D√©finit les macros
//              d'identification d'architecture (x86, x64, ARM, WASM).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

// -----------------------------------------------------------------------------
// MACROS DE D√âTECTION D'ARCHITECTURE
// -----------------------------------------------------------------------------

// Architecture x64 (64-bit)
#if defined(__x86_64__) || defined(_M_X64)
    #define NK_ARCH_X64 1
    #define NK_ARCH_64BIT 1

// Architecture x86 (32-bit)
#elif defined(__i386__) || defined(_M_IX86)
    #define NK_ARCH_X86 1
    #define NK_ARCH_32BIT 1
#endif

// Architecture ARM64 (64-bit)
#if defined(__aarch64__) || defined(_M_ARM64)
    #define NK_ARCH_ARM64 1
    #define NK_ARCH_64BIT 1

// Architecture ARM (32-bit)
#elif defined(__arm__) || defined(_M_ARM)
    #define NK_ARCH_ARM 1
    #define NK_ARCH_32BIT 1
#endif

// Architecture WebAssembly (WASM)
#if defined(__wasm__)
    #define NK_ARCH_WASM 1
#endif

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// DESCRIPTION: Espace de noms principal du framework
// -----------------------------------------------------------------------------
namespace nkentseu {

    /**
     * @brief Obtient le nom de l'architecture courante
     * @return Cha√Æne de caract√®res d√©crivant l'architecture
     */
    inline const char* GetArchitectureName() {
        #if defined(NK_ARCH_X64)
            return "x86_64";
        #elif defined(NK_ARCH_X86)
            return "x86";
        #elif defined(NK_ARCH_ARM64)
            return "ARM64";
        #elif defined(NK_ARCH_ARM)
            return "ARM";
        #elif defined(NK_ARCH_WASM)
            return "WebAssembly";
        #else
            return "Unknown";
        #endif
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Nkentseu\src\Nkentseu\Config\Compiler.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Config/Compiler.h
// DESCRIPTION: D√©tection du compilateur. D√©finit les macros d'identification
//              de compilateur (MSVC, GCC, Clang, Emscripten).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

// -----------------------------------------------------------------------------
// MACROS DE D√âTECTION DE COMPILATEUR
// -----------------------------------------------------------------------------

// Compilateur Microsoft Visual C++
#if defined(_MSC_VER)
    #define NK_COMPILER_MSVC 1
#endif

// Compilateur GCC (non Clang)
#if defined(__GNUC__) && !defined(__clang__)
    #define NK_COMPILER_GCC 1
#endif

// Compilateur Clang
#if defined(__clang__)
    #define NK_COMPILER_CLANG 1
#endif

// Compilateur Emscripten
#if defined(__EMSCRIPTEN__)
    #define NK_COMPILER_EMSCRIPTEN 1
#endif

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    /**
     * @brief Obtient le nom du compilateur courant
     * @return Cha√Æne de caract√®res d√©crivant le compilateur
     */
    inline const char* GetCompilerName() {
        #if defined(NK_COMPILER_MSVC)
            return "MSVC";
        #elif defined(NK_COMPILER_CLANG)
            return "Clang";
        #elif defined(NK_COMPILER_GCC)
            return "GCC";
        #elif defined(NK_COMPILER_EMSCRIPTEN)
            return "Emscripten";
        #else
            return "Unknown";
        #endif
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Nkentseu\src\Nkentseu\Config\Export.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Config/Export.h
// DESCRIPTION: Configuration d'exportation de symboles (DLL/Shared Library).
//              D√©finit les macros pour l'export/import et l'inlining.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Platform.h"
#include "Compiler.h"

// -----------------------------------------------------------------------------
// MACROS D'EXPORTATION/IMPORTATION (DLL/SHARED LIBRARY)
// -----------------------------------------------------------------------------

#if defined(NK_PLATFORM_WINDOWS)
    #if defined(NK_BUILD_SHARED)
        #define NK_API __declspec(dllexport)
    #elif defined(NK_USE_SHARED)
        #define NK_API __declspec(dllimport)
    #else
        #define NK_API
    #endif

#elif defined(NK_COMPILER_GCC) || defined(NK_COMPILER_CLANG)
    #if defined(NK_BUILD_SHARED)
        #define NK_API __attribute__((visibility("default")))
    #else
        #define NK_API
    #endif

#else
    #define NK_API
#endif

// -----------------------------------------------------------------------------
// MACROS D'INLINING
// -----------------------------------------------------------------------------

#if defined(NK_COMPILER_MSVC)
    #define NK_FORCE_INLINE __forceinline
    #define NK_NO_INLINE __declspec(noinline)

#elif defined(NK_COMPILER_GCC) || defined(NK_COMPILER_CLANG)
    #define NK_FORCE_INLINE __attribute__((always_inline)) inline
    #define NK_NO_INLINE __attribute__((noinline))

#else
    #define NK_FORCE_INLINE inline
    #define NK_NO_INLINE
#endif

// Macro d'inlining standard
#define NK_INLINE inline
==================================================


[FICHIER: Core\Nkentseu\src\Nkentseu\Config\Platform.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Config/Platform.h
// DESCRIPTION: D√©tection de la plateforme d'ex√©cution. D√©finit les macros
//              d'identification de plateforme (Windows, Linux, macOS, etc.)
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

// -----------------------------------------------------------------------------
// MACROS DE D√âTECTION DE PLATEFORME
// -----------------------------------------------------------------------------

// Plateforme Windows
#if defined(_WIN32) || defined(_WIN64)
    #define NK_PLATFORM_WINDOWS 1
#endif

// Plateforme Linux (non Android)
#if defined(__linux__) && !defined(__ANDROID__)
    #define NK_PLATFORM_LINUX 1
#endif

// Plateforme macOS
#if defined(__APPLE__) && defined(__MACH__)
    #include <TargetConditionals.h>
    #if TARGET_OS_MAC && !TARGET_OS_IPHONE
        #define NK_PLATFORM_MACOS 1
    #endif
#endif

// Plateforme iOS
#if defined(__APPLE__) && defined(__MACH__)
    #include <TargetConditionals.h>
    #if TARGET_OS_IPHONE
        #define NK_PLATFORM_IOS 1
    #endif
#endif

// Plateforme Android
#if defined(__ANDROID__)
    #define NK_PLATFORM_ANDROID 1
#endif

// Plateforme Emscripten (WebAssembly)
#if defined(__EMSCRIPTEN__)
    #define NK_PLATFORM_EMSCRIPTEN 1
#endif

// -----------------------------------------------------------------------------
// MACROS DE CAT√âGORIE DE PLATEFORME
// -----------------------------------------------------------------------------

// Plateformes Desktop
#if defined(NK_PLATFORM_WINDOWS) || defined(NK_PLATFORM_LINUX) || defined(NK_PLATFORM_MACOS)
    #define NK_PLATFORM_DESKTOP 1
#endif

// Plateformes Mobile
#if defined(NK_PLATFORM_ANDROID) || defined(NK_PLATFORM_IOS)
    #define NK_PLATFORM_MOBILE 1
#endif

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    /**
     * @brief Obtient le nom de la plateforme courante
     * @return Cha√Æne de caract√®res d√©crivant la plateforme
     */
    inline const char* GetPlatformName() {
        #if defined(NK_PLATFORM_WINDOWS)
            return "Windows";
        #elif defined(NK_PLATFORM_LINUX)
            return "Linux";
        #elif defined(NK_PLATFORM_MACOS)
            return "macOS";
        #elif defined(NK_PLATFORM_IOS)
            return "iOS";
        #elif defined(NK_PLATFORM_ANDROID)
            return "Android";
        #elif defined(NK_PLATFORM_EMSCRIPTEN)
            return "Emscripten";
        #else
            return "Unknown";
        #endif
    }

} // namespace nkentseu
==================================================


üìÅ DOSSIER: Core\Unkeny2D
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\Unkeny2D.jenga]
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# FICHIER: Core/Unkeny2D/Unkeny2D.jenga
# DESCRIPTION: Configuration du projet Unkeny2D (biblioth√®que statique principale).
#              D√©finit les sources, d√©pendances et configurations sp√©cifiques
#              √† chaque plateforme.
# AUTEUR: Rihen
# DATE: 2026
# -----------------------------------------------------------------------------

from Jenga.core.api import *

with project("Unkeny2D"):
    # Type de projet: biblioth√®que statique
    staticlib()
    
    # Langage et version C++
    language("C++")
    cppdialect("C++17")
    
    # Fichiers sources globaux
    files([
        "src/Unkeny2D/Core/**.cpp",
        "src/Unkeny2D/Events/**.cpp",
        "src/Unkeny2D/Window/**.cpp",
    ])
    
    # R√©pertoires d'inclusion publics
    includedirs([
        "src",
        "%{Logger.location}/src",
        "%{Nkentseu.location}/src",
    ])
    dependson(["Logger", "Nkentseu"])
    
    # Configuration sp√©cifique √† Windows
    with filter("system:Windows"):
        files(["src/Unkeny2D/Platform/Win32/**.cpp"])
        links(["gdi32", "user32"])
        addldflag("-lgdi32")
        addldflag("-luser32")
    
    # Configuration sp√©cifique √† Linux
    with filter("system:Linux"):
        files(["src/Unkeny2D/Platform/Linux/**.cpp"])
        links(["xcb"])
    
    # Configuration sp√©cifique √† Android
    with filter("system:Android"):
        files(["src/Unkeny2D/Platform/Android/**.cpp"])
        links(["android", "log"])
    
    # Configuration sp√©cifique √† Emscripten
    with filter("system:Emscripten"):
        files(["src/Unkeny2D/Platform/Emscripten/**.cpp"])
    
    # Configuration des r√©pertoires de sortie
    targetdir("%{wks.location}/Build/Lib/%{cfg.buildcfg}")
    objdir("%{wks.location}/Build/Obj/%{cfg.buildcfg}/%{prj.name}")
    
    # Configuration Debug
    with filter("configurations:Debug"):
        defines(["DEBUG", "_DEBUG"])
        optimize("Off")
        symbols("On")
    
    # Configuration Release
    with filter("configurations:Release"):
        defines(["NDEBUG", "RELEASE"])
        optimize("Speed")
        symbols("Off")
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Unkeny.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Unkeny.h
// DESCRIPTION: Point d'entr√©e principal du framework Unkeny. D√©finit les
//              fonctions d'entr√©e sp√©cifiques √† chaque plateforme.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

/**
 * @brief Fonction d'entr√©e principale de l'application
 * @param argc Nombre d'arguments
 * @param argv Tableau d'arguments
 * @return Code de retour de l'application
 */
extern int nkmain(int argc, char* argv[]);

// -----------------------------------------------------------------------------
// POINTS D'ENTR√âE SP√âCIFIQUES √Ä LA PLATEFORME
// -----------------------------------------------------------------------------

#if defined(NK_PLATFORM_WINDOWS)
    /**
     * @brief Point d'entr√©e Windows
     */
    int main(int argc, char* argv[]) {
        return nkmain(argc, argv);
    }
#elif defined(NK_PLATFORM_LINUX) || defined(NK_PLATFORM_EMSCRIPTEN)
    /**
     * @brief Point d'entr√©e Linux/Emscripten
     */
    int main(int argc, char* argv[]) {
        return nkmain(argc, argv);
    }
#elif defined(NK_PLATFORM_ANDROID)
    #include <android_native_app_glue.h>
    
    /**
     * @brief Point d'entr√©e Android
     * @param app Structure d'application Android
     */
    void android_main(struct android_app* app) {
        // TODO: Impl√©menter l'entr√©e Android
    }
#endif
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Events
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Events\Event.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Events/Event.h
// DESCRIPTION: Syst√®me complet d'√©v√©nements avec hi√©rarchie de classes.
//              D√©finit tous les types d'√©v√©nements support√©s (fen√™tre,
//              clavier, souris, tactile).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Nkentseu/Config/Export.h"
#include "Nkentseu/Types.h"
#include <type_traits>
#include <functional>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // √âNUM√âRATION: EventType
    // DESCRIPTION: Identifiants de tous les types d'√©v√©nements support√©s
    // -------------------------------------------------------------------------
    enum class EventType {
        None = 0,
        WindowClosed, WindowResized, WindowFocused, WindowUnfocused,
        KeyPressed, KeyReleased,
        MouseMoved, MouseButtonPressed, MouseButtonReleased, MouseScrolled,
        TouchBegan, TouchMoved, TouchEnded
    };

    // -------------------------------------------------------------------------
    // √âNUM√âRATION: KeyCode
    // DESCRIPTION: Codes des touches du clavier support√©es
    // -------------------------------------------------------------------------
    enum class KeyCode {
        Unknown = 0,
        A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
        Num0, Num1, Num2, Num3, Num4, Num5, Num6, Num7, Num8, Num9,
        F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
        Escape, Enter, Tab, Backspace, Delete, Space,
        Left, Right, Up, Down
    };

    // -------------------------------------------------------------------------
    // √âNUM√âRATION: MouseButton
    // DESCRIPTION: Boutons de souris support√©s
    // -------------------------------------------------------------------------
    enum class MouseButton { Left = 0, Right, Middle };

    // -------------------------------------------------------------------------
    // CLASSE: Event
    // DESCRIPTION: Classe de base abstraite pour tous les √©v√©nements du syst√®me
    // -------------------------------------------------------------------------
    class NK_API Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement
             * @param type Type de l'√©v√©nement
             * @param windowID Identifiant de la fen√™tre associ√©e (optionnel)
             */
            Event(EventType type, uint32 windowID = 0) 
                : m_Type(type), m_WindowID(windowID), m_Handled(false) {}
            
            virtual ~Event() = default;
            
            /**
             * @brief Obtient le type de l'√©v√©nement
             * @return Type de l'√©v√©nement
             */
            EventType GetType() const { return m_Type; }
            
            /**
             * @brief Obtient l'identifiant de la fen√™tre associ√©e
             * @return Identifiant de fen√™tre
             */
            uint32 GetWindowID() const { return m_WindowID; }
            
            /**
             * @brief V√©rifie si l'√©v√©nement a √©t√© trait√©
             * @return true si trait√©, false sinon
             */
            bool IsHandled() const { return m_Handled; }
            
            /**
             * @brief Marque l'√©v√©nement comme trait√©
             * @param h √âtat de traitement (true par d√©faut)
             */
            void SetHandled(bool h = true) { m_Handled = h; }
            
            /**
             * @brief V√©rifie si l'√©v√©nement est d'un type sp√©cifique
             * @tparam T Type d'√©v√©nement √† v√©rifier
             * @return true si l'√©v√©nement est du type T, false sinon
             */
            template<typename T>
            bool IsType() const { return m_Type == T::GetStaticType(); }
            
            /**
             * @brief Conversion s√©curis√©e vers un type d'√©v√©nement sp√©cifique
             * @tparam T Type d'√©v√©nement cible
             * @return R√©f√©rence √† l'√©v√©nement converti
             */
            template<typename T>
            T& As() { return *static_cast<T*>(this); }
            
            /**
             * @brief Conversion s√©curis√©e vers un type d'√©v√©nement sp√©cifique (const)
             * @tparam T Type d'√©v√©nement cible
             * @return R√©f√©rence constante √† l'√©v√©nement converti
             */
            template<typename T>
            const T& As() const { return *static_cast<const T*>(this); }
            
            /**
             * @brief Obtient un pointeur vers l'√©v√©nement s'il est du type sp√©cifi√©
             * @tparam T Type d'√©v√©nement cible
             * @return Pointeur vers l'√©v√©nement ou nullptr si type incorrect
             */
            template<typename T>
            const T* GetIf() const {
                if (IsType<T>()) {
                    return &As<T>();
                }
                return nullptr;
            }
            
            /**
             * @brief Obtient un pointeur vers l'√©v√©nement s'il est du type sp√©cifi√©
             * @tparam T Type d'√©v√©nement cible
             * @return Pointeur vers l'√©v√©nement ou nullptr si type incorrect
             */
            template<typename T>
            T* GetIf() {
                if (IsType<T>()) {
                    return &As<T>();
                }
                return nullptr;
            }

        protected:
            /// Type de l'√©v√©nement
            EventType m_Type;
            
            /// Identifiant de la fen√™tre associ√©e
            uint32 m_WindowID;
            
            /// Indicateur de traitement
            bool m_Handled;
    };

    // -------------------------------------------------------------------------
    // √âV√âNEMENTS DE FEN√äTRE
    // -------------------------------------------------------------------------

    /// √âv√©nement de fermeture de fen√™tre
    class NK_API WindowClosedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de fermeture de fen√™tre
             * @param id Identifiant de la fen√™tre ferm√©e
             */
            WindowClosedEvent(uint32 id) : Event(EventType::WindowClosed, id) {}
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement WindowClosed
             */
            static EventType GetStaticType() { return EventType::WindowClosed; }
    };

    /// √âv√©nement de redimensionnement de fen√™tre
    class NK_API WindowResizedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de redimensionnement de fen√™tre
             * @param id Identifiant de la fen√™tre
             * @param w Nouvelle largeur
             * @param h Nouvelle hauteur
             */
            WindowResizedEvent(uint32 id, uint32 w, uint32 h)
                : Event(EventType::WindowResized, id), width(w), height(h) {}
            
            /**
             * @brief Obtient la nouvelle largeur de la fen√™tre
             * @return Largeur en pixels
             */
            uint32 GetWidth() const { return width; }
            
            /**
             * @brief Obtient la nouvelle hauteur de la fen√™tre
             * @return Hauteur en pixels
             */
            uint32 GetHeight() const { return height; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement WindowResized
             */
            static EventType GetStaticType() { return EventType::WindowResized; }
            
        private:
            /// Nouvelle largeur de la fen√™tre
            uint32 width;
            
            /// Nouvelle hauteur de la fen√™tre
            uint32 height;
    };

    /// √âv√©nement de focus sur une fen√™tre
    class NK_API WindowFocusedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de focus de fen√™tre
             * @param id Identifiant de la fen√™tre ayant re√ßu le focus
             */
            WindowFocusedEvent(uint32 id) : Event(EventType::WindowFocused, id) {}
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement WindowFocused
             */
            static EventType GetStaticType() { return EventType::WindowFocused; }
    };

    /// √âv√©nement de perte de focus d'une fen√™tre
    class NK_API WindowUnfocusedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de perte de focus de fen√™tre
             * @param id Identifiant de la fen√™tre ayant perdu le focus
             */
            WindowUnfocusedEvent(uint32 id) : Event(EventType::WindowUnfocused, id) {}
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement WindowUnfocused
             */
            static EventType GetStaticType() { return EventType::WindowUnfocused; }
    };

    // -------------------------------------------------------------------------
    // √âV√âNEMENTS CLAVIER
    // -------------------------------------------------------------------------

    /// √âv√©nement d'appui sur une touche
    class NK_API KeyPressedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement d'appui sur touche
             * @param id Identifiant de la fen√™tre
             * @param key Code de la touche appuy√©e
             * @param repeated Indique si l'appui est une r√©p√©tition (auto-repeat)
             */
            KeyPressedEvent(uint32 id, KeyCode key, bool repeated = false)
                : Event(EventType::KeyPressed, id), keyCode(key), repeated(repeated) {}
            
            /**
             * @brief Obtient le code de la touche appuy√©e
             * @return Code de touche
             */
            KeyCode GetKeyCode() const { return keyCode; }
            
            /**
             * @brief V√©rifie si l'appui est une r√©p√©tition automatique
             * @return true si r√©p√©tition, false sinon
             */
            bool IsRepeated() const { return repeated; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement KeyPressed
             */
            static EventType GetStaticType() { return EventType::KeyPressed; }
            
        private:
            /// Code de la touche appuy√©e
            KeyCode keyCode;
            
            /// Indicateur de r√©p√©tition automatique
            bool repeated;
    };

    /// √âv√©nement de rel√¢chement d'une touche
    class NK_API KeyReleasedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de rel√¢chement de touche
             * @param id Identifiant de la fen√™tre
             * @param key Code de la touche rel√¢ch√©e
             */
            KeyReleasedEvent(uint32 id, KeyCode key)
                : Event(EventType::KeyReleased, id), keyCode(key) {}
            
            /**
             * @brief Obtient le code de la touche rel√¢ch√©e
             * @return Code de touche
             */
            KeyCode GetKeyCode() const { return keyCode; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement KeyReleased
             */
            static EventType GetStaticType() { return EventType::KeyReleased; }
            
        private:
            /// Code de la touche rel√¢ch√©e
            KeyCode keyCode;
    };

    // -------------------------------------------------------------------------
    // √âV√âNEMENTS SOURIS
    // -------------------------------------------------------------------------

    /// √âv√©nement de mouvement de souris
    class NK_API MouseMovedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de mouvement de souris
             * @param id Identifiant de la fen√™tre
             * @param x Position X du curseur
             * @param y Position Y du curseur
             */
            MouseMovedEvent(uint32 id, float x, float y)
                : Event(EventType::MouseMoved, id), posX(x), posY(y) {}
            
            /**
             * @brief Obtient la position X du curseur
             * @return Position X en pixels
             */
            float GetX() const { return posX; }
            
            /**
             * @brief Obtient la position Y du curseur
             * @return Position Y en pixels
             */
            float GetY() const { return posY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement MouseMoved
             */
            static EventType GetStaticType() { return EventType::MouseMoved; }
            
        private:
            /// Position X du curseur
            float posX;
            
            /// Position Y du curseur
            float posY;
    };

    /// √âv√©nement d'appui sur un bouton de souris
    class NK_API MouseButtonPressedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement d'appui sur bouton de souris
             * @param id Identifiant de la fen√™tre
             * @param button Bouton de souris appuy√©
             * @param x Position X du curseur
             * @param y Position Y du curseur
             */
            MouseButtonPressedEvent(uint32 id, MouseButton button, float x, float y)
                : Event(EventType::MouseButtonPressed, id), button(button), posX(x), posY(y) {}
            
            /**
             * @brief Obtient le bouton de souris appuy√©
             * @return Bouton de souris
             */
            MouseButton GetButton() const { return button; }
            
            /**
             * @brief Obtient la position X du curseur
             * @return Position X en pixels
             */
            float GetX() const { return posX; }
            
            /**
             * @brief Obtient la position Y du curseur
             * @return Position Y en pixels
             */
            float GetY() const { return posY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement MouseButtonPressed
             */
            static EventType GetStaticType() { return EventType::MouseButtonPressed; }
            
        private:
            /// Bouton de souris appuy√©
            MouseButton button;
            
            /// Position X du curseur
            float posX;
            
            /// Position Y du curseur
            float posY;
    };

    /// √âv√©nement de rel√¢chement d'un bouton de souris
    class NK_API MouseButtonReleasedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de rel√¢chement de bouton de souris
             * @param id Identifiant de la fen√™tre
             * @param button Bouton de souris rel√¢ch√©
             * @param x Position X du curseur
             * @param y Position Y du curseur
             */
            MouseButtonReleasedEvent(uint32 id, MouseButton button, float x, float y)
                : Event(EventType::MouseButtonReleased, id), button(button), posX(x), posY(y) {}
            
            /**
             * @brief Obtient le bouton de souris rel√¢ch√©
             * @return Bouton de souris
             */
            MouseButton GetButton() const { return button; }
            
            /**
             * @brief Obtient la position X du curseur
             * @return Position X en pixels
             */
            float GetX() const { return posX; }
            
            /**
             * @brief Obtient la position Y du curseur
             * @return Position Y en pixels
             */
            float GetY() const { return posY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement MouseButtonReleased
             */
            static EventType GetStaticType() { return EventType::MouseButtonReleased; }
            
        private:
            /// Bouton de souris rel√¢ch√©
            MouseButton button;
            
            /// Position X du curseur
            float posX;
            
            /// Position Y du curseur
            float posY;
    };

    /// √âv√©nement de d√©filement de molette de souris
    class NK_API MouseScrolledEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de d√©filement de molette
             * @param id Identifiant de la fen√™tre
             * @param deltaX D√©placement horizontal de la molette
             * @param deltaY D√©placement vertical de la molette
             */
            MouseScrolledEvent(uint32 id, float deltaX, float deltaY)
                : Event(EventType::MouseScrolled, id), deltaX(deltaX), deltaY(deltaY) {}
            
            /**
             * @brief Obtient le d√©placement horizontal de la molette
             * @return Delta X
             */
            float GetDeltaX() const { return deltaX; }
            
            /**
             * @brief Obtient le d√©placement vertical de la molette
             * @return Delta Y
             */
            float GetDeltaY() const { return deltaY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement MouseScrolled
             */
            static EventType GetStaticType() { return EventType::MouseScrolled; }
            
        private:
            /// D√©placement horizontal de la molette
            float deltaX;
            
            /// D√©placement vertical de la molette
            float deltaY;
    };

    // -------------------------------------------------------------------------
    // √âV√âNEMENTS TACTILES
    // -------------------------------------------------------------------------

    /// √âv√©nement de d√©but de contact tactile
    class NK_API TouchBeganEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de d√©but de contact tactile
             * @param id Identifiant de la fen√™tre
             * @param tid Identifiant unique du contact tactile
             * @param x Position X du contact
             * @param y Position Y du contact
             */
            TouchBeganEvent(uint32 id, int32 tid, float x, float y)
                : Event(EventType::TouchBegan, id), touchID(tid), posX(x), posY(y) {}
            
            /**
             * @brief Obtient l'identifiant unique du contact tactile
             * @return Identifiant de contact
             */
            int32 GetTouchID() const { return touchID; }
            
            /**
             * @brief Obtient la position X du contact
             * @return Position X en pixels
             */
            float GetX() const { return posX; }
            
            /**
             * @brief Obtient la position Y du contact
             * @return Position Y en pixels
             */
            float GetY() const { return posY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement TouchBegan
             */
            static EventType GetStaticType() { return EventType::TouchBegan; }
            
        private:
            /// Identifiant unique du contact tactile
            int32 touchID;
            
            /// Position X du contact
            float posX;
            
            /// Position Y du contact
            float posY;
    };

    /// √âv√©nement de mouvement de contact tactile
    class NK_API TouchMovedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de mouvement de contact tactile
             * @param id Identifiant de la fen√™tre
             * @param tid Identifiant unique du contact tactile
             * @param x Position X du contact
             * @param y Position Y du contact
             */
            TouchMovedEvent(uint32 id, int32 tid, float x, float y)
                : Event(EventType::TouchMoved, id), touchID(tid), posX(x), posY(y) {}
            
            /**
             * @brief Obtient l'identifiant unique du contact tactile
             * @return Identifiant de contact
             */
            int32 GetTouchID() const { return touchID; }
            
            /**
             * @brief Obtient la position X du contact
             * @return Position X en pixels
             */
            float GetX() const { return posX; }
            
            /**
             * @brief Obtient la position Y du contact
             * @return Position Y en pixels
             */
            float GetY() const { return posY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement TouchMoved
             */
            static EventType GetStaticType() { return EventType::TouchMoved; }
            
        private:
            /// Identifiant unique du contact tactile
            int32 touchID;
            
            /// Position X du contact
            float posX;
            
            /// Position Y du contact
            float posY;
    };

    /// √âv√©nement de fin de contact tactile
    class NK_API TouchEndedEvent : public Event {
        public:
            /**
             * @brief Constructeur d'√©v√©nement de fin de contact tactile
             * @param id Identifiant de la fen√™tre
             * @param tid Identifiant unique du contact tactile
             * @param x Position X du contact
             * @param y Position Y du contact
             */
            TouchEndedEvent(uint32 id, int32 tid, float x, float y)
                : Event(EventType::TouchEnded, id), touchID(tid), posX(x), posY(y) {}
            
            /**
             * @brief Obtient l'identifiant unique du contact tactile
             * @return Identifiant de contact
             */
            int32 GetTouchID() const { return touchID; }
            
            /**
             * @brief Obtient la position X du contact
             * @return Position X en pixels
             */
            float GetX() const { return posX; }
            
            /**
             * @brief Obtient la position Y du contact
             * @return Position Y en pixels
             */
            float GetY() const { return posY; }
            
            /**
             * @brief Obtient le type statique de l'√©v√©nement
             * @return Type d'√©v√©nement TouchEnded
             */
            static EventType GetStaticType() { return EventType::TouchEnded; }
            
        private:
            /// Identifiant unique du contact tactile
            int32 touchID;
            
            /// Position X du contact
            float posX;
            
            /// Position Y du contact
            float posY;
    };

    // -------------------------------------------------------------------------
    // ALIAS DE TYPE POUR LES CALLBACKS D'√âV√âNEMENTS
    // -------------------------------------------------------------------------
    
    /**
     * @brief Type de callback pour les √©v√©nements
     * @tparam EventType Type d'√©v√©nement sp√©cifique
     */
    template<typename EventType>
    using EventCallback = std::function<void(const EventType&)>;

} // namespace nkentseu
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Events\EventManager.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Events/EventManager.cpp
// DESCRIPTION: Impl√©mentation compl√®te du gestionnaire d'√©v√©nements avec
//              EventTracker RAII, file thread-safe et syst√®me de callbacks.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Unkeny2D/Events/EventManager.h"
#include "Unkeny2D/Window/WindowManager.h"
#include <iostream>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // INITIALISATION DES VARIABLES STATIQUES
    // -------------------------------------------------------------------------
    
    /// File d'attente des √©v√©nements
    std::queue<std::unique_ptr<Event>> EventManager::s_EventQueue;
    
    /// Mutex pour la synchronisation
    std::mutex EventManager::s_Mutex;
    
    /// √âv√©nement courant en traitement
    std::unique_ptr<Event> EventManager::s_CurrentEvent;
    
    /// Registre des callbacks par type d'√©v√©nement
    std::unordered_map<std::type_index, std::vector<std::unique_ptr<ICallbackWrapper>>> EventManager::s_Callbacks;

    // -------------------------------------------------------------------------
    // IMPL√âMENTATION DE LA CLASSE EventTracker
    // -------------------------------------------------------------------------
    
    /**
     * @brief Constructeur de EventTracker
     * @details R√©cup√®re le premier √©v√©nement disponible
     */
    EventTracker::EventTracker() {
        m_CurrentEvent = EventManager::GetNextEvent();
    }
    
    /**
     * @brief Op√©rateur de pr√©-incr√©mentation pour EventTracker
     * @return R√©f√©rence √† l'EventTracker apr√®s passage √† l'√©v√©nement suivant
     */
    EventTracker& EventTracker::operator++() {
        m_CurrentEvent = EventManager::GetNextEvent();
        return *this;
    }

    // =========================================================================
    // IMPL√âMENTATION DE L'API RAII D'EventManager
    // =========================================================================

    /**
     * @brief Commence le tracking des √©v√©nements disponibles
     * @return EventTracker pour it√©ration RAII
     */
    EventTracker EventManager::PollEvent() {
        return EventTracker();
    }
    
    /**
     * @brief R√©cup√®re le prochain √©v√©nement de la file
     * @return Pointeur vers l'√©v√©nement ou nullptr si file vide
     */
    Event* EventManager::GetNextEvent() {
        // Traiter d'abord les √©v√©nements des fen√™tres
        WindowManager::ProcessAllEvents();
        
        Event* result = nullptr;
        
        // R√©cup√©rer un √©v√©nement de la file avec protection thread-safe
        {
            std::lock_guard<std::mutex> lock(s_Mutex);
            if (!s_EventQueue.empty()) {
                s_CurrentEvent = std::move(s_EventQueue.front());
                s_EventQueue.pop();
                result = s_CurrentEvent.get();
            }
        }
        
        return result;
    }

    // =========================================================================
    // IMPL√âMENTATION DE L'API TRADITIONNELLE D'EventManager
    // =========================================================================

    /**
     * @brief Ajoute un √©v√©nement √† la file de traitement
     * @param event √âv√©nement √† ajouter (propri√©t√© transf√©r√©e)
     */
    void EventManager::PushEvent(Event* event) {
        std::lock_guard<std::mutex> lock(s_Mutex);
        s_EventQueue.push(std::unique_ptr<Event>(event));
    }
    
    /**
     * @brief R√©cup√®re le prochain √©v√©nement de la file
     * @param outEvent R√©f√©rence pour recevoir le pointeur d'√©v√©nement
     * @return true si un √©v√©nement a √©t√© r√©cup√©r√©, false si file vide
     */
    bool EventManager::PollEvent(Event*& outEvent) {
        // 1. Traiter les √©v√©nements des fen√™tres (sans lock)
        WindowManager::ProcessAllEvents();
        
        // 2. R√©cup√©rer un √©v√©nement de la file (avec lock)
        {
            std::lock_guard<std::mutex> lock(s_Mutex);
            if (s_EventQueue.empty()) {
                outEvent = nullptr;
                return false;
            }
            
            s_CurrentEvent = std::move(s_EventQueue.front());
            s_EventQueue.pop();
            outEvent = s_CurrentEvent.get();
        }
        
        return true;
    }
    
    /**
     * @brief Vide compl√®tement la file d'√©v√©nements
     */
    void EventManager::ClearEvents() {
        std::lock_guard<std::mutex> lock(s_Mutex);
        while (!s_EventQueue.empty()) {
            s_EventQueue.pop();
        }
    }
    
    /**
     * @brief Obtient le nombre d'√©v√©nements en attente
     * @return Nombre d'√©v√©nements dans la file
     */
    size_t EventManager::GetEventCount() {
        std::lock_guard<std::mutex> lock(s_Mutex);
        return s_EventQueue.size();
    }

    // =========================================================================
    // IMPL√âMENTATION DE L'API DE TRAITEMENT D'EventManager
    // =========================================================================

    /**
     * @brief Traite tous les √©v√©nements avec les callbacks globaux
     */
    void EventManager::ProcessAllEvents() {
        Event* event = nullptr;
        while (PollEvent(event)) {
            if (event) {
                ProcessEvent(event);
            }
        }
    }
    
    /**
     * @brief Traite un seul √©v√©nement avec les callbacks appropri√©s
     * @param event √âv√©nement √† traiter
     */
    void EventManager::ProcessEvent(Event* event) {
        if (!event) return;
        
        // Appeler les callbacks appropri√©s selon le type d'√©v√©nement
        switch (event->GetType()) {
            case EventType::WindowClosed:
                if (const auto* e = event->GetIf<WindowClosedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::WindowResized:
                if (const auto* e = event->GetIf<WindowResizedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::WindowFocused:
                if (const auto* e = event->GetIf<WindowFocusedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::WindowUnfocused:
                if (const auto* e = event->GetIf<WindowUnfocusedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::KeyPressed:
                if (const auto* e = event->GetIf<KeyPressedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::KeyReleased:
                if (const auto* e = event->GetIf<KeyReleasedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::MouseMoved:
                if (const auto* e = event->GetIf<MouseMovedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::MouseButtonPressed:
                if (const auto* e = event->GetIf<MouseButtonPressedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::MouseButtonReleased:
                if (const auto* e = event->GetIf<MouseButtonReleasedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::MouseScrolled:
                if (const auto* e = event->GetIf<MouseScrolledEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::TouchBegan:
                if (const auto* e = event->GetIf<TouchBeganEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::TouchMoved:
                if (const auto* e = event->GetIf<TouchMovedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            case EventType::TouchEnded:
                if (const auto* e = event->GetIf<TouchEndedEvent>()) {
                    CallCallbacks(*e);
                }
                break;
                
            default:
                break;
        }
    }
    
    /**
     * @brief Gestion d'√©v√©nements avec callbacks sp√©cifiques (syntaxe simple)
     */
    void EventManager::HandleEvents(
        std::function<void(const WindowClosedEvent&)> onClose,
        std::function<void(const KeyPressedEvent&)> onKeyPressed,
        std::function<void(const KeyReleasedEvent&)> onKeyReleased,
        std::function<void(const MouseMovedEvent&)> onMouseMoved,
        std::function<void(const MouseButtonPressedEvent&)> onMousePressed,
        std::function<void(const MouseButtonReleasedEvent&)> onMouseReleased,
        std::function<void(const MouseScrolledEvent&)> onMouseScrolled,
        std::function<void(const WindowResizedEvent&)> onResized,
        std::function<void(const WindowFocusedEvent&)> onFocused,
        std::function<void(const WindowUnfocusedEvent&)> onUnfocused
    ) {
        // Utiliser l'API Track() pour une syntaxe plus propre
        auto tracker = PollEvent();
        
        while (tracker) {
            Event* event = &(*tracker); // Obtenir l'√©v√©nement du tracker
            
            // Traiter chaque type d'√©v√©nement avec le callback appropri√©
            if (const auto* closedEvent = event->GetIf<WindowClosedEvent>()) {
                if (onClose) onClose(*closedEvent);
            }
            else if (const auto* keyPressedEvent = event->GetIf<KeyPressedEvent>()) {
                if (onKeyPressed) onKeyPressed(*keyPressedEvent);
            }
            else if (const auto* keyReleasedEvent = event->GetIf<KeyReleasedEvent>()) {
                if (onKeyReleased) onKeyReleased(*keyReleasedEvent);
            }
            else if (const auto* mouseMovedEvent = event->GetIf<MouseMovedEvent>()) {
                if (onMouseMoved) onMouseMoved(*mouseMovedEvent);
            }
            else if (const auto* mousePressedEvent = event->GetIf<MouseButtonPressedEvent>()) {
                if (onMousePressed) onMousePressed(*mousePressedEvent);
            }
            else if (const auto* mouseReleasedEvent = event->GetIf<MouseButtonReleasedEvent>()) {
                if (onMouseReleased) onMouseReleased(*mouseReleasedEvent);
            }
            else if (const auto* mouseScrolledEvent = event->GetIf<MouseScrolledEvent>()) {
                if (onMouseScrolled) onMouseScrolled(*mouseScrolledEvent);
            }
            else if (const auto* resizedEvent = event->GetIf<WindowResizedEvent>()) {
                if (onResized) onResized(*resizedEvent);
            }
            else if (const auto* focusedEvent = event->GetIf<WindowFocusedEvent>()) {
                if (onFocused) onFocused(*focusedEvent);
            }
            else if (const auto* unfocusedEvent = event->GetIf<WindowUnfocusedEvent>()) {
                if (onUnfocused) onUnfocused(*unfocusedEvent);
            }
            
            event->SetHandled(true);
            
            // Passer √† l'√©v√©nement suivant
            ++tracker;
        }
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Events\EventManager.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Events/EventManager.h
// DESCRIPTION: Gestionnaire global d'√©v√©nements avec syst√®me de callbacks,
//              file d'attente thread-safe et it√©rateur RAII (EventTracker).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Nkentseu/Config/Export.h"
#include "Event.h"
#include <queue>
#include <memory>
#include <mutex>
#include <functional>
#include <unordered_map>
#include <vector>
#include <typeindex>
#include <algorithm>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: EventTracker
    // DESCRIPTION: Objet RAII pour l'it√©ration s√©curis√©e des √©v√©nements.
    //              Permet une syntaxe de type "while (auto event = Track())"
    // -------------------------------------------------------------------------
    class EventTracker {
        public:
            /**
             * @brief Constructeur - commence le tracking des √©v√©nements
             */
            EventTracker();
            
            /**
             * @brief Op√©rateur de conversion pour utilisation dans les boucles
             * @return true si un √©v√©nement est disponible, false sinon
             */
            operator bool() const {
                return m_CurrentEvent != nullptr;
            }
            
            /**
             * @brief Op√©rateur fl√®che pour acc√®s aux membres de l'√©v√©nement
             * @return Pointeur vers l'√©v√©nement courant
             */
            Event* operator->() {
                return m_CurrentEvent;
            }
            
            /**
             * @brief Op√©rateur d'indirection pour acc√®s direct √† l'√©v√©nement
             * @return R√©f√©rence √† l'√©v√©nement courant
             */
            Event& operator*() {
                return *m_CurrentEvent;
            }
            
            /**
             * @brief Passe √† l'√©v√©nement suivant dans la file
             * @return R√©f√©rence √† l'EventTracker (pour cha√Ænage)
             */
            EventTracker& operator++();

        private:
            /// √âv√©nement courant en cours de traitement
            Event* m_CurrentEvent;
    };

    // -------------------------------------------------------------------------
    // CLASSE: ICallbackWrapper
    // DESCRIPTION: Interface de base pour les wrappers de callbacks typ√©s
    // -------------------------------------------------------------------------
    class ICallbackWrapper {
        public:
            virtual ~ICallbackWrapper() = default;
            
            /**
             * @brief Appelle le callback avec l'√©v√©nement sp√©cifi√©
             * @param event √âv√©nement √† passer au callback
             */
            virtual void Call(const Event* event) = 0;
            
            /**
             * @brief Obtient le type d'√©v√©nement g√©r√© par ce wrapper
             * @return Type index de l'√©v√©nement
             */
            virtual std::type_index GetEventType() const = 0;
    };

    // -------------------------------------------------------------------------
    // CLASSE TEMPLATE: CallbackWrapper
    // DESCRIPTION: Wrapper typ√© pour les callbacks d'√©v√©nements sp√©cifiques
    // -------------------------------------------------------------------------
    template<typename EventType>
    class CallbackWrapper : public ICallbackWrapper {
        public:
            /**
             * @brief Constructeur du wrapper de callback
             * @param callback Fonction callback √† wrapper
             */
            explicit CallbackWrapper(std::function<void(const EventType&)> callback)
                : m_Callback(std::move(callback)) {}
            
            /**
             * @brief Appelle le callback si l'√©v√©nement est du bon type
             * @param event √âv√©nement √† traiter
             */
            void Call(const Event* event) override {
                if (event && event->IsType<EventType>()) {
                    m_Callback(event->As<EventType>());
                }
            }
            
            /**
             * @brief Obtient le type d'√©v√©nement g√©r√©
             * @return Type index de l'√©v√©nement template
             */
            std::type_index GetEventType() const override {
                return typeid(EventType);
            }
            
        private:
            /// Callback typ√© stock√©
            std::function<void(const EventType&)> m_Callback;
    };

    // -------------------------------------------------------------------------
    // CLASSE: EventManager
    // DESCRIPTION: Gestionnaire global singleton d'√©v√©nements avec file
    //              d'attente thread-safe et syst√®me de callbacks
    // -------------------------------------------------------------------------
    class NK_API EventManager {
        public:
            // ---------------------------------------------------------------------
            // API RAII POUR IT√âRATION
            // ---------------------------------------------------------------------
            
            /**
             * @brief Commence le tracking des √©v√©nements disponibles
             * @return EventTracker pour it√©ration RAII
             * 
             * @code
             * // Utilisation 1: Boucle while
             * while (auto event = EventManager::PollEvent()) {
             *     if (const auto* keyEvent = event->GetIf<KeyPressedEvent>()) {
             *         // Traitement...
             *     }
             *     ++event; // Passe √† l'√©v√©nement suivant
             * }
             * 
             * // Utilisation 2: Boucle for
             * for (auto& event : EventManager::PollEvent()) {
             *     // Traitement...
             * }
             * @endcode
             */
            static EventTracker PollEvent();
            
            /**
             * @brief R√©cup√®re le prochain √©v√©nement de la file
             * @return Pointeur vers l'√©v√©nement ou nullptr si vide
             * 
             * @attention La m√©moire est g√©r√©e par EventManager.
             *            NE PAS appeler delete sur le r√©sultat.
             *            Le pointeur reste valide jusqu'au prochain appel.
             */
            static Event* GetNextEvent();
            
            // ---------------------------------------------------------------------
            // GESTION DE LA FILE D'√âV√âNEMENTS
            // ---------------------------------------------------------------------
            
            /**
             * @brief Ajoute un √©v√©nement √† la file de traitement
             * @param event √âv√©nement √† ajouter (propri√©t√© transf√©r√©e)
             */
            static void PushEvent(Event* event);
            
            /**
             * @brief R√©cup√®re le prochain √©v√©nement de la file
             * @param outEvent R√©f√©rence pour recevoir le pointeur d'√©v√©nement
             * @return true si un √©v√©nement a √©t√© r√©cup√©r√©, false si file vide
             */
            static bool PollEvent(Event*& outEvent);
            
            /**
             * @brief Vide compl√®tement la file d'√©v√©nements
             */
            static void ClearEvents();
            
            /**
             * @brief Obtient le nombre d'√©v√©nements en attente
             * @return Nombre d'√©v√©nements dans la file
             */
            static size_t GetEventCount();
            
            // ---------------------------------------------------------------------
            // API DE CALLBACKS GLOBALE
            // ---------------------------------------------------------------------
            
            /**
             * @brief Enregistre un callback pour un type d'√©v√©nement sp√©cifique
             * @tparam EventType Type d'√©v√©nement √† √©couter
             * @param callback Fonction √† appeler lorsque l'√©v√©nement se produit
             */
            template<typename EventType>
            static void RegisterCallback(std::function<void(const EventType&)> callback);
            
            /**
             * @brief D√©senregistre tous les callbacks pour un type d'√©v√©nement
             * @tparam EventType Type d'√©v√©nement √† d√©senregistrer
             */
            template<typename EventType>
            static void UnregisterAllCallbacks();
            
            // ---------------------------------------------------------------------
            // API FLEXIBLE POUR LE TRAITEMENT D'√âV√âNEMENTS
            // ---------------------------------------------------------------------
            
            /**
             * @brief Traite tous les √©v√©nements avec les callbacks globaux
             */
            static void ProcessAllEvents();
            
            /**
             * @brief Gestion d'√©v√©nements avec callbacks sp√©cifiques (syntaxe simple)
             * @param onClose Callback pour fermeture de fen√™tre
             * @param onKeyPressed Callback pour appui sur touche
             * @param onKeyReleased Callback pour rel√¢chement de touche
             * @param onMouseMoved Callback pour mouvement de souris
             * @param onMousePressed Callback pour appui sur bouton souris
             * @param onMouseReleased Callback pour rel√¢chement bouton souris
             * @param onMouseScrolled Callback pour d√©filement molette
             * @param onResized Callback pour redimensionnement fen√™tre
             * @param onFocused Callback pour focus fen√™tre
             * @param onUnfocused Callback pour perte de focus fen√™tre
             */
            static void HandleEvents(
                std::function<void(const WindowClosedEvent&)> onClose = nullptr,
                std::function<void(const KeyPressedEvent&)> onKeyPressed = nullptr,
                std::function<void(const KeyReleasedEvent&)> onKeyReleased = nullptr,
                std::function<void(const MouseMovedEvent&)> onMouseMoved = nullptr,
                std::function<void(const MouseButtonPressedEvent&)> onMousePressed = nullptr,
                std::function<void(const MouseButtonReleasedEvent&)> onMouseReleased = nullptr,
                std::function<void(const MouseScrolledEvent&)> onMouseScrolled = nullptr,
                std::function<void(const WindowResizedEvent&)> onResized = nullptr,
                std::function<void(const WindowFocusedEvent&)> onFocused = nullptr,
                std::function<void(const WindowUnfocusedEvent&)> onUnfocused = nullptr
            );
            
            /**
             * @brief Pattern visitor pour traiter plusieurs types d'√©v√©nements
             * @tparam Visitor Type du visitor (doit g√©rer tous les types d'√©v√©nements)
             * @param visitor Objet visitor √† appliquer √† chaque √©v√©nement
             */
            template<typename Visitor>
            static void VisitEvents(Visitor&& visitor);
            
            /**
             * @brief Traite un seul √©v√©nement avec les callbacks appropri√©s
             * @param event √âv√©nement √† traiter
             */
            static void ProcessEvent(Event* event);

        private:
            // ---------------------------------------------------------------------
            // VARIABLES STATIQUES PRIV√âES
            // ---------------------------------------------------------------------
            
            /// File d'attente thread-safe des √©v√©nements
            static std::queue<std::unique_ptr<Event>> s_EventQueue;
            
            /// Mutex pour la synchronisation thread-safe
            static std::mutex s_Mutex;
            
            /// √âv√©nement courant en cours de traitement
            static std::unique_ptr<Event> s_CurrentEvent;
            
            /// Registre des callbacks organis√©s par type d'√©v√©nement
            static std::unordered_map<std::type_index, std::vector<std::unique_ptr<ICallbackWrapper>>> s_Callbacks;
            
            // ---------------------------------------------------------------------
            // M√âTHODES TEMPLATE PRIV√âES
            // ---------------------------------------------------------------------
            
            /**
             * @brief Appelle tous les callbacks enregistr√©s pour un type d'√©v√©nement
             * @tparam EventType Type d'√©v√©nement √† traiter
             * @param event √âv√©nement √† passer aux callbacks
             */
            template<typename EventType>
            static void CallCallbacks(const EventType& event);
    };

    // =========================================================================
    // IMPL√âMENTATION DES M√âTHODES TEMPLATE
    // =========================================================================

    /**
     * @brief Enregistre un callback pour un type d'√©v√©nement sp√©cifique
     * @tparam EventType Type d'√©v√©nement √† √©couter
     * @param callback Fonction √† appeler lorsque l'√©v√©nement se produit
     */
    template<typename EventType>
    void EventManager::RegisterCallback(std::function<void(const EventType&)> callback) {
        std::lock_guard<std::mutex> lock(s_Mutex);
        auto& callbacks = s_Callbacks[typeid(EventType)];
        callbacks.push_back(std::make_unique<CallbackWrapper<EventType>>(std::move(callback)));
    }

    /**
     * @brief D√©senregistre tous les callbacks pour un type d'√©v√©nement
     * @tparam EventType Type d'√©v√©nement √† d√©senregistrer
     */
    template<typename EventType>
    void EventManager::UnregisterAllCallbacks() {
        std::lock_guard<std::mutex> lock(s_Mutex);
        s_Callbacks.erase(typeid(EventType));
    }

    /**
     * @brief Appelle tous les callbacks enregistr√©s pour un type d'√©v√©nement
     * @tparam EventType Type d'√©v√©nement √† traiter
     * @param event √âv√©nement √† passer aux callbacks
     */
    template<typename EventType>
    void EventManager::CallCallbacks(const EventType& event) {
        auto it = s_Callbacks.find(typeid(EventType));
        if (it != s_Callbacks.end()) {
            for (auto& wrapper : it->second) {
                wrapper->Call(&event);
            }
        }
    }

    /**
     * @brief Pattern visitor pour traiter plusieurs types d'√©v√©nements
     * @tparam Visitor Type du visitor
     * @param visitor Objet visitor √† appliquer √† chaque √©v√©nement
     */
    template<typename Visitor>
    void EventManager::VisitEvents(Visitor&& visitor) {
        Event* event = nullptr;
        while (PollEvent(event)) {
            if (!event) continue;
            
            // Visiter l'√©v√©nement avec le visitor selon son type
            switch (event->GetType()) {
                case EventType::WindowClosed:
                    if (const auto* e = event->GetIf<WindowClosedEvent>()) visitor(*e);
                    break;
                case EventType::WindowResized:
                    if (const auto* e = event->GetIf<WindowResizedEvent>()) visitor(*e);
                    break;
                case EventType::WindowFocused:
                    if (const auto* e = event->GetIf<WindowFocusedEvent>()) visitor(*e);
                    break;
                case EventType::WindowUnfocused:
                    if (const auto* e = event->GetIf<WindowUnfocusedEvent>()) visitor(*e);
                    break;
                case EventType::KeyPressed:
                    if (const auto* e = event->GetIf<KeyPressedEvent>()) visitor(*e);
                    break;
                case EventType::KeyReleased:
                    if (const auto* e = event->GetIf<KeyReleasedEvent>()) visitor(*e);
                    break;
                case EventType::MouseMoved:
                    if (const auto* e = event->GetIf<MouseMovedEvent>()) visitor(*e);
                    break;
                case EventType::MouseButtonPressed:
                    if (const auto* e = event->GetIf<MouseButtonPressedEvent>()) visitor(*e);
                    break;
                case EventType::MouseButtonReleased:
                    if (const auto* e = event->GetIf<MouseButtonReleasedEvent>()) visitor(*e);
                    break;
                case EventType::MouseScrolled:
                    if (const auto* e = event->GetIf<MouseScrolledEvent>()) visitor(*e);
                    break;
                case EventType::TouchBegan:
                    if (const auto* e = event->GetIf<TouchBeganEvent>()) visitor(*e);
                    break;
                case EventType::TouchMoved:
                    if (const auto* e = event->GetIf<TouchMovedEvent>()) visitor(*e);
                    break;
                case EventType::TouchEnded:
                    if (const auto* e = event->GetIf<TouchEndedEvent>()) visitor(*e);
                    break;
                default:
                    break;
            }
            
            event->SetHandled(true);
        }
    }

} // namespace nkentseu
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Platform\Android
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Android\WindowAndroid.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Android/WindowAndroid.cpp
// DESCRIPTION: Impl√©mentation sp√©cifique Android de l'interface Window.
//              Utilise Android Native App Glue pour la gestion des fen√™tres.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "WindowAndroid.h"

// Compilation conditionnelle pour Android uniquement
#ifdef NK_PLATFORM_ANDROID

#include "Unkeny2D/Events/EventManager.h"
#include "Unkeny2D/Window/WindowManager.h"
#include <android/log.h>

// Macro pour le logging Android
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, "nkentseu", __VA_ARGS__)

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // VARIABLE GLOBALE PRIV√âE
    // -------------------------------------------------------------------------
    
    /// Compteur pour g√©n√©rer des IDs uniques de fen√™tres Android
    static uint32 g_NextWindowID = 1;

    // -------------------------------------------------------------------------
    // IMPL√âMENTATION DE WindowAndroid
    // -------------------------------------------------------------------------
    
    /**
     * @brief Constructeur de fen√™tre Android
     * @param title Titre de la fen√™tre
     * @param width Largeur initiale
     * @param height Hauteur initiale
     */
    WindowAndroid::WindowAndroid(const char* title, uint32 width, uint32 height)
        : m_ID(g_NextWindowID++)
        , m_Title(title)
        , m_Width(width)
        , m_Height(height)
        , m_IsOpen(false)
        , m_App(nullptr)
    {
    }
    
    /**
     * @brief Destructeur de fen√™tre Android
     */
    WindowAndroid::~WindowAndroid() {
        Shutdown();
    }
    
    /**
     * @brief Initialise la fen√™tre Android
     * @return true si r√©ussite, false sinon
     */
    bool WindowAndroid::Initialize() {
        if (!m_App) return false;
        
        // Configuration des callbacks Android
        m_App->userData = this;
        m_App->onAppCmd = HandleCmd;
        m_App->onInputEvent = HandleInput;
        
        m_IsOpen = true;
        WindowManager::RegisterWindow(this);
        LOGI("Android window initialized");
        return true;
    }
    
    /**
     * @brief Lib√®re les ressources de la fen√™tre Android
     */
    void WindowAndroid::Shutdown() {
        m_IsOpen = false;
        WindowManager::UnregisterWindow(this);
    }
    
    /**
     * @brief Traite les √©v√©nements Android
     */
    void WindowAndroid::ProcessEvents() {
        if (!m_App) return;
        
        int events;
        struct android_poll_source* source;
        
        // Boucle de traitement des √©v√©nements Android
        while (ALooper_pollAll(0, nullptr, &events, (void**)&source) >= 0) {
            if (source) {
                source->process(m_App, source);
            }
            
            // Gestion de la fermeture demand√©e
            if (m_App->destroyRequested) {
                EventManager::PushEvent(new WindowClosedEvent(m_ID));
                m_IsOpen = false;
            }
        }
    }
    
    /**
     * @brief Efface la fen√™tre avec une couleur (stub pour Android)
     * @param color Couleur de fond
     */
    void WindowAndroid::Clear(const Color& color) {
        // TODO: Impl√©menter le rendu software pour Android
    }
    
    /**
     * @brief √âchange les buffers (stub pour Android)
     */
    void WindowAndroid::SwapBuffers() {
        // TODO: Impl√©menter l'√©change de buffers pour Android
    }
    
    /**
     * @brief Callback de commande Android
     * @param app Structure d'application Android
     * @param cmd Commande re√ßue
     */
    void WindowAndroid::HandleCmd(struct android_app* app, int32_t cmd) {
        auto* window = (WindowAndroid*)app->userData;
        
        switch (cmd) {
            case APP_CMD_INIT_WINDOW:
                if (app->window) {
                    window->m_Width = ANativeWindow_getWidth(app->window);
                    window->m_Height = ANativeWindow_getHeight(app->window);
                    EventManager::PushEvent(new WindowResizedEvent(window->m_ID, window->m_Width, window->m_Height));
                }
                break;
            case APP_CMD_TERM_WINDOW:
                EventManager::PushEvent(new WindowClosedEvent(window->m_ID));
                break;
        }
    }
    
    /**
     * @brief Callback d'entr√©e Android
     * @param app Structure d'application Android
     * @param event √âv√©nement d'entr√©e
     * @return 1 si √©v√©nement trait√©, 0 sinon
     */
    int32_t WindowAndroid::HandleInput(struct android_app* app, AInputEvent* event) {
        auto* window = (WindowAndroid*)app->userData;
        
        if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {
            float x = AMotionEvent_getX(event, 0);
            float y = AMotionEvent_getY(event, 0);
            int32_t id = AMotionEvent_getPointerId(event, 0);
            
            int32_t action = AMotionEvent_getAction(event) & AMOTION_EVENT_ACTION_MASK;
            
            if (action == AMOTION_EVENT_ACTION_DOWN) {
                EventManager::PushEvent(new TouchBeganEvent(window->m_ID, id, x, y));
            }
            
            return 1;
        }
        
        return 0;
    }

} // namespace nkentseu

#endif // NK_PLATFORM_ANDROID
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Android\WindowAndroid.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Android/WindowAndroid.h
// DESCRIPTION: D√©claration de la classe WindowAndroid (impl√©mentation Android).
//              Header conditionnel pour la plateforme Android.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// Compilation conditionnelle pour Android uniquement
#ifdef NK_PLATFORM_ANDROID

#include <android_native_app_glue.h>
#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowAndroid
    // DESCRIPTION: Impl√©mentation Android de l'interface Window
    // -------------------------------------------------------------------------
    class WindowAndroid : public Window {
    public:
        // ---------------------------------------------------------------------
        // CONSTRUCTEUR ET DESTRUCTEUR
        // ---------------------------------------------------------------------
        
        /**
         * @brief Constructeur de fen√™tre Android
         * @param title Titre de la fen√™tre
         * @param width Largeur initiale
         * @param height Hauteur initiale
         */
        WindowAndroid(const char* title, uint32 width, uint32 height);
        
        /**
         * @brief Destructeur de fen√™tre Android
         */
        ~WindowAndroid() override;
        
        // ---------------------------------------------------------------------
        // IMPL√âMENTATION DE L'INTERFACE Window
        // ---------------------------------------------------------------------
        
        /**
         * @brief Initialise la fen√™tre Android
         * @return true si r√©ussite, false sinon
         */
        bool Initialize() override;
        
        /**
         * @brief Lib√®re les ressources de la fen√™tre Android
         */
        void Shutdown() override;
        
        /**
         * @brief Affiche la fen√™tre (no-op sur Android)
         */
        void Show() override {}
        
        /**
         * @brief Cache la fen√™tre (no-op sur Android)
         */
        void Hide() override {}
        
        /**
         * @brief V√©rifie si la fen√™tre est ouverte
         * @return √âtat d'ouverture de la fen√™tre
         */
        bool IsOpen() const override { return m_IsOpen; }
        
        /**
         * @brief Traite les √©v√©nements Android
         */
        void ProcessEvents() override;
        
        /**
         * @brief Efface la fen√™tre avec une couleur
         * @param color Couleur de fond
         */
        void Clear(const Color& color) override;
        
        /**
         * @brief √âchange les buffers d'affichage
         */
        void SwapBuffers() override;
        
        // ---------------------------------------------------------------------
        // GETTERS
        // ---------------------------------------------------------------------
        
        /**
         * @brief Obtient l'identifiant de la fen√™tre
         * @return ID unique de la fen√™tre
         */
        uint32 GetID() const override { return m_ID; }
        
        /**
         * @brief Obtient la largeur courante de la fen√™tre
         * @return Largeur en pixels
         */
        uint32 GetWidth() const override { return m_Width; }
        
        /**
         * @brief Obtient la hauteur courante de la fen√™tre
         * @return Hauteur en pixels
         */
        uint32 GetHeight() const override { return m_Height; }
        
        /**
         * @brief Obtient le titre de la fen√™tre
         * @return Titre sous forme de cha√Æne C
         */
        const char* GetTitle() const override { return m_Title.c_str(); }
        
        /**
         * @brief Obtient le nom de la plateforme
         * @return "Android"
         */
        const char* GetPlatformName() const override { return "Android"; }
        
        // ---------------------------------------------------------------------
        // M√âTHODES SP√âCIFIQUES ANDROID
        // ---------------------------------------------------------------------
        
        /**
         * @brief Configure l'application Android associ√©e
         * @param app Structure d'application Android
         */
        void SetAndroidApp(struct android_app* app) { m_App = app; }

    private:
        // ---------------------------------------------------------------------
        // M√âTHODES STATIQUES PRIV√âES (CALLBACKS ANDROID)
        // ---------------------------------------------------------------------
        
        /**
         * @brief Callback de commande Android
         * @param app Structure d'application
         * @param cmd Commande re√ßue
         */
        static void HandleCmd(struct android_app* app, int32_t cmd);
        
        /**
         * @brief Callback d'entr√©e Android
         * @param app Structure d'application
         * @param event √âv√©nement d'entr√©e
         * @return 1 si trait√©, 0 sinon
         */
        static int32_t HandleInput(struct android_app* app, AInputEvent* event);
        
        // ---------------------------------------------------------------------
        // VARIABLES MEMBRE PRIV√âES
        // ---------------------------------------------------------------------
        
        /// Identifiant unique de la fen√™tre
        uint32 m_ID;
        
        /// Titre de la fen√™tre
        std::string m_Title;
        
        /// Largeur de la fen√™tre
        uint32 m_Width;
        
        /// Hauteur de la fen√™tre
        uint32 m_Height;
        
        /// √âtat d'ouverture de la fen√™tre
        bool m_IsOpen;
        
        /// Pointeur vers la structure d'application Android
        struct android_app* m_App;
    };

} // namespace nkentseu

#endif // NK_PLATFORM_ANDROID
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Platform\Emscripten
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Emscripten\WindowEmscripten.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Emscripten/WindowEmscripten.cpp
// DESCRIPTION: Impl√©mentation Emscripten (WebAssembly) de l'interface Window.
//              Utilise les APIs HTML5 Canvas pour l'affichage web.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "WindowEmscripten.h"

// Compilation conditionnelle pour Emscripten uniquement
#ifdef NK_PLATFORM_EMSCRIPTEN

#include "Unkeny2D/Events/EventManager.h"
#include "Unkeny2D/Window/WindowManager.h"
#include <emscripten.h>
#include <emscripten/html5.h>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // VARIABLE GLOBALE PRIV√âE
    // -------------------------------------------------------------------------
    
    /// Compteur pour g√©n√©rer des IDs uniques de fen√™tres Emscripten
    static uint32 g_NextWindowID = 1;

    // -------------------------------------------------------------------------
    // IMPL√âMENTATION DE WindowEmscripten
    // -------------------------------------------------------------------------
    
    /**
     * @brief Constructeur de fen√™tre Emscripten
     * @param title Titre de la fen√™tre
     * @param width Largeur initiale
     * @param height Hauteur initiale
     */
    WindowEmscripten::WindowEmscripten(const char* title, uint32 width, uint32 height)
        : m_ID(g_NextWindowID++)
        , m_Title(title)
        , m_Width(width)
        , m_Height(height)
        , m_IsOpen(false)
    {
    }
    
    /**
     * @brief Destructeur de fen√™tre Emscripten
     */
    WindowEmscripten::~WindowEmscripten() {
        Shutdown();
    }
    
    /**
     * @brief Initialise la fen√™tre Emscripten
     * @return true si r√©ussite, false sinon
     */
    bool WindowEmscripten::Initialize() {
        // Configuration du canvas HTML5
        emscripten_set_canvas_element_size("#canvas", m_Width, m_Height);
        
        m_IsOpen = true;
        WindowManager::RegisterWindow(this);
        return true;
    }
    
    /**
     * @brief Lib√®re les ressources de la fen√™tre Emscripten
     */
    void WindowEmscripten::Shutdown() {
        m_IsOpen = false;
        WindowManager::UnregisterWindow(this);
    }
    
    /**
     * @brief Traite les √©v√©nements (g√©r√©s par HTML5 sur Emscripten)
     */
    void WindowEmscripten::ProcessEvents() {
        // Les √©v√©nements sont g√©r√©s via les callbacks HTML5
    }
    
    /**
     * @brief Efface la fen√™tre avec une couleur (stub pour Emscripten)
     * @param color Couleur de fond
     */
    void WindowEmscripten::Clear(const Color& color) {
        // TODO: Impl√©menter le rendu Canvas 2D pour Emscripten
    }
    
    /**
     * @brief √âchange les buffers (automatique avec le navigateur)
     */
    void WindowEmscripten::SwapBuffers() {
        // Automatique avec le navigateur
    }

} // namespace nkentseu

#endif // NK_PLATFORM_EMSCRIPTEN
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Emscripten\WindowEmscripten.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Emscripten/WindowEmscripten.h
// DESCRIPTION: D√©claration de la classe WindowEmscripten.
//              Header conditionnel pour la plateforme Emscripten.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// Compilation conditionnelle pour Emscripten uniquement
#ifdef NK_PLATFORM_EMSCRIPTEN

#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowEmscripten
    // DESCRIPTION: Impl√©mentation Emscripten de l'interface Window
    // -------------------------------------------------------------------------
    class WindowEmscripten : public Window {
    public:
        // ---------------------------------------------------------------------
        // CONSTRUCTEUR ET DESTRUCTEUR
        // ---------------------------------------------------------------------
        
        /**
         * @brief Constructeur de fen√™tre Emscripten
         * @param title Titre de la fen√™tre
         * @param width Largeur initiale
         * @param height Hauteur initiale
         */
        WindowEmscripten(const char* title, uint32 width, uint32 height);
        
        /**
         * @brief Destructeur de fen√™tre Emscripten
         */
        ~WindowEmscripten() override;
        
        // ---------------------------------------------------------------------
        // IMPL√âMENTATION DE L'INTERFACE Window
        // ---------------------------------------------------------------------
        
        /**
         * @brief Initialise la fen√™tre Emscripten
         * @return true si r√©ussite, false sinon
         */
        bool Initialize() override;
        
        /**
         * @brief Lib√®re les ressources de la fen√™tre Emscripten
         */
        void Shutdown() override;
        
        /**
         * @brief Affiche la fen√™tre (no-op sur Emscripten)
         */
        void Show() override {}
        
        /**
         * @brief Cache la fen√™tre (no-op sur Emscripten)
         */
        void Hide() override {}
        
        /**
         * @brief V√©rifie si la fen√™tre est ouverte
         * @return √âtat d'ouverture de la fen√™tre
         */
        bool IsOpen() const override { return m_IsOpen; }
        
        /**
         * @brief Traite les √©v√©nements (g√©r√©s par HTML5)
         */
        void ProcessEvents() override;
        
        /**
         * @brief Efface la fen√™tre avec une couleur
         * @param color Couleur de fond
         */
        void Clear(const Color& color) override;
        
        /**
         * @brief √âchange les buffers d'affichage
         */
        void SwapBuffers() override;
        
        // ---------------------------------------------------------------------
        // GETTERS
        // ---------------------------------------------------------------------
        
        /**
         * @brief Obtient l'identifiant de la fen√™tre
         * @return ID unique de la fen√™tre
         */
        uint32 GetID() const override { return m_ID; }
        
        /**
         * @brief Obtient la largeur courante de la fen√™tre
         * @return Largeur en pixels
         */
        uint32 GetWidth() const override { return m_Width; }
        
        /**
         * @brief Obtient la hauteur courante de la fen√™tre
         * @return Hauteur en pixels
         */
        uint32 GetHeight() const override { return m_Height; }
        
        /**
         * @brief Obtient le titre de la fen√™tre
         * @return Titre sous forme de cha√Æne C
         */
        const char* GetTitle() const override { return m_Title.c_str(); }
        
        /**
         * @brief Obtient le nom de la plateforme
         * @return "Emscripten"
         */
        const char* GetPlatformName() const override { return "Emscripten"; }

    private:
        // ---------------------------------------------------------------------
        // VARIABLES MEMBRE PRIV√âES
        // ---------------------------------------------------------------------
        
        /// Identifiant unique de la fen√™tre
        uint32 m_ID;
        
        /// Titre de la fen√™tre
        std::string m_Title;
        
        /// Largeur de la fen√™tre
        uint32 m_Width;
        
        /// Hauteur de la fen√™tre
        uint32 m_Height;
        
        /// √âtat d'ouverture de la fen√™tre
        bool m_IsOpen;
    };

} // namespace nkentseu

#endif // NK_PLATFORM_EMSCRIPTEN
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Platform\iOS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\iOS\WindowIOS.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/iOS/WindowIOS.h
// DESCRIPTION: Stub d'impl√©mentation iOS de l'interface Window.
//              √Ä compl√©ter avec les APIs iOS natives (UIKit).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// Compilation conditionnelle pour iOS uniquement
#ifdef NK_PLATFORM_IOS

#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowIOS
    // DESCRIPTION: Impl√©mentation iOS (stub) de l'interface Window
    // -------------------------------------------------------------------------
    class WindowIOS : public Window {
    public:
        // ---------------------------------------------------------------------
        // CONSTRUCTEUR ET DESTRUCTEUR
        // ---------------------------------------------------------------------
        
        /**
         * @brief Constructeur de fen√™tre iOS (stub)
         * @param title Titre de la fen√™tre
         * @param width Largeur initiale
         * @param height Hauteur initiale
         */
        WindowIOS(const char* title, uint32 width, uint32 height) {}
        
        /**
         * @brief Destructeur de fen√™tre iOS (stub)
         */
        ~WindowIOS() override {}
        
        // ---------------------------------------------------------------------
        // IMPL√âMENTATION DE L'INTERFACE Window (STUBS)
        // ---------------------------------------------------------------------
        
        /**
         * @brief Initialise la fen√™tre iOS (stub)
         * @return false (non impl√©ment√©)
         */
        bool Initialize() override { return false; }
        
        /**
         * @brief Lib√®re les ressources de la fen√™tre iOS (stub)
         */
        void Shutdown() override {}
        
        /**
         * @brief Affiche la fen√™tre (stub)
         */
        void Show() override {}
        
        /**
         * @brief Cache la fen√™tre (stub)
         */
        void Hide() override {}
        
        /**
         * @brief V√©rifie si la fen√™tre est ouverte (stub)
         * @return false (non impl√©ment√©)
         */
        bool IsOpen() const override { return false; }
        
        /**
         * @brief Traite les √©v√©nements iOS (stub)
         */
        void ProcessEvents() override {}
        
        /**
         * @brief Efface la fen√™tre avec une couleur (stub)
         * @param color Couleur de fond
         */
        void Clear(const Color& color) override {}
        
        /**
         * @brief √âchange les buffers d'affichage (stub)
         */
        void SwapBuffers() override {}
        
        // ---------------------------------------------------------------------
        // GETTERS (STUBS)
        // ---------------------------------------------------------------------
        
        /**
         * @brief Obtient l'identifiant de la fen√™tre (stub)
         * @return 0 (non impl√©ment√©)
         */
        uint32 GetID() const override { return 0; }
        
        /**
         * @brief Obtient la largeur courante de la fen√™tre (stub)
         * @return 0 (non impl√©ment√©)
         */
        uint32 GetWidth() const override { return 0; }
        
        /**
         * @brief Obtient la hauteur courante de la fen√™tre (stub)
         * @return 0 (non impl√©ment√©)
         */
        uint32 GetHeight() const override { return 0; }
        
        /**
         * @brief Obtient le titre de la fen√™tre (stub)
         * @return Cha√Æne vide (non impl√©ment√©)
         */
        const char* GetTitle() const override { return ""; }
        
        /**
         * @brief Obtient le nom de la plateforme
         * @return "iOS"
         */
        const char* GetPlatformName() const override { return "iOS"; }
    };

} // namespace nkentseu

#endif // NK_PLATFORM_IOS
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Platform\Linux
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Linux\WindowXCB.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Linux/WindowXCB.cpp
// DESCRIPTION: Impl√©mentation Linux XCB de l'interface Window.
//              Utilise XCB (X Protocol C Binding) pour la gestion des fen√™tres.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "WindowXCB.h"

// Compilation conditionnelle pour Linux uniquement
#ifdef NK_PLATFORM_LINUX

#include "Unkeny2D/Events/EventManager.h"
#include "Unkeny2D/Window/WindowManager.h"

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // VARIABLE GLOBALE PRIV√âE
    // -------------------------------------------------------------------------
    
    /// Compteur pour g√©n√©rer des IDs uniques de fen√™tres XCB
    static uint32 g_NextWindowID = 1;

    // -------------------------------------------------------------------------
    // IMPL√âMENTATION DE WindowXCB
    // -------------------------------------------------------------------------
    
    /**
     * @brief Constructeur de fen√™tre XCB
     * @param title Titre de la fen√™tre
     * @param width Largeur initiale
     * @param height Hauteur initiale
     */
    WindowXCB::WindowXCB(const char* title, uint32 width, uint32 height)
        : m_ID(g_NextWindowID++)
        , m_Title(title)
        , m_Width(width)
        , m_Height(height)
        , m_IsOpen(false)
        , m_Connection(nullptr)
        , m_Window(0)
        , m_Screen(nullptr)
        , m_GC(0)
    {
    }
    
    /**
     * @brief Destructeur de fen√™tre XCB
     */
    WindowXCB::~WindowXCB() {
        Shutdown();
    }
    
    /**
     * @brief Initialise la fen√™tre XCB
     * @return true si r√©ussite, false sinon
     */
    bool WindowXCB::Initialize() {
        // Connexion au serveur X
        m_Connection = xcb_connect(nullptr, nullptr);
        if (xcb_connection_has_error(m_Connection)) return false;
        
        // R√©cup√©ration de l'√©cran par d√©faut
        const xcb_setup_t* setup = xcb_get_setup(m_Connection);
        xcb_screen_iterator_t iter = xcb_setup_roots_iterator(setup);
        m_Screen = iter.data;
        
        // Cr√©ation de la fen√™tre XCB
        m_Window = xcb_generate_id(m_Connection);
        
        uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
        uint32_t values[2] = {
            m_Screen->white_pixel,
            XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_KEY_PRESS | 
            XCB_EVENT_MASK_BUTTON_PRESS | XCB_EVENT_MASK_POINTER_MOTION |
            XCB_EVENT_MASK_STRUCTURE_NOTIFY
        };
        
        xcb_create_window(m_Connection, XCB_COPY_FROM_PARENT, m_Window, m_Screen->root,
                          0, 0, m_Width, m_Height, 1,
                          XCB_WINDOW_CLASS_INPUT_OUTPUT, m_Screen->root_visual,
                          mask, values);
        
        // D√©finition du titre de la fen√™tre
        xcb_change_property(m_Connection, XCB_PROP_MODE_REPLACE, m_Window,
                           XCB_ATOM_WM_NAME, XCB_ATOM_STRING, 8,
                           m_Title.length(), m_Title.c_str());
        
        // Cr√©ation du contexte graphique (GC)
        m_GC = xcb_generate_id(m_Connection);
        xcb_create_gc(m_Connection, m_GC, m_Window, 0, nullptr);
        
        // Affichage de la fen√™tre
        xcb_map_window(m_Connection, m_Window);
        xcb_flush(m_Connection);
        
        m_IsOpen = true;
        WindowManager::RegisterWindow(this);
        return true;
    }
    
    /**
     * @brief Lib√®re les ressources de la fen√™tre XCB
     */
    void WindowXCB::Shutdown() {
        if (m_Connection) {
            xcb_destroy_window(m_Connection, m_Window);
            xcb_disconnect(m_Connection);
            m_Connection = nullptr;
        }
        m_IsOpen = false;
        WindowManager::UnregisterWindow(this);
    }
    
    /**
     * @brief Affiche la fen√™tre XCB
     */
    void WindowXCB::Show() {
        if (m_Connection) {
            xcb_map_window(m_Connection, m_Window);
            xcb_flush(m_Connection);
        }
    }
    
    /**
     * @brief Cache la fen√™tre XCB
     */
    void WindowXCB::Hide() {
        if (m_Connection) {
            xcb_unmap_window(m_Connection, m_Window);
            xcb_flush(m_Connection);
        }
    }
    
    /**
     * @brief Traite les √©v√©nements XCB
     */
    void WindowXCB::ProcessEvents() {
        xcb_generic_event_t* event;
        while ((event = xcb_poll_for_event(m_Connection))) {
            switch (event->response_type & ~0x80) {
                case XCB_KEY_PRESS: {
                    auto* kp = (xcb_key_press_event_t*)event;
                    EventManager::PushEvent(new KeyPressedEvent(m_ID, KeyCode::Unknown));
                    break;
                }
                case XCB_MOTION_NOTIFY: {
                    auto* mn = (xcb_motion_notify_event_t*)event;
                    EventManager::PushEvent(new MouseMovedEvent(m_ID, mn->event_x, mn->event_y));
                    break;
                }
                case XCB_CONFIGURE_NOTIFY: {
                    auto* cfg = (xcb_configure_notify_event_t*)event;
                    if (cfg->width != m_Width || cfg->height != m_Height) {
                        m_Width = cfg->width;
                        m_Height = cfg->height;
                        EventManager::PushEvent(new WindowResizedEvent(m_ID, m_Width, m_Height));
                    }
                    break;
                }
            }
            free(event);
        }
    }
    
    /**
     * @brief Efface la fen√™tre avec une couleur (rendu software XCB)
     * @param color Couleur de fond
     */
    void WindowXCB::Clear(const Color& color) {
        if (!m_Connection) return;
        
        // Conversion de la couleur RGBA vers pixel XCB
        uint32_t pixel = ((uint32_t)(color.r * 255) << 16) |
                         ((uint32_t)(color.g * 255) << 8) |
                         ((uint32_t)(color.b * 255));
        
        xcb_change_gc(m_Connection, m_GC, XCB_GC_FOREGROUND, &pixel);
        
        // Remplissage du rectangle
        xcb_rectangle_t rect = { 0, 0, (uint16_t)m_Width, (uint16_t)m_Height };
        xcb_poly_fill_rectangle(m_Connection, m_Window, m_GC, 1, &rect);
        xcb_flush(m_Connection);
    }
    
    /**
     * @brief √âchange les buffers (rendu software - no-op)
     */
    void WindowXCB::SwapBuffers() {
        // Rend software - pas d'√©change de buffers n√©cessaire
    }

} // namespace nkentseu

#endif // NK_PLATFORM_LINUX
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Linux\WindowXCB.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Linux/WindowXCB.h
// DESCRIPTION: D√©claration de la classe WindowXCB (impl√©mentation Linux XCB).
//              Header conditionnel pour la plateforme Linux.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// Compilation conditionnelle pour Linux uniquement
#ifdef NK_PLATFORM_LINUX

#include <xcb/xcb.h>
#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowXCB
    // DESCRIPTION: Impl√©mentation Linux XCB de l'interface Window
    // -------------------------------------------------------------------------
    class WindowXCB : public Window {
    public:
        // ---------------------------------------------------------------------
        // CONSTRUCTEUR ET DESTRUCTEUR
        // ---------------------------------------------------------------------
        
        /**
         * @brief Constructeur de fen√™tre XCB
         * @param title Titre de la fen√™tre
         * @param width Largeur initiale
         * @param height Hauteur initiale
         */
        WindowXCB(const char* title, uint32 width, uint32 height);
        
        /**
         * @brief Destructeur de fen√™tre XCB
         */
        ~WindowXCB() override;
        
        // ---------------------------------------------------------------------
        // IMPL√âMENTATION DE L'INTERFACE Window
        // ---------------------------------------------------------------------
        
        /**
         * @brief Initialise la fen√™tre XCB
         * @return true si r√©ussite, false sinon
         */
        bool Initialize() override;
        
        /**
         * @brief Lib√®re les ressources de la fen√™tre XCB
         */
        void Shutdown() override;
        
        /**
         * @brief Affiche la fen√™tre XCB
         */
        void Show() override;
        
        /**
         * @brief Cache la fen√™tre XCB
         */
        void Hide() override;
        
        /**
         * @brief V√©rifie si la fen√™tre est ouverte
         * @return √âtat d'ouverture de la fen√™tre
         */
        bool IsOpen() const override { return m_IsOpen; }
        
        /**
         * @brief Traite les √©v√©nements XCB
         */
        void ProcessEvents() override;
        
        /**
         * @brief Efface la fen√™tre avec une couleur
         * @param color Couleur de fond
         */
        void Clear(const Color& color) override;
        
        /**
         * @brief √âchange les buffers d'affichage
         */
        void SwapBuffers() override;
        
        // ---------------------------------------------------------------------
        // GETTERS
        // ---------------------------------------------------------------------
        
        /**
         * @brief Obtient l'identifiant de la fen√™tre
         * @return ID unique de la fen√™tre
         */
        uint32 GetID() const override { return m_ID; }
        
        /**
         * @brief Obtient la largeur courante de la fen√™tre
         * @return Largeur en pixels
         */
        uint32 GetWidth() const override { return m_Width; }
        
        /**
         * @brief Obtient la hauteur courante de la fen√™tre
         * @return Hauteur en pixels
         */
        uint32 GetHeight() const override { return m_Height; }
        
        /**
         * @brief Obtient le titre de la fen√™tre
         * @return Titre sous forme de cha√Æne C
         */
        const char* GetTitle() const override { return m_Title.c_str(); }
        
        /**
         * @brief Obtient le nom de la plateforme
         * @return "Linux"
         */
        const char* GetPlatformName() const override { return "Linux"; }

    private:
        // ---------------------------------------------------------------------
        // VARIABLES MEMBRE PRIV√âES
        // ---------------------------------------------------------------------
        
        /// Identifiant unique de la fen√™tre
        uint32 m_ID;
        
        /// Titre de la fen√™tre
        std::string m_Title;
        
        /// Largeur de la fen√™tre
        uint32 m_Width;
        
        /// Hauteur de la fen√™tre
        uint32 m_Height;
        
        /// √âtat d'ouverture de la fen√™tre
        bool m_IsOpen;
        
        /// Connexion XCB
        xcb_connection_t* m_Connection;
        
        /// Fen√™tre XCB
        xcb_window_t m_Window;
        
        /// √âcran XCB
        xcb_screen_t* m_Screen;
        
        /// Contexte graphique XCB
        xcb_gcontext_t m_GC;
    };

} // namespace nkentseu

#endif // NK_PLATFORM_LINUX
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Platform\macOS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\macOS\WindowMacOS.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/macOS/WindowMacOS.h
// DESCRIPTION: Stub d'impl√©mentation macOS de l'interface Window.
//              √Ä compl√©ter avec les APIs macOS natives (Cocoa).
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// Compilation conditionnelle pour macOS uniquement
#ifdef NK_PLATFORM_MACOS

#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowMacOS
    // DESCRIPTION: Impl√©mentation macOS (stub) de l'interface Window
    // -------------------------------------------------------------------------
    class WindowMacOS : public Window {
    public:
        // ---------------------------------------------------------------------
        // CONSTRUCTEUR ET DESTRUCTEUR
        // ---------------------------------------------------------------------
        
        /**
         * @brief Constructeur de fen√™tre macOS (stub)
         * @param title Titre de la fen√™tre
         * @param width Largeur initiale
         * @param height Hauteur initiale
         */
        WindowMacOS(const char* title, uint32 width, uint32 height);
        
        /**
         * @brief Destructeur de fen√™tre macOS (stub)
         */
        ~WindowMacOS() override;
        
        // ---------------------------------------------------------------------
        // IMPL√âMENTATION DE L'INTERFACE Window (STUBS)
        // ---------------------------------------------------------------------
        
        /**
         * @brief Initialise la fen√™tre macOS (stub)
         * @return false (non impl√©ment√©)
         */
        bool Initialize() override { return false; }
        
        /**
         * @brief Lib√®re les ressources de la fen√™tre macOS (stub)
         */
        void Shutdown() override {}
        
        /**
         * @brief Affiche la fen√™tre (stub)
         */
        void Show() override {}
        
        /**
         * @brief Cache la fen√™tre (stub)
         */
        void Hide() override {}
        
        /**
         * @brief V√©rifie si la fen√™tre est ouverte (stub)
         * @return false (non impl√©ment√©)
         */
        bool IsOpen() const override { return false; }
        
        /**
         * @brief Traite les √©v√©nements macOS (stub)
         */
        void ProcessEvents() override {}
        
        /**
         * @brief Efface la fen√™tre avec une couleur (stub)
         * @param color Couleur de fond
         */
        void Clear(const Color& color) override {}
        
        /**
         * @brief √âchange les buffers d'affichage (stub)
         */
        void SwapBuffers() override {}
        
        // ---------------------------------------------------------------------
        // GETTERS (STUBS)
        // ---------------------------------------------------------------------
        
        /**
         * @brief Obtient l'identifiant de la fen√™tre (stub)
         * @return 0 (non impl√©ment√©)
         */
        uint32 GetID() const override { return 0; }
        
        /**
         * @brief Obtient la largeur courante de la fen√™tre (stub)
         * @return 0 (non impl√©ment√©)
         */
        uint32 GetWidth() const override { return 0; }
        
        /**
         * @brief Obtient la hauteur courante de la fen√™tre (stub)
         * @return 0 (non impl√©ment√©)
         */
        uint32 GetHeight() const override { return 0; }
        
        /**
         * @brief Obtient le titre de la fen√™tre (stub)
         * @return Cha√Æne vide (non impl√©ment√©)
         */
        const char* GetTitle() const override { return ""; }
        
        /**
         * @brief Obtient le nom de la plateforme
         * @return "macOS"
         */
        const char* GetPlatformName() const override { return "macOS"; }
    };

} // namespace nkentseu

#endif // NK_PLATFORM_MACOS
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Platform\Win32
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Win32\WindowWin32.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Win32/WindowWin32.cpp
// DESCRIPTION: Impl√©mentation Win32 de l'interface Window.
//              Utilise l'API Windows native (Win32) pour la gestion des fen√™tres.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "WindowWin32.h"

// Compilation conditionnelle pour Windows uniquement
#ifdef NK_PLATFORM_WINDOWS

#include "Unkeny2D/Events/EventManager.h"
#include "Unkeny2D/Window/WindowManager.h"
#include <windowsx.h>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // VARIABLES GLOBALES PRIV√âES
    // -------------------------------------------------------------------------
    
    /// Compteur pour g√©n√©rer des IDs uniques de fen√™tres Win32
    static uint32 g_NextWindowID = 1;
    
    /// Nom de la classe de fen√™tre Win32
    static const wchar_t* WINDOW_CLASS_NAME = L"NkentseuWindowClass";
    
    /// Indicateur d'enregistrement de classe
    static bool g_ClassRegistered = false;

    // -------------------------------------------------------------------------
    // IMPL√âMENTATION DE WindowWin32
    // -------------------------------------------------------------------------
    
    /**
     * @brief Constructeur de fen√™tre Win32
     * @param title Titre de la fen√™tre
     * @param width Largeur initiale
     * @param height Hauteur initiale
     */
    WindowWin32::WindowWin32(const char* title, uint32 width, uint32 height)
        : m_ID(g_NextWindowID++)
        , m_Title(title)
        , m_Width(width)
        , m_Height(height)
        , m_IsOpen(false)
        , m_Hwnd(nullptr)
        , m_Hdc(nullptr)
    {
        m_Hinstance = GetModuleHandle(nullptr);
    }
    
    /**
     * @brief Destructeur de fen√™tre Win32
     */
    WindowWin32::~WindowWin32() {
        Shutdown();
    }
    
    /**
     * @brief Initialise la fen√™tre Win32
     * @return true si r√©ussite, false sinon
     */
    bool WindowWin32::Initialize() {
        // Enregistrement de la classe de fen√™tre (une seule fois)
        if (!g_ClassRegistered) {
            WNDCLASSEXW wc = {};
            wc.cbSize = sizeof(WNDCLASSEXW);
            wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
            wc.lpfnWndProc = WindowProc;
            wc.hInstance = m_Hinstance;
            wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
            wc.lpszClassName = WINDOW_CLASS_NAME;
            
            if (!RegisterClassExW(&wc)) return false;
            g_ClassRegistered = true;
        }
        
        // Calcul du rectangle client avec ajustement pour les bordures
        RECT rect = { 0, 0, (LONG)m_Width, (LONG)m_Height };
        AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
        
        // Conversion du titre UTF-8 vers UTF-16
        int titleLen = MultiByteToWideChar(CP_UTF8, 0, m_Title.c_str(), -1, nullptr, 0);
        wchar_t* wTitle = new wchar_t[titleLen];
        MultiByteToWideChar(CP_UTF8, 0, m_Title.c_str(), -1, wTitle, titleLen);
        
        // Cr√©ation de la fen√™tre
        m_Hwnd = CreateWindowExW(
            0, WINDOW_CLASS_NAME, wTitle, WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT,
            rect.right - rect.left, rect.bottom - rect.top,
            nullptr, nullptr, m_Hinstance, this
        );
        
        delete[] wTitle;
        
        if (!m_Hwnd) return false;
        
        // Obtention du contexte de p√©riph√©rique
        m_Hdc = GetDC(m_Hwnd);
        m_IsOpen = true;
        
        WindowManager::RegisterWindow(this);
        return true;
    }
    
    /**
     * @brief Lib√®re les ressources de la fen√™tre Win32
     */
    void WindowWin32::Shutdown() {
        if (m_Hdc) {
            ReleaseDC(m_Hwnd, m_Hdc);
            m_Hdc = nullptr;
        }
        if (m_Hwnd) {
            DestroyWindow(m_Hwnd);
            m_Hwnd = nullptr;
        }
        m_IsOpen = false;
        WindowManager::UnregisterWindow(this);
    }
    
    /**
     * @brief Affiche la fen√™tre Win32
     */
    void WindowWin32::Show() {
        if (m_Hwnd) {
            ShowWindow(m_Hwnd, SW_SHOW);
            UpdateWindow(m_Hwnd);
        }
    }
    
    /**
     * @brief Cache la fen√™tre Win32
     */
    void WindowWin32::Hide() {
        if (m_Hwnd) ShowWindow(m_Hwnd, SW_HIDE);
    }
    
    /**
     * @brief Traite les messages Windows
     */
    void WindowWin32::ProcessEvents() {
        MSG msg;
        while (PeekMessageW(&msg, m_Hwnd, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }
    }
    
    /**
     * @brief Efface la fen√™tre avec une couleur (GDI)
     * @param color Couleur de fond
     */
    void WindowWin32::Clear(const Color& color) {
        if (!m_Hdc) return;
        
        RECT rect;
        GetClientRect(m_Hwnd, &rect);
        
        // Cr√©ation d'un brush GDI avec la couleur sp√©cifi√©e
        HBRUSH brush = CreateSolidBrush(RGB(
            (BYTE)(color.r * 255),
            (BYTE)(color.g * 255),
            (BYTE)(color.b * 255)
        ));
        
        FillRect(m_Hdc, &rect, brush);
        DeleteObject(brush);
    }
    
    /**
     * @brief √âchange les buffers (rendu software - no-op)
     */
    void WindowWin32::SwapBuffers() {
        // Rend software - pas d'√©change de buffers n√©cessaire
    }
    
    /**
     * @brief Proc√©dure de fen√™tre Win32 (callback syst√®me)
     * @param hwnd Handle de fen√™tre
     * @param msg Message Windows
     * @param wParam Param√®tre W
     * @param lParam Param√®tre L
     * @return R√©sultat du traitement
     */
    LRESULT CALLBACK WindowWin32::WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        WindowWin32* window = nullptr;
        
        // R√©cup√©ration de l'instance WindowWin32 depuis les donn√©es utilisateur
        if (msg == WM_CREATE) {
            CREATESTRUCT* cs = reinterpret_cast<CREATESTRUCT*>(lParam);
            window = reinterpret_cast<WindowWin32*>(cs->lpCreateParams);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(window));
        } else {
            window = reinterpret_cast<WindowWin32*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
        }
        
        if (!window) return DefWindowProcW(hwnd, msg, wParam, lParam);
        
        // Traitement des messages Windows
        switch (msg) {
            case WM_CLOSE:
                EventManager::PushEvent(new WindowClosedEvent(window->m_ID));
                window->m_IsOpen = false;
                return 0;
            
            case WM_SIZE: {
                UINT width = LOWORD(lParam);
                UINT height = HIWORD(lParam);
                window->m_Width = width;
                window->m_Height = height;
                EventManager::PushEvent(new WindowResizedEvent(window->m_ID, width, height));
                return 0;
            }
            
            case WM_KEYDOWN: {
                KeyCode key = KeyCode::Unknown;
                if (wParam >= 'A' && wParam <= 'Z') {
                    key = (KeyCode)((int)KeyCode::A + (wParam - 'A'));
                } else if (wParam == VK_ESCAPE) {
                    key = KeyCode::Escape;
                } else if (wParam == VK_RETURN) {
                    key = KeyCode::Enter;
                }
                EventManager::PushEvent(new KeyPressedEvent(window->m_ID, key));
                return 0;
            }
            
            case WM_MOUSEMOVE: {
                float x = (float)GET_X_LPARAM(lParam);
                float y = (float)GET_Y_LPARAM(lParam);
                EventManager::PushEvent(new MouseMovedEvent(window->m_ID, x, y));
                return 0;
            }
        }
        
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }

} // namespace nkentseu

#endif // NK_PLATFORM_WINDOWS
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Platform\Win32\WindowWin32.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Platform/Win32/WindowWin32.h
// DESCRIPTION: D√©claration de la classe WindowWin32 (impl√©mentation Win32).
//              Header conditionnel pour la plateforme Windows.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// Compilation conditionnelle pour Windows uniquement
#ifdef NK_PLATFORM_WINDOWS

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowWin32
    // DESCRIPTION: Impl√©mentation Win32 de l'interface Window
    // -------------------------------------------------------------------------
    class WindowWin32 : public Window {
    public:
        // ---------------------------------------------------------------------
        // CONSTRUCTEUR ET DESTRUCTEUR
        // ---------------------------------------------------------------------
        
        /**
         * @brief Constructeur de fen√™tre Win32
         * @param title Titre de la fen√™tre
         * @param width Largeur initiale
         * @param height Hauteur initiale
         */
        WindowWin32(const char* title, uint32 width, uint32 height);
        
        /**
         * @brief Destructeur de fen√™tre Win32
         */
        ~WindowWin32() override;
        
        // ---------------------------------------------------------------------
        // IMPL√âMENTATION DE L'INTERFACE Window
        // ---------------------------------------------------------------------
        
        /**
         * @brief Initialise la fen√™tre Win32
         * @return true si r√©ussite, false sinon
         */
        bool Initialize() override;
        
        /**
         * @brief Lib√®re les ressources de la fen√™tre Win32
         */
        void Shutdown() override;
        
        /**
         * @brief Affiche la fen√™tre Win32
         */
        void Show() override;
        
        /**
         * @brief Cache la fen√™tre Win32
         */
        void Hide() override;
        
        /**
         * @brief V√©rifie si la fen√™tre est ouverte
         * @return √âtat d'ouverture de la fen√™tre
         */
        bool IsOpen() const override { return m_IsOpen; }
        
        /**
         * @brief Traite les messages Windows
         */
        void ProcessEvents() override;
        
        /**
         * @brief Efface la fen√™tre avec une couleur
         * @param color Couleur de fond
         */
        void Clear(const Color& color) override;
        
        /**
         * @brief √âchange les buffers d'affichage
         */
        void SwapBuffers() override;
        
        // ---------------------------------------------------------------------
        // GETTERS
        // ---------------------------------------------------------------------
        
        /**
         * @brief Obtient l'identifiant de la fen√™tre
         * @return ID unique de la fen√™tre
         */
        uint32 GetID() const override { return m_ID; }
        
        /**
         * @brief Obtient la largeur courante de la fen√™tre
         * @return Largeur en pixels
         */
        uint32 GetWidth() const override { return m_Width; }
        
        /**
         * @brief Obtient la hauteur courante de la fen√™tre
         * @return Hauteur en pixels
         */
        uint32 GetHeight() const override { return m_Height; }
        
        /**
         * @brief Obtient le titre de la fen√™tre
         * @return Titre sous forme de cha√Æne C
         */
        const char* GetTitle() const override { return m_Title.c_str(); }
        
        /**
         * @brief Obtient le nom de la plateforme
         * @return "Windows"
         */
        const char* GetPlatformName() const override { return "Windows"; }

    private:
        // ---------------------------------------------------------------------
        // M√âTHODES STATIQUES PRIV√âES
        // ---------------------------------------------------------------------
        
        /**
         * @brief Proc√©dure de fen√™tre Win32 (callback syst√®me)
         * @param hwnd Handle de fen√™tre
         * @param msg Message Windows
         * @param wParam Param√®tre W
         * @param lParam Param√®tre L
         * @return R√©sultat du traitement
         */
        static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
        
        // ---------------------------------------------------------------------
        // VARIABLES MEMBRE PRIV√âES
        // ---------------------------------------------------------------------
        
        /// Identifiant unique de la fen√™tre
        uint32 m_ID;
        
        /// Titre de la fen√™tre
        std::string m_Title;
        
        /// Largeur de la fen√™tre
        uint32 m_Width;
        
        /// Hauteur de la fen√™tre
        uint32 m_Height;
        
        /// √âtat d'ouverture de la fen√™tre
        bool m_IsOpen;
        
        /// Handle de fen√™tre Win32
        HWND m_Hwnd;
        
        /// Contexte de p√©riph√©rique Win32
        HDC m_Hdc;
        
        /// Instance d'application Win32
        HINSTANCE m_Hinstance;
    };

} // namespace nkentseu

#endif // NK_PLATFORM_WINDOWS
==================================================


üìÅ DOSSIER: Core\Unkeny2D\src\Unkeny2D\Window
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Core\Unkeny2D\src\Unkeny2D\Window\Window.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Window/Window.cpp
// DESCRIPTION: Factory pour la cr√©ation de fen√™tres adapt√©es √† la plateforme.
//              S√©lectionne automatiquement l'impl√©mentation appropri√©e.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Unkeny2D/Window/Window.h"
#include "Nkentseu/Config/Platform.h"

// -----------------------------------------------------------------------------
// INCLUDES SP√âCIFIQUES √Ä LA PLATEFORME
// -----------------------------------------------------------------------------

#if defined(NK_PLATFORM_WINDOWS)
    #include "Unkeny2D/Platform/Win32/WindowWin32.h"
    
#elif defined(NK_PLATFORM_LINUX)
    #include "Unkeny2D/Platform/Linux/WindowXCB.h"
    
#elif defined(NK_PLATFORM_MACOS)
    #include "Unkeny2D/Platform/macOS/WindowMacOS.h"
    
#elif defined(NK_PLATFORM_ANDROID)
    #include "Unkeny2D/Platform/Android/WindowAndroid.h"
    
#elif defined(NK_PLATFORM_IOS)
    #include "Unkeny2D/Platform/iOS/WindowIOS.h"
    
#elif defined(NK_PLATFORM_EMSCRIPTEN)
    #include "Unkeny2D/Platform/Emscripten/WindowEmscripten.h"
#endif

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // FONCTION: Window::Create
    // DESCRIPTION: Factory method pour cr√©er une fen√™tre adapt√©e √† la plateforme
    // -------------------------------------------------------------------------
    Window* Window::Create(const char* title, uint32 width, uint32 height) {
        #if defined(NK_PLATFORM_WINDOWS)
            return new WindowWin32(title, width, height);
            
        #elif defined(NK_PLATFORM_LINUX)
            return new WindowXCB(title, width, height);
            
        #elif defined(NK_PLATFORM_MACOS)
            return new WindowMacOS(title, width, height);
            
        #elif defined(NK_PLATFORM_ANDROID)
            return new WindowAndroid(title, width, height);
            
        #elif defined(NK_PLATFORM_IOS)
            return new WindowIOS(title, width, height);
            
        #elif defined(NK_PLATFORM_EMSCRIPTEN)
            return new WindowEmscripten(title, width, height);
            
        #else
            #error "Platform not supported"
            return nullptr;
        #endif
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Window\Window.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Window/Window.h
// DESCRIPTION: Interface principale abstraite pour les fen√™tres multiplateforme.
//              D√©finit l'API commune √† toutes les impl√©mentations de fen√™tres.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Nkentseu/Config/Export.h"
#include "Nkentseu/Types.h"
#include <string>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // STRUCTURE: Color
    // DESCRIPTION: Repr√©sentation d'une couleur RGBA avec composantes flottantes
    // -------------------------------------------------------------------------
    struct Color {
        /// Composante rouge (0.0 √† 1.0)
        float r;
        
        /// Composante verte (0.0 √† 1.0)
        float g;
        
        /// Composante bleue (0.0 √† 1.0)
        float b;
        
        /// Composante alpha (0.0 √† 1.0)
        float a;
        
        /**
         * @brief Constructeur de couleur
         * @param red Composante rouge (d√©faut: 0.0)
         * @param green Composante verte (d√©faut: 0.0)
         * @param blue Composante bleue (d√©faut: 0.0)
         * @param alpha Composante alpha (d√©faut: 1.0)
         */
        Color(float red = 0, float green = 0, float blue = 0, float alpha = 1)
            : r(red), g(green), b(blue), a(alpha) {}
    };

    // -------------------------------------------------------------------------
    // CLASSE: Window
    // DESCRIPTION: Interface abstraite pour les fen√™tres multiplateforme
    // -------------------------------------------------------------------------
    class NK_API Window {
        public:
            virtual ~Window() = default;
            
            // ---------------------------------------------------------------------
            // M√âTHODES STATIQUES
            // ---------------------------------------------------------------------
            
            /**
             * @brief Factory method pour cr√©er une fen√™tre adapt√©e √† la plateforme
             * @param title Titre de la fen√™tre
             * @param width Largeur initiale en pixels
             * @param height Hauteur initiale en pixels
             * @return Pointeur vers la fen√™tre cr√©√©e (√† d√©truire avec delete)
             */
            static Window* Create(const char* title, uint32 width, uint32 height);
            
            // ---------------------------------------------------------------------
            // M√âTHODES VIRTUELLES PURES (INTERFACE)
            // ---------------------------------------------------------------------
            
            /**
             * @brief Initialise la fen√™tre et ses ressources
             * @return true si l'initialisation r√©ussit, false sinon
             */
            virtual bool Initialize() = 0;
            
            /**
             * @brief Lib√®re les ressources de la fen√™tre
             */
            virtual void Shutdown() = 0;
            
            /**
             * @brief Affiche la fen√™tre
             */
            virtual void Show() = 0;
            
            /**
             * @brief Cache la fen√™tre
             */
            virtual void Hide() = 0;
            
            /**
             * @brief V√©rifie si la fen√™tre est ouverte
             * @return true si la fen√™tre est ouverte, false sinon
             */
            virtual bool IsOpen() const = 0;
            
            /**
             * @brief Traite les √©v√©nements en attente de la fen√™tre
             */
            virtual void ProcessEvents() = 0;
            
            /**
             * @brief Efface le contenu de la fen√™tre avec une couleur
             * @param color Couleur de fond
             */
            virtual void Clear(const Color& color) = 0;
            
            /**
             * @brief √âchange les buffers d'affichage (double buffering)
             */
            virtual void SwapBuffers() = 0;
            
            // ---------------------------------------------------------------------
            // M√âTHODES D'ACC√àS (GETTERS)
            // ---------------------------------------------------------------------
            
            /**
             * @brief Obtient l'identifiant unique de la fen√™tre
             * @return Identifiant de fen√™tre
             */
            virtual uint32 GetID() const = 0;
            
            /**
             * @brief Obtient la largeur courante de la fen√™tre
             * @return Largeur en pixels
             */
            virtual uint32 GetWidth() const = 0;
            
            /**
             * @brief Obtient la hauteur courante de la fen√™tre
             * @return Hauteur en pixels
             */
            virtual uint32 GetHeight() const = 0;
            
            /**
             * @brief Obtient le titre de la fen√™tre
             * @return Titre sous forme de cha√Æne C
             */
            virtual const char* GetTitle() const = 0;
            
            /**
             * @brief Obtient le nom de la plateforme d'impl√©mentation
             * @return Nom de la plateforme
             */
            virtual const char* GetPlatformName() const = 0;
    };

} // namespace nkentseu
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Window\WindowManager.cpp]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Window/WindowManager.cpp
// DESCRIPTION: Impl√©mentation du gestionnaire centralis√© des fen√™tres.
//              Fournit des services d'enregistrement, recherche et traitement
//              pour toutes les fen√™tres de l'application.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#include "Unkeny2D/Window/WindowManager.h"
#include <algorithm>
#include <iostream>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // INITIALISATION DES VARIABLES STATIQUES
    // -------------------------------------------------------------------------
    
    /// Liste de toutes les fen√™tres enregistr√©es
    std::vector<Window*> WindowManager::s_Windows;
    
    /// Mutex pour la synchronisation thread-safe
    std::mutex WindowManager::s_Mutex;
    
    /// Compteur pour g√©n√©rer des identifiants uniques
    uint32 WindowManager::s_NextID = 1;

    // -------------------------------------------------------------------------
    // IMPL√âMENTATION DES M√âTHODES PUBLIQUES
    // -------------------------------------------------------------------------
    
    /**
     * @brief Enregistre une nouvelle fen√™tre dans le gestionnaire
     * @param window Pointeur vers la fen√™tre √† enregistrer
     */
    void WindowManager::RegisterWindow(Window* window) {
        std::lock_guard<std::mutex> lock(s_Mutex);
        s_Windows.push_back(window);
    }
    
    /**
     * @brief D√©senregistre une fen√™tre du gestionnaire
     * @param window Pointeur vers la fen√™tre √† d√©senregistrer
     */
    void WindowManager::UnregisterWindow(Window* window) {
        std::lock_guard<std::mutex> lock(s_Mutex);
        auto it = std::find(s_Windows.begin(), s_Windows.end(), window);
        if (it != s_Windows.end()) {
            s_Windows.erase(it);
        }
    }
    
    /**
     * @brief Recherche une fen√™tre par son identifiant
     * @param id Identifiant de la fen√™tre recherch√©e
     * @return Pointeur vers la fen√™tre ou nullptr si non trouv√©e
     */
    Window* WindowManager::GetWindow(uint32 id) {
        std::lock_guard<std::mutex> lock(s_Mutex);
        for (auto* win : s_Windows) {
            if (win->GetID() == id) {
                return win;
            }
        }
        return nullptr;
    }
    
    /**
     * @brief Traite les √©v√©nements de toutes les fen√™tres enregistr√©es
     */
    void WindowManager::ProcessAllEvents() {
        std::lock_guard<std::mutex> lock(s_Mutex);
        for (auto* win : s_Windows) {
            if (win->IsOpen()) {
                win->ProcessEvents();
            }
        }
    }

} // namespace nkentseu
==================================================


[FICHIER: Core\Unkeny2D\src\Unkeny2D\Window\WindowManager.h]
==================================================
// -----------------------------------------------------------------------------
// FICHIER: Core/Unkeny2D/src/Unkeny2D/Window/WindowManager.h
// DESCRIPTION: Gestionnaire centralis√© des fen√™tres. Permet d'enregistrer,
//              suivre et traiter toutes les fen√™tres cr√©√©es dans l'application.
// AUTEUR: Rihen
// DATE: 2026
// -----------------------------------------------------------------------------

#pragma once

#include "Nkentseu/Config/Export.h"
#include "Window.h"
#include <vector>
#include <mutex>

// -----------------------------------------------------------------------------
// NAMESPACE: nkentseu
// -----------------------------------------------------------------------------
namespace nkentseu {

    // -------------------------------------------------------------------------
    // CLASSE: WindowManager
    // DESCRIPTION: Singleton pour la gestion centralis√©e des fen√™tres
    // -------------------------------------------------------------------------
    class NK_API WindowManager {
    public:
        // ---------------------------------------------------------------------
        // M√âTHODES STATIQUES PUBLIQUES
        // ---------------------------------------------------------------------
        
        /**
         * @brief Enregistre une nouvelle fen√™tre dans le gestionnaire
         * @param window Pointeur vers la fen√™tre √† enregistrer
         */
        static void RegisterWindow(Window* window);
        
        /**
         * @brief D√©senregistre une fen√™tre du gestionnaire
         * @param window Pointeur vers la fen√™tre √† d√©senregistrer
         */
        static void UnregisterWindow(Window* window);
        
        /**
         * @brief Recherche une fen√™tre par son identifiant
         * @param id Identifiant de la fen√™tre recherch√©e
         * @return Pointeur vers la fen√™tre ou nullptr si non trouv√©e
         */
        static Window* GetWindow(uint32 id);
        
        /**
         * @brief Traite les √©v√©nements de toutes les fen√™tres enregistr√©es
         */
        static void ProcessAllEvents();

    private:
        // ---------------------------------------------------------------------
        // VARIABLES STATIQUES PRIV√âES
        // ---------------------------------------------------------------------
        
        /// Liste de toutes les fen√™tres enregistr√©es
        static std::vector<Window*> s_Windows;
        
        /// Mutex pour la synchronisation thread-safe
        static std::mutex s_Mutex;
        
        /// Compteur pour g√©n√©rer des identifiants uniques
        static uint32 s_NextID;
    };

} // namespace nkentseu
==================================================


üìÅ DOSSIER: Sandbox
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Sandbox\Sandbox.jenga]
==================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------------
# FICHIER: Sandbox/Sandbox.jenga
# DESCRIPTION: Configuration du projet Sandbox (application de test).
#              D√©finit une application console avec d√©pendance sur Core.
# AUTEUR: Rihen
# DATE: 2026
# -----------------------------------------------------------------------------

from Jenga.core.api import *

with project("Sandbox"):
    # Type de projet: application console
    consoleapp()
    
    # Langage et version C++
    language("C++")
    cppdialect("C++17")
    
    # Fichiers sources
    files(["src/**.cpp"])
    
    # R√©pertoires d'inclusion
    includedirs([
        "%{Unkeny2D.location}/src",
        "%{Logger.location}/src",
        "%{Nkentseu.location}/src",
        "src"
    ])
    
    # D√©pendance sur le projet Core
    dependson(["Unkeny2D", "Logger", "Nkentseu"])
    
    # -------------------------------------------------------------------------
    # CONFIGURATIONS SP√âCIFIQUES √Ä LA PLATEFORME
    # -------------------------------------------------------------------------
    
    # Configuration Windows
    with filter("system:Windows"):
        # Liens avec les biblioth√®ques Windows n√©cessaires
        links(["gdi32", "user32"])
        addldflag("-lgdi32")
        addldflag("-luser32")
    
    # Configuration Linux
    with filter("system:Linux"):
        links(["xcb", "pthread"])
    
    # Configuration Android
    with filter("system:Android"):
        links(["android", "log"])
    
    # -------------------------------------------------------------------------
    # CONFIGURATION DES R√âPERTOIRES DE SORTIE
    # -------------------------------------------------------------------------
    
    targetdir("%{wks.location}/Build/Bin/%{cfg.buildcfg}")
    objdir("%{wks.location}/Build/Obj/%{cfg.buildcfg}/%{prj.name}")
    
    # -------------------------------------------------------------------------
    # CONFIGURATIONS DE BUILD
    # -------------------------------------------------------------------------
    
    # Configuration Debug
    with filter("configurations:Debug"):
        defines(["DEBUG"])
        optimize("Off")
        symbols("On")
    
    # Configuration Release
    with filter("configurations:Release"):
        defines(["NDEBUG"])
        optimize("Speed")
        symbols("Off")
==================================================


üìÅ DOSSIER: Sandbox\src
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[FICHIER: Sandbox\src\Main.cpp]
==================================================
#include <Unkeny2D/Window/Window.h>
#include <Unkeny2D/Events/EventManager.h>
#include <Nkentseu/Sleep.h>
#include <Nkentseu/Config/Platform.h>
#include <Nkentseu/Config/Compiler.h>
#include <Nkentseu/Config/Architecture.h>
#include <Unkeny2D/Unkeny.h>
#include <Logger/Log.h>  // Inclure Defaultlog
#include <Logger/Sinks/ConsoleSink.h>
#include <Logger/Sinks/FileSink.h>
#include <iostream>
#include <cmath>

using namespace nkentseu;
using namespace nkentseu::logger;

/**
 * @brief Fonction principale de l'application
 */
int nkmain(int argc, char* argv[]) {
    // -------------------------------------------------------------------------
    // INITIALISATION DU LOGGING
    // -------------------------------------------------------------------------
    
    // Initialiser le log par d√©faut avec configuration personnalis√©e
    NkentseuLogger::Initialize("SandboxApp", "[%Y-%m-%d %H:%M:%S.%e] [%L] [%n] [%s] [%#] [%F] -> %v", LogLevel::Trace);
    
    // OU utiliser l'API fluide pour configurer
    // Defaultlog::Instance()
    //     .Named("SandboxApp")
    //     .Pattern("[%Y-%m-%d %H:%M:%S.%e] [%L] [%n] [%s:%#] %v")
    //     .Level(LogLevel::Debug);
    
    // -------------------------------------------------------------------------
    // LOGGING DE D√âBUT (avec la macro 'log' qui capture file/line/function)
    // -------------------------------------------------------------------------
    
    logs.Info("======================================");
    logs.Info("  Unkeny2D - Cross-Platform Window");
    logs.Info("  Platform: %s", GetPlatformName());
    logs.Info("  Architecture: %s", GetArchitectureName());
    logs.Info("  Compiler: %s", GetCompilerName());
    logs.Info("======================================");
    
    // -------------------------------------------------------------------------
    // CR√âATION DE LA FEN√äTRE
    // -------------------------------------------------------------------------
    
    logs.Debug("Creating window...");
    Window* window = Window::Create("Unkeny2D Demo", 1280, 720);
    
    if (!window || !window->Initialize()) {
        logs.Error("Failed to create window");
        logs.Critical("Application initialization failed");
        return 1;
    }
    
    window->Show();
    logs.Info("Window created successfully (ID: %u)", window->GetID());
    
    // -------------------------------------------------------------------------
    // VARIABLES DE BOUCLE PRINCIPALE
    // -------------------------------------------------------------------------
    
    bool running = true;
    uint64 frameCount = 0;
    float clearColorR = 0.2f;
    
    // -------------------------------------------------------------------------
    // BOUCLE PRINCIPALE
    // -------------------------------------------------------------------------
    
    logs.Info("Entering main loop...");
    
    while (running) {
        // ---------------------------------------------------------------------
        // TRAITEMENT DES √âV√âNEMENTS
        // ---------------------------------------------------------------------
        
        while (auto event = EventManager::PollEvent()) {
            if (const auto* closed = event->GetIf<WindowClosedEvent>()) {
                if (closed->GetWindowID() == window->GetID()) {
                    logs.Info("Window closed event received");
                    running = false;
                }
            }
            
            if (const auto* keyPressed = event->GetIf<KeyPressedEvent>()) {
                if (keyPressed->GetKeyCode() == KeyCode::Escape) {
                    logs.Warn("Escape key pressed - hiding window");
                    window->Hide();
                } else if (keyPressed->GetKeyCode() == KeyCode::F1) {
                    logs.Trace("F1 pressed - toggling trace logging");
                    // Changer le niveau de log
                    logs.Level(logs.GetLevel() == LogLevel::Trace ? 
                        LogLevel::Info : LogLevel::Trace
                    );
                }
            }
            
            else if (const auto* resized = event->GetIf<WindowResizedEvent>()) {
                logs.Info("Window resized to %ux%u", 
                          resized->GetWidth(), resized->GetHeight());
            }
            
            else if (const auto* mouseMoved = event->GetIf<MouseMovedEvent>()) {
                logs.Trace("Mouse moved to (%.1f, %.1f)", 
                           mouseMoved->GetX(), mouseMoved->GetY());
            }
        }
        
        // ---------------------------------------------------------------------
        // MISE √Ä JOUR
        // ---------------------------------------------------------------------
        
        frameCount++;
        
        // Animation simple de couleur
        clearColorR = 0.2f + 0.1f * std::sin(static_cast<float>(frameCount) * 0.01f);
        
        if (frameCount % 100 == 0) {
            // logs.Debug("Frame %llu, color R: %.3f", frameCount, clearColorR);
        }
        
        // ---------------------------------------------------------------------
        // RENDU
        // ---------------------------------------------------------------------
        
        Color clearColor(clearColorR, 0.3f, 0.4f, 1.0f);
        window->Clear(clearColor);
        window->SwapBuffers();
        
        // ---------------------------------------------------------------------
        // PAUSE
        // ---------------------------------------------------------------------
        
        SleepMilli(1);
    }
    
    // -------------------------------------------------------------------------
    // FINALISATION
    // -------------------------------------------------------------------------
    
    logs.Info("Exiting main loop");
    logs.Info("Total frames rendered: %llu", frameCount);
    
    delete window;
    
    logs.Info("Application shutdown complete");
    logs.Info("======================================");
    
    // Flush final des logs
    logs.Flush();
    
    return 0;
}
==================================================

